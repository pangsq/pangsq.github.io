<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Gin路由分析（二）"><meta name="keywords" content="Golang,Gin,Router"><meta name="author" content="锋寒"><meta name="copyright" content="锋寒"><title>Gin路由分析（二） | 锋寒的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#路由的注册"><span class="toc-number">1.</span> <span class="toc-text">路由的注册</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#node"><span class="toc-number">1.1.</span> <span class="toc-text">node</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#node-addRoute"><span class="toc-number">1.1.1.</span> <span class="toc-text">node.addRoute</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#node-insertChild"><span class="toc-number">1.1.2.</span> <span class="toc-text">node.insertChild</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#路由的使用"><span class="toc-number">2.</span> <span class="toc-text">路由的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#路由的检索"><span class="toc-number">3.</span> <span class="toc-text">路由的检索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Gin的不足"><span class="toc-number">5.</span> <span class="toc-text">Gin的不足</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">锋寒</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">10</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">27</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">锋寒的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Gin路由分析（二）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Gin/">Gin</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>The fastest full-featured web framework for Go.</p>
</blockquote>
<blockquote>
<p>Radix tree based routing, small memory foot print. No reflection. Predictable API performance.</p>
</blockquote>
<p>官方声称Gin是最快的功能完整的Go web框架，本文研究下其实现细节。</p>
<h2 id="路由的注册"><a href="#路由的注册" class="headerlink" title="路由的注册"></a>路由的注册</h2><p>前一篇文章分析中已知handler最终落到<code>group.engine.addRoute(httpMethod, absolutePath, handlers)</code>，所以本文从addRoute开始分析。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">addRoute</span><span class="params">(method, path <span class="keyword">string</span>, handlers HandlersChain)</span></span> &#123;</span><br><span class="line">	... <span class="comment">// 1. 参数检查与打印一些调试信息</span></span><br><span class="line">	root := engine.trees.get(method)</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="comment">// 2. 惰性创建相关method的root node</span></span><br><span class="line">		root = <span class="built_in">new</span>(node)</span><br><span class="line">		root.fullPath = <span class="string">"/"</span></span><br><span class="line">		engine.trees = <span class="built_in">append</span>(engine.trees, methodTree&#123;method: method, root: root&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 3. 往root node中注册handlers</span></span><br><span class="line">	root.addRoute(path, handlers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这段代码中我们还知道这么几件事：</p>
<ol>
<li>path -&gt; handlers的映射关系维护在tree(node)中</li>
<li>每个method一个独立的tree</li>
<li>从命名上我们可以大致猜测出这就是个树形结构</li>
</ol>
<p>在更深入实现细节前，先回顾下<code>路由参数</code>的概念。</p>
<p>url路径中存在两种通配符。<code>:</code>可以匹配一段路径，<code>*</code>可以匹配0或n段路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.) path &#x3D; &#x2F;user&#x2F;:name  </span><br><span class="line"></span><br><span class="line">此handler会匹配 &#x2F;user&#x2F;john 但不会匹配 &#x2F;user&#x2F; 或者 &#x2F;user</span><br><span class="line"></span><br><span class="line">2.) path &#x3D; &#x2F;user&#x2F;:name&#x2F;*action</span><br><span class="line">此 handler 将匹配 &#x2F;user&#x2F;john&#x2F; 和 &#x2F;user&#x2F;john&#x2F;send</span><br><span class="line">如果没有其他路由匹配 &#x2F;user&#x2F;john，它将重定向到 &#x2F;user&#x2F;john&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><p>再来看看node的数据结构。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	path      <span class="keyword">string</span>	<span class="comment">// 当前节点path，一段或多段segment，例如 /a/b，/:param等等</span></span><br><span class="line">	indices   <span class="keyword">string</span>	<span class="comment">// 索引，存储子节点的首字符</span></span><br><span class="line">	children  []*node	<span class="comment">// 子节点</span></span><br><span class="line">	handlers  HandlersChain	<span class="comment">// handlers方法</span></span><br><span class="line">	priority  <span class="keyword">uint32</span>	<span class="comment">// 路径包含该节点的handler数量，即路由经由该节点的handler数</span></span><br><span class="line">	nType     nodeType	<span class="comment">// 节点类型</span></span><br><span class="line">	maxParams <span class="keyword">uint8</span>		<span class="comment">// 该节点之后的路径参数个数</span></span><br><span class="line">	wildChild <span class="keyword">bool</span>		<span class="comment">// child是否为通配符，若true，则其child的path就带:或*</span></span><br><span class="line">	fullPath  <span class="keyword">string</span>	<span class="comment">// 完整路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点类型</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	static nodeType = <span class="literal">iota</span> <span class="comment">// default // 普通节点，不含路径参数</span></span><br><span class="line">	root	<span class="comment">// 根节点</span></span><br><span class="line">	param	<span class="comment">// 路径参数节点，通配符:代表的节点</span></span><br><span class="line">	catchAll	<span class="comment">// 通配符*代表的节点</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>此外还有几个结构体要注意，先列出来：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Param <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key   <span class="keyword">string</span></span><br><span class="line">	Value <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Params []Param</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> methodTree <span class="keyword">struct</span> &#123;</span><br><span class="line">	method <span class="keyword">string</span></span><br><span class="line">	root   *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> methodTrees []methodTree</span><br></pre></td></tr></table></figure>

<h4 id="node-addRoute"><a href="#node-addRoute" class="headerlink" title="node.addRoute"></a>node.addRoute</h4><p>分析下engine.addRoute最终调用的node.addRoute方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">addRoute</span><span class="params">(path <span class="keyword">string</span>, handlers HandlersChain)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注意：随着代码的进行，n可能指向不同的对象，path也在不断地缩短，handlers保持不变</span></span><br><span class="line">	fullPath := path</span><br><span class="line">	n.priority++</span><br><span class="line">	numParams := countParams(path)	<span class="comment">// 计算路径参数个数，即path中:和*的个数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前节点没有设置path和children，则只可能是root节点，直接调用insertChild（见下一小节）</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(n.path) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(n.children) == <span class="number">0</span> &#123;</span><br><span class="line">		n.insertChild(numParams, path, fullPath, handlers)</span><br><span class="line">		n.nType = root</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	parentFullPathIndex := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">walk:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Update maxParams of the current node</span></span><br><span class="line">		<span class="keyword">if</span> numParams &gt; n.maxParams &#123;</span><br><span class="line">			n.maxParams = numParams</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 找到path和当前node.path的最长前缀；其中不可能包含:或*</span></span><br><span class="line">		i := longestCommonPrefix(path, n.path)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Split edge</span></span><br><span class="line">		<span class="comment">// node.path并不是path的前缀，h则进行对node的拆分</span></span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(n.path) &#123;</span><br><span class="line">			child := node&#123;	<span class="comment">// 新节点继承了原节点的一切</span></span><br><span class="line">				path:      n.path[i:],	<span class="comment">// 公共前缀之后的路径</span></span><br><span class="line">				wildChild: n.wildChild,</span><br><span class="line">				indices:   n.indices,</span><br><span class="line">				children:  n.children,</span><br><span class="line">				handlers:  n.handlers,</span><br><span class="line">				priority:  n.priority - <span class="number">1</span>,	<span class="comment">// 新节点权重减小</span></span><br><span class="line">				fullPath:  n.fullPath,</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Update maxParams (max of all children)</span></span><br><span class="line">			<span class="keyword">for</span> _, v := <span class="keyword">range</span> child.children &#123;</span><br><span class="line">				<span class="keyword">if</span> v.maxParams &gt; child.maxParams &#123;</span><br><span class="line">					child.maxParams = v.maxParams</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			n.children = []*node&#123;&amp;child&#125;	<span class="comment">// node的子节点只有刚创建的节点</span></span><br><span class="line">			<span class="comment">// []byte for proper unicode char conversion, see #65</span></span><br><span class="line">			n.indices = <span class="keyword">string</span>([]<span class="keyword">byte</span>&#123;n.path[i]&#125;)</span><br><span class="line">			n.path = path[:i] <span class="comment">// node的path被截断</span></span><br><span class="line">			n.handlers = <span class="literal">nil</span>	<span class="comment">// 注册的handlers被置为空</span></span><br><span class="line">			n.wildChild = <span class="literal">false</span></span><br><span class="line">			n.fullPath = fullPath[:parentFullPathIndex+i] <span class="comment">// fullPath被截断</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Make new node a child of this node</span></span><br><span class="line">		<span class="comment">// path并不是node.path的前缀，需要在当前node之后挂新的child</span></span><br><span class="line">		<span class="comment">// 由于此前已经截断过node.path，所以此处判断的前提是node.path必然已是path的前缀</span></span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(path) &#123;</span><br><span class="line">			path = path[i:]	<span class="comment">// 去除与node.path的公共前缀，剩下的path才是需要处理的</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> n.wildChild &#123;	<span class="comment">// 通过阅读node.insertChild，可知wildChild节点之后的节点必然是通配符节点</span></span><br><span class="line">				parentFullPathIndex += <span class="built_in">len</span>(n.path)</span><br><span class="line">				n = n.children[<span class="number">0</span>]	<span class="comment">// 通配符节点</span></span><br><span class="line">				n.priority++</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Update maxParams of the child node</span></span><br><span class="line">				<span class="keyword">if</span> numParams &gt; n.maxParams &#123;</span><br><span class="line">					n.maxParams = numParams</span><br><span class="line">				&#125;</span><br><span class="line">				numParams--	<span class="comment">// 由于当前节点为wildChild则表示下一个节点必然是通配符节点，numParams可先减1</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// Check if the wildcard matches</span></span><br><span class="line">				<span class="comment">// 判断n.path是当前path的前缀</span></span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(path) &gt;= <span class="built_in">len</span>(n.path) &amp;&amp; n.path == path[:<span class="built_in">len</span>(n.path)] &#123;</span><br><span class="line">					<span class="comment">// check for longer wildcard, e.g. :name and :names</span></span><br><span class="line">					<span class="comment">// len(n.path)&gt;=len(path)结合上一判断条件，代表n.path完全等于path</span></span><br><span class="line">					<span class="comment">// 或者path是n.path头部的一或n个segemt</span></span><br><span class="line">					<span class="keyword">if</span> <span class="built_in">len</span>(n.path) &gt;= <span class="built_in">len</span>(path) || path[<span class="built_in">len</span>(n.path)] == <span class="string">'/'</span> &#123;</span><br><span class="line">						<span class="comment">// 例如：</span></span><br><span class="line">						<span class="comment">// path=:a和n.path=:a能够match</span></span><br><span class="line">						<span class="comment">// path=:a/a和n.path=:a能够match</span></span><br><span class="line">						<span class="comment">// path=:aa和n.path=:a不能match</span></span><br><span class="line">						<span class="comment">// path=:a和n.path=:aa不能match</span></span><br><span class="line">						<span class="keyword">continue</span> walk</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 若不能匹配，将会panic</span></span><br><span class="line">			</span><br><span class="line">				...</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 经过之前的处理，目前的情况如下</span></span><br><span class="line">			<span class="comment">// 1. node.path与（此时的）path已无交集</span></span><br><span class="line">			<span class="comment">// 2. node非wildChild</span></span><br><span class="line">			<span class="comment">// 接下来要做的就是基于剩下的path构建新节点，注册为node的child</span></span><br><span class="line"></span><br><span class="line">			c := path[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">			<span class="comment">// slash after param</span></span><br><span class="line">			<span class="comment">// param节点之后还存在节点的情况下，此时c == '/'表示当前path并不以通配符起始，取子节点代替node，直接进入下一轮</span></span><br><span class="line">			<span class="keyword">if</span> n.nType == param &amp;&amp; c == <span class="string">'/'</span> &amp;&amp; <span class="built_in">len</span>(n.children) == <span class="number">1</span> &#123;</span><br><span class="line">				parentFullPathIndex += <span class="built_in">len</span>(n.path)</span><br><span class="line">				n = n.children[<span class="number">0</span>]</span><br><span class="line">				n.priority++</span><br><span class="line">				<span class="keyword">continue</span> walk</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check if a child with the next path byte exists</span></span><br><span class="line">			<span class="comment">// 遍历indices，找到与c匹配的child，修改所有child的权重</span></span><br><span class="line">			<span class="comment">// 将node置为匹配的child，进入下一轮</span></span><br><span class="line">			<span class="keyword">for</span> i, max := <span class="number">0</span>, <span class="built_in">len</span>(n.indices); i &lt; max; i++ &#123;</span><br><span class="line">				<span class="keyword">if</span> c == n.indices[i] &#123;</span><br><span class="line">					parentFullPathIndex += <span class="built_in">len</span>(n.path)</span><br><span class="line">					i = n.incrementChildPrio(i)</span><br><span class="line">					n = n.children[i]</span><br><span class="line">					<span class="keyword">continue</span> walk</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Otherwise insert it</span></span><br><span class="line">			<span class="comment">// 没有任何一个child的path和当前的path有公共前缀，且c非通配符的情况下</span></span><br><span class="line">			<span class="keyword">if</span> c != <span class="string">':'</span> &amp;&amp; c != <span class="string">'*'</span> &#123;</span><br><span class="line">				<span class="comment">// []byte for proper unicode char conversion, see #65</span></span><br><span class="line">				n.indices += <span class="keyword">string</span>([]<span class="keyword">byte</span>&#123;c&#125;)</span><br><span class="line">				<span class="comment">// 创建一个全新的节点，加入到node的children中，并调整所有之前已存在的child的权重</span></span><br><span class="line">				child := &amp;node&#123;</span><br><span class="line">					maxParams: numParams,</span><br><span class="line">					fullPath:  fullPath,</span><br><span class="line">				&#125;</span><br><span class="line">				n.children = <span class="built_in">append</span>(n.children, child)</span><br><span class="line">				n.incrementChildPrio(<span class="built_in">len</span>(n.indices) - <span class="number">1</span>)</span><br><span class="line">				n = child</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 调用insertChild完成节点的注册</span></span><br><span class="line">			n.insertChild(numParams, path, fullPath, handlers)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Otherwise and handle to current node</span></span><br><span class="line">		<span class="keyword">if</span> n.handlers != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"handlers are already registered for path '"</span> + fullPath + <span class="string">"'"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 此时node.path == path</span></span><br><span class="line">		n.handlers = handlers</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要流程：</p>
<ol>
<li>如果是root节点，直接调用insertChild</li>
<li>非root节点时，进入walk loop<ol>
<li>计算当前node.path和path的公共前缀</li>
<li>假设node.path并不是path的前缀<ol>
<li>新建一个节点，将原节点的一系列数据转移过去</li>
<li>原节点的path置为计算出的公共前缀，将其他信息重置</li>
<li>node指向新节点</li>
</ol>
</li>
<li>经过一番处理，此时的node.path必然已是path的前缀<ol>
<li>当node.path与path不相等时（node.path是path的前缀，但不是完整的path）<ol>
<li>path减去前缀node.path部分</li>
<li>如果当前node是wildChild<ol>
<li>node直接指向其child</li>
<li>确保当前path不会与node.path产生冲突</li>
<li>直接进入下一轮</li>
</ol>
</li>
<li>如果当前node为param节点，且存在child，而且path以/起始。以child替换node，进入下一轮</li>
<li>遍历indices，寻找与c匹配的indice。若找到则调整所有child的权重，并以匹配的child替换node，进入下一轮</li>
<li>如果当前node的所有child的path都和当前path无公共前缀，则往node的children中添加新节点，node指向新节点</li>
<li>调用insertChild</li>
</ol>
</li>
<li>当node.path与path完全相等时，直接往node上注册handlers</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="node-insertChild"><a href="#node-insertChild" class="headerlink" title="node.insertChild"></a>node.insertChild</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">insertChild</span><span class="params">(numParams <span class="keyword">uint8</span>, path <span class="keyword">string</span>, fullPath <span class="keyword">string</span>, handlers HandlersChain)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注意：n指向的对象在下面的代码中可能会不断变化，path会不断缩短，fullPath/handlers会保持不变</span></span><br><span class="line">	<span class="keyword">for</span> numParams &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Find prefix until first wildcard</span></span><br><span class="line">		wildcard, i, valid := findWildcard(path) <span class="comment">// 找到第一个通配符，返回该通配符的segment和其位置，并检验是否合法（通配符后接/或处于path末尾是合法的，即不存在两个连续的通配符）</span></span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="number">0</span> &#123; <span class="comment">// No wildcard found // 当前path中已不存在通配符的情况下跳出循环；在整个for循环中，path的长度会不断减少</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		... </span><br><span class="line">		<span class="comment">// 进行检查 确保满足：</span></span><br><span class="line">		<span class="comment">// 1. path中通配符合法，即一个segment只存在一个:或*</span></span><br><span class="line">		<span class="comment">// 2. 路径参数必须有一个名字，所以该segment长度必须大于1</span></span><br><span class="line">		<span class="comment">// 3. node不允许已存在child</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> wildcard[<span class="number">0</span>] == <span class="string">':'</span> &#123; <span class="comment">// param // 当前path的第一个segment是通配符:</span></span><br><span class="line">			<span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// 设置parent的path，这是一段不含任何通配符的path</span></span><br><span class="line">				n.path = path[:i]</span><br><span class="line">				<span class="comment">// 从通配符开始的剩余path</span></span><br><span class="line">				path = path[i:]</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			n.wildChild = <span class="literal">true</span> <span class="comment">// 指明是通配符节点</span></span><br><span class="line">			child := &amp;node&#123;		<span class="comment">// 创建新节点</span></span><br><span class="line">				nType:     param,     <span class="comment">// 节点类型</span></span><br><span class="line">				path:      wildcard,  <span class="comment">// 当前节点的path，由于是wildcard，实则就是一段segment</span></span><br><span class="line">				maxParams: numParams, <span class="comment">// 从当前节点往后（递归遍历其child）存在多少个param</span></span><br><span class="line">				fullPath:  fullPath, <span class="comment">// handler的完整路径，后续搜索时可以根据这个判断，node是否可对应handler</span></span><br><span class="line">			&#125;</span><br><span class="line">			n.children = []*node&#123;child&#125; <span class="comment">// 将创建的节点注册为父亲节点的child</span></span><br><span class="line">			n = child		<span class="comment">// 之后若继续处理，则以刚创建的child为父亲节点</span></span><br><span class="line">			n.priority++	<span class="comment">// 即将刚创建的child的priority设置为1</span></span><br><span class="line">			numParams--		<span class="comment">// 剩余路径参数减少</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果当前处理的segment不是最后一段，那么为剩余的path创建新的子节点，进入下一轮</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(wildcard) &lt; <span class="built_in">len</span>(path) &#123;</span><br><span class="line">				path = path[<span class="built_in">len</span>(wildcard):]</span><br><span class="line"></span><br><span class="line">				child := &amp;node&#123;</span><br><span class="line">					maxParams: numParams,</span><br><span class="line">					priority:  <span class="number">1</span>,</span><br><span class="line">					fullPath:  fullPath,</span><br><span class="line">				&#125;</span><br><span class="line">				n.children = []*node&#123;child&#125;</span><br><span class="line">				n = child</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 直到path不再有剩余，设置handlers并结束</span></span><br><span class="line">			n.handlers = handlers</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 排除当前第一个segment是通配符:的情况，剩下自然是处理*的情况，剩下自然是处理</span></span><br><span class="line">		<span class="comment">// 由于*可以匹配0或n个segment，所以最终只会往parent上注册一个child就可以，而不需要考虑child的child</span></span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 进行检查 确保满足</span></span><br><span class="line">		<span class="comment">// 1. 含*的segment之后没有其他segment；当前path中只存在一个通配符</span></span><br><span class="line">		<span class="comment">// 2. parent的path不以/结尾</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// currently fixed width 1 for '/'</span></span><br><span class="line">		i--</span><br><span class="line">		<span class="keyword">if</span> path[i] != <span class="string">'/'</span> &#123; <span class="comment">// 确保*前是/</span></span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"no / before catch-all in path '"</span> + fullPath + <span class="string">"'"</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		n.path = path[:i]</span><br><span class="line"></span><br><span class="line">		<span class="comment">// First node: catchAll node with empty path</span></span><br><span class="line">		child := &amp;node&#123;</span><br><span class="line">			wildChild: <span class="literal">true</span>,</span><br><span class="line">			nType:     catchAll,</span><br><span class="line">			maxParams: <span class="number">1</span>,</span><br><span class="line">			fullPath:  fullPath,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// update maxParams of the parent node</span></span><br><span class="line">		<span class="keyword">if</span> n.maxParams &lt; <span class="number">1</span> &#123;</span><br><span class="line">			n.maxParams = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		n.children = []*node&#123;child&#125;</span><br><span class="line">		n.indices = <span class="keyword">string</span>(<span class="string">'/'</span>)</span><br><span class="line">		n = child</span><br><span class="line">		n.priority++ <span class="comment">//priority设置为1</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// second node: node holding the variable</span></span><br><span class="line">		child = &amp;node&#123;</span><br><span class="line">			path:      path[i:],</span><br><span class="line">			nType:     catchAll,</span><br><span class="line">			maxParams: <span class="number">1</span>,</span><br><span class="line">			handlers:  handlers,</span><br><span class="line">			priority:  <span class="number">1</span>,</span><br><span class="line">			fullPath:  fullPath,</span><br><span class="line">		&#125;</span><br><span class="line">		n.children = []*node&#123;child&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If no wildcard was found, simply insert the path and handle</span></span><br><span class="line">	n.path = path</span><br><span class="line">	n.handlers = handlers</span><br><span class="line">	n.fullPath = fullPath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要流程：</p>
<ol>
<li>在numParams &gt; 0的情况下，循环处理path中剩余的含通配符的segment<ol>
<li>取出当前path中最前面的通配符segment</li>
<li>如果含通配符:<ol>
<li>如果该segment之前还有静态路径，将node的path设置为该segment之前的静态路径</li>
<li>创建一个param类型的node作为其child</li>
<li>如果该segment还没到path尾部，则再创建一个param类型的node作为child的child，之后处理的node转为这个最新的child</li>
<li>如果该segment已到path尾部，则注册handlers，并结束整个方法</li>
</ol>
</li>
<li>如果含通配符*<ol>
<li>将node的path设置为该segment之前的静态路径（不含/）</li>
<li>创建一个catchAll类型节点，作为node的child</li>
<li>再创建一个catchAll类型节点，作为前一个节点的child，其path为这段segment，handlers注册在这个节点上</li>
<li>结束整个方法</li>
</ol>
</li>
</ol>
</li>
<li>当numParams == 0，即不存在路由参数的情况下，直接设置n.path/handlers/fullPath</li>
</ol>
<h2 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h2><p>存入trees中的router和handlers在什么时候使用？</p>
<p>下方是相应的调用链，不细展开了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(address, engine) -&gt; engine.ServeHTTP(writer, req) -&gt; engine.handleHTTPRequest(c) -&gt; root.getValue(rPath, c.Params, unescape)</span><br></pre></td></tr></table></figure>

<h2 id="路由的检索"><a href="#路由的检索" class="headerlink" title="路由的检索"></a>路由的检索</h2><p>接下来从getValue出发，研究下Gin是怎么根据url定位到相应handlers的。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">getValue</span><span class="params">(path <span class="keyword">string</span>, po Params, unescape <span class="keyword">bool</span>)</span> <span class="params">(value nodeValue)</span></span> &#123;</span><br><span class="line">	value.params = po</span><br><span class="line">walk: <span class="comment">// Outer loop for walking the tree</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		prefix := n.path</span><br><span class="line">		<span class="comment">// path == n.path</span></span><br><span class="line">		<span class="keyword">if</span> path == prefix &#123;</span><br><span class="line">			<span class="comment">// 若node.handlers不为空，则返回注册的handlers</span></span><br><span class="line">			<span class="keyword">if</span> value.handlers = n.handlers; value.handlers != <span class="literal">nil</span> &#123;</span><br><span class="line">				value.fullPath = n.fullPath</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 当path为"/"且wildChild为true时，设置重定向</span></span><br><span class="line">			<span class="keyword">if</span> path == <span class="string">"/"</span> &amp;&amp; n.wildChild &amp;&amp; n.nType != root &#123;</span><br><span class="line">				value.tsr = <span class="literal">true</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果children中某个child的path以/开始，满足以下任一情况时，设置重定向</span></span><br><span class="line">			<span class="comment">// 1. 该child的path就是/，且handlers非nil</span></span><br><span class="line">			<span class="comment">// 2. 该child是catchAll类型，且子child的handlers非nil（这里的逻辑有点不能理解，按前面分析的insertChild方法，树上只有通配符*会产生连续的两个catchAll节点，而第一个catchAll节点的path是空的，不可能满足此处的条件</span></span><br><span class="line">			indices := n.indices</span><br><span class="line">			<span class="keyword">for</span> i, max := <span class="number">0</span>, <span class="built_in">len</span>(indices); i &lt; max; i++ &#123;</span><br><span class="line">				<span class="keyword">if</span> indices[i] == <span class="string">'/'</span> &#123;</span><br><span class="line">					n = n.children[i]</span><br><span class="line">					value.tsr = (<span class="built_in">len</span>(n.path) == <span class="number">1</span> &amp;&amp; n.handlers != <span class="literal">nil</span>) ||</span><br><span class="line">						(n.nType == catchAll &amp;&amp; n.children[<span class="number">0</span>].handlers != <span class="literal">nil</span>)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// node.path是path前缀的情况</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; <span class="built_in">len</span>(prefix) &amp;&amp; path[:<span class="built_in">len</span>(prefix)] == prefix &#123;</span><br><span class="line">			path = path[<span class="built_in">len</span>(prefix):]	<span class="comment">// 截断path</span></span><br><span class="line">			<span class="comment">// 非wildChild的情况，因为wildChild的话，直接处理child即可</span></span><br><span class="line">			<span class="keyword">if</span> !n.wildChild &#123;</span><br><span class="line">				c := path[<span class="number">0</span>]</span><br><span class="line">				indices := n.indices</span><br><span class="line">				<span class="comment">// 根据indices快速（？）寻找匹配的child，进入下一轮</span></span><br><span class="line">				<span class="keyword">for</span> i, max := <span class="number">0</span>, <span class="built_in">len</span>(indices); i &lt; max; i++ &#123;</span><br><span class="line">					<span class="keyword">if</span> c == indices[i] &#123;</span><br><span class="line">						n = n.children[i]</span><br><span class="line">						<span class="keyword">continue</span> walk</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 没有匹配的child的话，如果path为/且当前nodes含handlers，则设置重定向</span></span><br><span class="line">				<span class="comment">// 例如 当前url中是 /a/b/c/，而注册在案的路由只有 /a/b/c，那么就可以顺利地进行重定向</span></span><br><span class="line">				value.tsr = path == <span class="string">"/"</span> &amp;&amp; n.handlers != <span class="literal">nil</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 对于wildChild，直接处理其child</span></span><br><span class="line">			n = n.children[<span class="number">0</span>]</span><br><span class="line">			<span class="keyword">switch</span> n.nType &#123;</span><br><span class="line">			<span class="keyword">case</span> param:</span><br><span class="line">				<span class="comment">// 找到:能匹配到的一段segment</span></span><br><span class="line">				end := <span class="number">0</span></span><br><span class="line">				<span class="keyword">for</span> end &lt; <span class="built_in">len</span>(path) &amp;&amp; path[end] != <span class="string">'/'</span> &#123;</span><br><span class="line">					end++</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 扩容params，达到必然满足要求的最小容量</span></span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">cap</span>(value.params) &lt; <span class="keyword">int</span>(n.maxParams) &#123;</span><br><span class="line">					value.params = <span class="built_in">make</span>(Params, <span class="number">0</span>, n.maxParams)</span><br><span class="line">				&#125;</span><br><span class="line">				i := <span class="built_in">len</span>(value.params)</span><br><span class="line">				value.params = value.params[:i+<span class="number">1</span>] <span class="comment">// expand slice within preallocated capacity</span></span><br><span class="line">				<span class="comment">// param的键</span></span><br><span class="line">				value.params[i].Key = n.path[<span class="number">1</span>:]</span><br><span class="line">				<span class="comment">// 从path中获取param对应的值</span></span><br><span class="line">				val := path[:end]</span><br><span class="line">				<span class="comment">// 转义</span></span><br><span class="line">				<span class="keyword">if</span> unescape &#123;</span><br><span class="line">					<span class="keyword">var</span> err error</span><br><span class="line">					<span class="keyword">if</span> value.params[i].Value, err = url.QueryUnescape(val); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						value.params[i].Value = val <span class="comment">// fallback, in case of error</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					value.params[i].Value = val</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 由上面逻辑可知，params与path中实际的路由参数组是逆序的</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// 还未到path末尾的话，则截断path，node指向child，继续</span></span><br><span class="line">				<span class="keyword">if</span> end &lt; <span class="built_in">len</span>(path) &#123;</span><br><span class="line">					<span class="keyword">if</span> <span class="built_in">len</span>(n.children) &gt; <span class="number">0</span> &#123;</span><br><span class="line">						path = path[end:]</span><br><span class="line">						n = n.children[<span class="number">0</span>]</span><br><span class="line">						<span class="keyword">continue</span> walk</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 如果没有children可用了，则重定向</span></span><br><span class="line">					value.tsr = <span class="built_in">len</span>(path) == end+<span class="number">1</span></span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> value.handlers = n.handlers; value.handlers != <span class="literal">nil</span> &#123;</span><br><span class="line">					value.fullPath = n.fullPath</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(n.children) == <span class="number">1</span> &#123;</span><br><span class="line">					<span class="comment">// 重定向</span></span><br><span class="line">					n = n.children[<span class="number">0</span>]</span><br><span class="line">					value.tsr = n.path == <span class="string">"/"</span> &amp;&amp; n.handlers != <span class="literal">nil</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="comment">// 直接将路由参数匹配完剩下的path</span></span><br><span class="line">			<span class="keyword">case</span> catchAll:</span><br><span class="line">				<span class="comment">// save param value</span></span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">cap</span>(value.params) &lt; <span class="keyword">int</span>(n.maxParams) &#123;</span><br><span class="line">					value.params = <span class="built_in">make</span>(Params, <span class="number">0</span>, n.maxParams)</span><br><span class="line">				&#125;</span><br><span class="line">				i := <span class="built_in">len</span>(value.params)</span><br><span class="line">				value.params = value.params[:i+<span class="number">1</span>] <span class="comment">// expand slice within preallocated capacity</span></span><br><span class="line">				value.params[i].Key = n.path[<span class="number">2</span>:]</span><br><span class="line">				<span class="keyword">if</span> unescape &#123;</span><br><span class="line">					<span class="keyword">var</span> err error</span><br><span class="line">					<span class="keyword">if</span> value.params[i].Value, err = url.QueryUnescape(path); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						value.params[i].Value = path <span class="comment">// fallback, in case of error</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					value.params[i].Value = path</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				value.handlers = n.handlers</span><br><span class="line">				value.fullPath = n.fullPath</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">"invalid node type"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 重定向</span></span><br><span class="line">		value.tsr = (path == <span class="string">"/"</span>) ||</span><br><span class="line">			(<span class="built_in">len</span>(prefix) == <span class="built_in">len</span>(path)+<span class="number">1</span> &amp;&amp; prefix[<span class="built_in">len</span>(path)] == <span class="string">'/'</span> &amp;&amp;</span><br><span class="line">				path == prefix[:<span class="built_in">len</span>(prefix)<span class="number">-1</span>] &amp;&amp; n.handlers != <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本阅读完了Gin的router模块（<a href="https://github.com/julienschmidt/httprouter" target="_blank" rel="noopener">https://github.com/julienschmidt/httprouter</a> 也就是这个项目），其对于radix的处理逻辑有点复杂，但大致思想我们已可以感受到。</p>
<p>所以Gin为什么快，源于其Radix的实现，令具有公共前缀的路由尽可能地复用相同的节点，使得树的深度尽量浅，以获得高效的查询效率。</p>
<p>举个例子，需要组建如下所示的路由：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">"/ping"</span>, <span class="literal">nil</span>)</span><br><span class="line">r.GET(<span class="string">"/p/*segs"</span>, <span class="literal">nil</span>))</span><br><span class="line">r.GET(<span class="string">"/ping/:seg"</span>, <span class="literal">nil</span>)</span><br><span class="line">r.Group(<span class="string">"/v1"</span>).GET(<span class="string">"/get"</span>))</span><br></pre></td></tr></table></figure>

<p>最终内存中树结构看起来是这样的：</p>
<img src="/2020/05/01/gin_router_2/index/radix.png" width="1000" height="600" align="center">


<h2 id="Gin的不足"><a href="#Gin的不足" class="headerlink" title="Gin的不足"></a>Gin的不足</h2><p>Gin在使用路由参数时依旧存在一些bug，与依赖的httprouter项目一直没修复相关，所以目前还没看到有改进计划，见<a href="https://github.com/gin-gonic/gin/issues/2016" target="_blank" rel="noopener">https://github.com/gin-gonic/gin/issues/2016</a></p>
<p>bug例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1) 同一位值，参数和静态路径冲突</span><br><span class="line">r.GET(&quot;&#x2F;ping&#x2F;:seg&#x2F;1&quot;, nil)</span><br><span class="line">r.GET(&quot;&#x2F;ping&#x2F;seg&#x2F;1&quot;, nil)</span><br><span class="line"></span><br><span class="line">2）同一位置，不同名的参数冲突</span><br><span class="line">r.GET(&quot;&#x2F;ping&#x2F;:seg&#x2F;1&quot;, nil)</span><br><span class="line">r.GET(&quot;&#x2F;ping&#x2F;:se&quot;, nil)</span><br><span class="line">或者</span><br><span class="line">r.GET(&quot;&#x2F;ping&#x2F;:seg&#x2F;1&quot;, nil)</span><br><span class="line">r.GET(&quot;&#x2F;ping&#x2F;:se&#x2F;2&quot;, nil)</span><br></pre></td></tr></table></figure>

<p>这样的bug可以归纳为：路由参数是排他的，一个位置（前缀相同）上只要存在了路由参数，就不能再定义静态路径或其他名字参数了，因为httprouter中并没有给静态路径和路由参数定义优先级…</p>
<p>要避免这个问题，方法也简单，只要遵守两点：</p>
<ol>
<li>不要在同一位置放不同名称的参数</li>
<li>想要在同一位置放参数和静态路径，可以选择统一成路由参数，再通过handler进行分发，示例如下<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//r.GET("/ping/:seg/1", handler1)</span></span><br><span class="line"><span class="comment">//r.GET("/ping/seg/1", handler2)</span></span><br><span class="line">r.GET(<span class="string">"/ping/:seg/1"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	seg := c.Param(<span class="string">"seg"</span>)</span><br><span class="line">	<span class="keyword">if</span> seg == <span class="string">"seg"</span> &#123;</span><br><span class="line">		handler1(c)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		handler2(c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>另外有点不合理的是Gin并没有对HANDLE/GET/POST/Group/Use等方法做非nil的判断，导致只有在request进来的时候才会提示空指针问题。</p>
<blockquote><p>同步自 <a href="https://github.com/pangsq/useGin/blob/master/articles/router_analysis_2.md" target="_blank" rel="noopener">https://github.com/pangsq/useGin/blob/master/articles/router_analysis_2.md</a></p>
</blockquote>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">锋寒</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.pangsq.cn/2020/05/01/gin_router_2/index/">https://blog.pangsq.cn/2020/05/01/gin_router_2/index/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.pangsq.cn">锋寒的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a><a class="post-meta__tags" href="/tags/Gin/">Gin</a><a class="post-meta__tags" href="/tags/Router/">Router</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/05/02/controllerManagerEntry/index/"><i class="fa fa-chevron-left">  </i><span>Kubernetes Controller —— Controller Manager入口分析</span></a></div><div class="next-post pull-right"><a href="/2020/05/01/gin_router_1/index/"><span>Gin路由分析（一）</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 锋寒</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>