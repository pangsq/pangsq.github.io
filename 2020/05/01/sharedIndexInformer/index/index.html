<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Kubernetes运行机制 —— SharedIndexInformer"><meta name="keywords" content="Kubernetes,Golang,Informer,Cache"><meta name="author" content="锋寒"><meta name="copyright" content="锋寒"><title>Kubernetes运行机制 —— SharedIndexInformer | 锋寒的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-number">1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Store"><span class="toc-number">1.1.</span> <span class="toc-text">Store</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Indexer"><span class="toc-number">1.1.1.</span> <span class="toc-text">Indexer</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#threadSafeMap"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">threadSafeMap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Indexer的使用例子"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">Indexer的使用例子</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Queue"><span class="toc-number">1.1.2.</span> <span class="toc-text">Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Queue的使用例子"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">Queue的使用例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他"><span class="toc-number">1.2.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RingGrowing"><span class="toc-number">1.2.1.</span> <span class="toc-text">RingGrowing</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行机制"><span class="toc-number">2.</span> <span class="toc-text">运行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建"><span class="toc-number">2.1.</span> <span class="toc-text">创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#直接创建"><span class="toc-number">2.1.1.</span> <span class="toc-text">直接创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#借助工厂类"><span class="toc-number">2.1.2.</span> <span class="toc-text">借助工厂类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventHandler"><span class="toc-number">2.2.</span> <span class="toc-text">EventHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Run"><span class="toc-number">2.3.</span> <span class="toc-text">Run</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Goroutine及函数调用链路"><span class="toc-number">2.4.</span> <span class="toc-text">Goroutine及函数调用链路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据处理流程"><span class="toc-number">3.</span> <span class="toc-text">数据处理流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他-1"><span class="toc-number">4.</span> <span class="toc-text">其他</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">锋寒</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">8</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">20</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">5</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">锋寒的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Kubernetes运行机制 —— SharedIndexInformer</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Kubernetes/">Kubernetes</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>SharedIndexInformer是k8s的client-go中一个功能强大的工具，通过它可以在client端缓存apiserver中的资源实例状态，以提高对整集群管理、调谐的效率。</p>
<p>无论在controller-manager/scheduler等原生组件中还是用kubebuilder编写crd的controller中都会用到它，因此对它内部的实现进行了解是很有必要的。</p>
<p>SharedIndexInformer的运行大致可以表述成：</p>
<ol>
<li>利用ListWatch机制不断从apiserver处获取某一类型的资源实例，存入本地内存中的一个Indexer（带索引和其他丰富接口的缓存）。</li>
<li>并辅以一个Queue（按照先后顺序）对外进行通知（资源实例的变化——增删改 到来时触发用户事先自定义好的事件句柄）。</li>
<li>一般情况下，触发的事件句柄会把资源变化事件放入一个workQueue，另有线程（可以有多个并行）从中拾取事件进行处理（基于本类型或其他类型资源的Indexer作出正确的决策）。当然这是后话，本文暂不具体展开。</li>
</ol>
<p>下文以三个层次对SharedIndexInformer进行分析，分别是：</p>
<ol>
<li>静态：数据结构，出于利用索引提高读性能、顺序访问、线程安全、缓冲、阻塞等待等目的而实现，如Indexer、Queue、RingGrowing等</li>
<li>动态：运行机制，创建、初始化、运行、运行时的各种goroutine被带起的时机</li>
<li>动静结合：完整的数据处理流程，从访问apiserver获取资源到分发、处理、存储资源的整个流程</li>
</ol>
<p>：如下文出现代码均以release-1.18分支为例。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>SharedIndexInformer，在cache包中提供了对应的实现sharedIndexInformer，其依赖一些自定义的特殊结构，先讲讲它们。</p>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>Store，一个通用的对象存储和处理的接口，可以简单理解成：以一个map为核心（存取数据），并提供丰富的接口方法（Add/Update/Delete/List/ListKeys/Get/GetByKey/Replace/Resync）。</p>
<p>Store在client-go/tools/cache库中并没有直接的实现，而是延伸出了两种新接口：Indexer和Queue，分别作为带索引的Store和维护处理顺序的Store。在具体业务逻辑中，这两者往往结合使用。</p>
<p>Store/Indexer/Queue的继承关系与实现的结构体如下图所示：</p>
<p><img src="/2020/05/01/sharedIndexInformer/index/store.png" alt="store"></p>
<h4 id="Indexer"><a href="#Indexer" class="headerlink" title="Indexer"></a>Indexer</h4><p>实现Indexer的结构体是cache，而cache的核心在ThreadSafeStore（cache封装了ThreadSafeStore的相应方法，而Add/Update/Delete等方法实现上是先调用keyFunc获取对象的key再调用后者相应方法）。</p>
<p>keyFunc作用是计算某个对象的key，相同key的对象就可以确定是同一个对象实例的副本。由于底层数据存储的实现上是一个map，自然就可以用对象实例的新副本覆盖旧副本（或者如DeltaFIFO中那样保存不同版本）。</p>
<p>对于k8s的资源对象，普遍使用的keyFunc是MetaNamespaceKeyFunc，如对Pod就可以计算 <code>Pod的namespace/Pod的name</code> 作为key。</p>
<h5 id="threadSafeMap"><a href="#threadSafeMap" class="headerlink" title="threadSafeMap"></a>threadSafeMap</h5><p>threadSafeMap实现了ThreadSafeStore，具体是如何实现的，有必要贴下其结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type threadSafeMap struct &#123;</span><br><span class="line">	lock  sync.RWMutex</span><br><span class="line">	items map[string]interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">	indexers Indexers</span><br><span class="line">	indices Indices</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type IndexFunc func(obj interface&#123;&#125;) ([]string, error)</span><br><span class="line"></span><br><span class="line">type Index map[string]sets.String</span><br><span class="line"></span><br><span class="line">type Indexers map[string]IndexFunc</span><br><span class="line"></span><br><span class="line">type Indices map[string]Index</span><br></pre></td></tr></table></figure>

<p>简单说明：</p>
<ol>
<li>items作为存储对象key-value对的 核心结构</li>
<li>indexers存储一系列索引方法</li>
<li>indices存储通过将indexers中的索引方法作用在items上计算得出的索引key和索引values(此处有点绕，结合实例才方便理解)</li>
</ol>
<p>举个例子：(模仿<a href="https://github.com/kubernetes/kubernetes/blob/29e4e66b597e8fed0a41b77d99653941ae742103/pkg/controller/nodelifecycle/node_lifecycle_controller.go#L130:1" target="_blank" rel="noopener">nodeNameKeyIndex</a>以nodename为索引)</p>
<p>假设此时items中含我们预设的Pod（精简了结构的），其key-value对如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;default&#x2F;pod1&quot; -&gt; Pod&#123;</span><br><span class="line">    nodename: &quot;node1&quot;</span><br><span class="line">&#125;</span><br><span class="line">&quot;default&#x2F;pod2&quot; -&gt; Pod&#123;</span><br><span class="line">    nodename: &quot;node1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时该Indexer包含一个nodename索引，那么Indexers的key-value对如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;nodename&quot; -&gt;  nodeNameKeyIndex</span><br></pre></td></tr></table></figure>

<p>nodeNameKeyIndex代码逻辑为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func nodeNameKeyIndex(obj interface&#123;&#125;) ([]string, error) &#123;</span><br><span class="line">	pod, ok :&#x3D; obj.(*Pod)</span><br><span class="line">	if !ok &#123;</span><br><span class="line">		return []string&#123;&#125;, nil</span><br><span class="line">	&#125;</span><br><span class="line">	if pod.nodename &#x3D;&#x3D; &quot;&quot; &#123;</span><br><span class="line">		return []string&#123;&#125;, nil</span><br><span class="line">	&#125;</span><br><span class="line">	return []string&#123;pod.nodename&#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么最终indices的数据组织如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;nodename&quot; -&gt; &#123;</span><br><span class="line">    &quot;node1&quot; -&gt; &#123; &quot;default&#x2F;pod1&quot;, &quot;default&#x2F;pod2&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Indexer的使用例子"><a href="#Indexer的使用例子" class="headerlink" title="Indexer的使用例子"></a>Indexer的使用例子</h5><p>代码放在<a href="https://github.com/pangsq/read_code_of_k8s/blob/master/tools/cache/SharedIndexInformer/example/main.go" target="_blank" rel="noopener">SharedIndexInformer/example/main.go</a></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Resource <span class="keyword">struct</span> &#123;</span><br><span class="line">	Namespace <span class="keyword">string</span></span><br><span class="line">	Name      <span class="keyword">string</span></span><br><span class="line">	Nodename  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertEquals</span><span class="params">(obj, target <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> obj != target &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"%v is not equal to %v"</span>, obj, target))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cache.MetaNamespaceKeyFunc是client-go中常用的keyFunc(计算object的key)，将`namespace/name`作为对象的唯一键</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">metaNamespaceKeyFunc</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> res, ok := obj.(*Resource); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> res.Namespace + <span class="string">"/"</span> + res.Name, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"Wrong resource type"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">useIndexer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	metaNamespaceKeyFunc := <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> res, ok := obj.(*Resource); ok &#123;</span><br><span class="line">			<span class="keyword">return</span> res.Namespace + <span class="string">"/"</span> + res.Name, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"Wrong resource type"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 以nodename为键的索引</span></span><br><span class="line">	indexByNodename := <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">		res := obj.(*Resource)</span><br><span class="line">		nodename := res.Nodename</span><br><span class="line">		<span class="keyword">return</span> []<span class="keyword">string</span>&#123;nodename&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 索引可以在初始化Indexer的时候放入，也可以通过AddIndexers添加</span></span><br><span class="line">	resourceIndexer := cache.NewIndexer(cache.KeyFunc(metaNamespaceKeyFunc),</span><br><span class="line">		cache.Indexers&#123;<span class="string">"byNodename"</span>: indexByNodename&#125;)</span><br><span class="line">	defaultRes1 := &amp;Resource&#123;</span><br><span class="line">		Namespace: <span class="string">"default"</span>,</span><br><span class="line">		Name:      <span class="string">"res1"</span>,</span><br><span class="line">		Nodename:  <span class="string">"node1"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	extendRes1 := &amp;Resource&#123;</span><br><span class="line">		Namespace: <span class="string">"extend"</span>,</span><br><span class="line">		Name:      <span class="string">"res1"</span>,</span><br><span class="line">		Nodename:  <span class="string">"node1"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// listWatch的list会调用Replace将现存的事例批量导入到Indexer中</span></span><br><span class="line">	<span class="comment">// resourceVersion在目前client-go实现的几个Store中并没有实际使用到</span></span><br><span class="line">	resourceIndexer.Replace([]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		defaultRes1, extendRes1,</span><br><span class="line">	&#125;, <span class="string">"0"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据对象获取对象</span></span><br><span class="line">	res, _, _ := resourceIndexer.Get(defaultRes1)</span><br><span class="line">	assertEquals(res.(*Resource).Nodename, <span class="string">"node1"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过key获取对象</span></span><br><span class="line">	res, _, _ = resourceIndexer.GetByKey(<span class="string">"default/res1"</span>)</span><br><span class="line">	assertEquals(res.(*Resource).Nodename, <span class="string">"node1"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加对象，如果已存在则是修改已有对象，实际实现上与Update并无二致</span></span><br><span class="line">	newRes := &amp;Resource&#123; <span class="comment">// 构造与res1同一个对象（namespace和name一致即可判定为同一资源对象），仅修改nodename</span></span><br><span class="line">		Namespace: <span class="string">"default"</span>,</span><br><span class="line">		Name:      <span class="string">"res1"</span>,</span><br><span class="line">		Nodename:  <span class="string">"node2"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	resourceIndexer.Add(newRes)</span><br><span class="line">	<span class="comment">// 修改后，存在以node2为键的byNodename索引</span></span><br><span class="line">	reses, _ := resourceIndexer.ByIndex(<span class="string">"byNodename"</span>, <span class="string">"node2"</span>)</span><br><span class="line">	assertEquals(<span class="built_in">len</span>(reses), <span class="number">1</span>)</span><br><span class="line">	assertEquals(reses[<span class="number">0</span>].(*Resource).Name, <span class="string">"res1"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>实现Queue的结构体有FIFO和DeltaFIFO，两者差别在于前者存放对象的一个最新版本，而后者可以存放对象的多个历史版本。</p>
<p>Delta具体是何物，与对象本身有什么联系，通过阅读下面的代码很容易理解。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Deltas []Delta</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Delta <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type   DeltaType</span><br><span class="line">	Object <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Added   DeltaType = <span class="string">"Added"</span></span><br><span class="line">	Updated DeltaType = <span class="string">"Updated"</span></span><br><span class="line">	Deleted DeltaType = <span class="string">"Deleted"</span></span><br><span class="line">	Replaced DeltaType = <span class="string">"Replaced"</span></span><br><span class="line">	Sync DeltaType = <span class="string">"Sync"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>FIFO和DeltaFIFO使用<code>queue []string</code>数组来维护先后顺序，并用sync.Cond来实现Pop时的阻塞（相较于异步非阻塞，同步阻塞的方法对于使用者的心智负担无疑是更小的）</p>
<h5 id="Queue的使用例子"><a href="#Queue的使用例子" class="headerlink" title="Queue的使用例子"></a>Queue的使用例子</h5><p>代码放在<a href="https://github.com/pangsq/read_code_of_k8s/blob/master/tools/cache/SharedIndexInformer/example/main.go" target="_blank" rel="noopener">SharedIndexInformer/example/main.go</a></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">useQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">	queue := cache.NewDeltaFIFO(metaNamespaceKeyFunc, <span class="literal">nil</span>)</span><br><span class="line">	lock := sync.Mutex&#123;&#125;</span><br><span class="line">	cond := sync.NewCond(&amp;lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ch := make(chan struct&#123;&#125;)</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		defaultRes1 := &amp;Resource&#123;</span><br><span class="line">			Namespace: <span class="string">"default"</span>,</span><br><span class="line">			Name:      <span class="string">"res1"</span>,</span><br><span class="line">			Nodename:  <span class="string">"node1"</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		extendRes1 := &amp;Resource&#123;</span><br><span class="line">			Namespace: <span class="string">"extend"</span>,</span><br><span class="line">			Name:      <span class="string">"res1"</span>,</span><br><span class="line">			Nodename:  <span class="string">"node1"</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Replace一般用于初始化</span></span><br><span class="line">		queue.Replace([]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">			defaultRes1, extendRes1,</span><br><span class="line">		&#125;, <span class="string">"0"</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 等待初始化放入(Sync)的资源被消费完毕</span></span><br><span class="line">		lock.Lock()</span><br><span class="line">		<span class="keyword">for</span> !queue.HasSynced() &#123;</span><br><span class="line">			cond.Wait()</span><br><span class="line">		&#125;</span><br><span class="line">		lock.Unlock()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 修改资源</span></span><br><span class="line">		defaultRes2 := &amp;Resource&#123;</span><br><span class="line">			Namespace: <span class="string">"default"</span>,</span><br><span class="line">			Name:      <span class="string">"res2"</span>,</span><br><span class="line">			Nodename:  <span class="string">"node1"</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		newDefaultRes2 := &amp;Resource&#123;</span><br><span class="line">			Namespace: <span class="string">"default"</span>,</span><br><span class="line">			Name:      <span class="string">"res2"</span>,</span><br><span class="line">			Nodename:  <span class="string">"node2"</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		queue.Add(defaultRes2)</span><br><span class="line">		queue.Update(newDefaultRes2)</span><br><span class="line"></span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		queue.Close()</span><br><span class="line">		<span class="comment">// close()</span></span><br><span class="line">	&#125;()</span><br><span class="line">	records := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 设计一个简单的处理逻辑：仅仅负责将资源信息打印出来</span></span><br><span class="line">	<span class="comment">// 真正业务中常是将资源事例放入一个workqueue中</span></span><br><span class="line">	recordFunc := <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		deltas := obj.(cache.Deltas)</span><br><span class="line">		<span class="comment">// 取最新的状态</span></span><br><span class="line">		res := deltas.Newest().Object.(*Resource)</span><br><span class="line"></span><br><span class="line">		record := fmt.Sprintf(<span class="string">"%v/%v is on %s , last change is %v, oldest change is %v"</span>,</span><br><span class="line">			res.Namespace, res.Name, res.Nodename, deltas.Newest().Type, deltas.Oldest().Type)</span><br><span class="line">		records = <span class="built_in">append</span>(records, record)</span><br><span class="line">		<span class="comment">// fmt.Println(record)</span></span><br><span class="line">		cond.Signal()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		_, err := queue.Pop(cache.PopProcessFunc(recordFunc))</span><br><span class="line">		<span class="comment">// 一般处理器会限流</span></span><br><span class="line">		time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			assertEquals(err, cache.ErrFIFOClosed)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// for _, rec := range records &#123;</span></span><br><span class="line">	<span class="comment">// 	fmt.Println(rec)</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	assertEquals(records[<span class="number">0</span>], <span class="string">"default/res1 is on node1 , last change is Sync, oldest change is Sync"</span>)     <span class="comment">// 按照顺序，default/res1是最先被添加到Queue的</span></span><br><span class="line">	assertEquals(records[<span class="number">1</span>], <span class="string">"extend/res1 is on node1 , last change is Sync, oldest change is Sync"</span>)      <span class="comment">// 按照顺序，extend/res1是第二个被添加到Queue的</span></span><br><span class="line">	assertEquals(records[<span class="number">2</span>], <span class="string">"default/res2 is on node2 , last change is Updated, oldest change is Added"</span>) <span class="comment">// default/res2最后加入，Deltas中存在它的两个版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="RingGrowing"><a href="#RingGrowing" class="headerlink" title="RingGrowing"></a>RingGrowing</h4><p>一个可增长的环形buffer，作为读写速度不一致时的缓冲区。</p>
<h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>SharedIndexInformer的创建一般有两种：直接创建、借助工厂类。</p>
<h4 id="直接创建"><a href="#直接创建" class="headerlink" title="直接创建"></a>直接创建</h4><p>直接上<a href="https://github.com/pangsq/read_code_of_k8s/blob/master/tools/cache/SharedIndexInformer/example/main.go" target="_blank" rel="noopener">例子</a></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createSharedIndexInformer</span><span class="params">(c *kubernetes.Clientset)</span> <span class="title">cache</span>.<span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">	namespace := v1.NamespaceAll</span><br><span class="line">	podListWatcher := cache.NewListWatchFromClient(c.CoreV1().RESTClient(), <span class="string">"pods"</span>, namespace, fields.Everything())</span><br><span class="line">	<span class="comment">// 也可以选择下面这种写法</span></span><br><span class="line">	<span class="comment">// podListWatcher = &amp;cache.ListWatch&#123;</span></span><br><span class="line">	<span class="comment">// 	ListFunc: func(options metav1.ListOptions) (runtime.Object, error) &#123;</span></span><br><span class="line">	<span class="comment">// 		return c.CoreV1().Pods(namespace).List(context.TODO(), options)</span></span><br><span class="line">	<span class="comment">// 	&#125;,</span></span><br><span class="line">	<span class="comment">// 	WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) &#123;</span></span><br><span class="line">	<span class="comment">// 		return c.CoreV1().Pods(namespace).Watch(context.TODO(), options)</span></span><br><span class="line">	<span class="comment">// 	&#125;,</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	informer := cache.NewSharedIndexInformer(podListWatcher, &amp;v1.Pod&#123;&#125;, <span class="number">0</span>, cache.Indexers&#123;&#125;)</span><br><span class="line">	<span class="comment">// go informer.Run(make(chan struct&#123;&#125;)) // informer.Run本身是阻塞的，所以一般另起一个goroutine；暂时先不启动</span></span><br><span class="line">	<span class="keyword">return</span> informer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="借助工厂类"><a href="#借助工厂类" class="headerlink" title="借助工厂类"></a>借助工厂类</h4><p>这种方式更鼓励使用，client-go也为此针对每个资源写了相应的构造方法，见<a href="https://github.com/kubernetes/client-go/tree/release-1.18/informers" target="_blank" rel="noopener">informers</a></p>
<p><a href="https://github.com/pangsq/read_code_of_k8s/blob/master/tools/cache/SharedIndexInformer/example/main.go" target="_blank" rel="noopener">例子</a>如下</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createSharedIndexInformerByFactory</span><span class="params">(c *kubernetes.Clientset)</span> <span class="params">(cache.SharedIndexInformer, informers.SharedInformerFactory)</span></span> &#123;</span><br><span class="line">	factory := informers.NewSharedInformerFactoryWithOptions(c, <span class="number">0</span>, informers.WithNamespace(v1.NamespaceAll))</span><br><span class="line">	<span class="comment">// factory.Start(make(chan struct&#123;&#125;)) // factory.Start非阻塞；暂时先不启动</span></span><br><span class="line">	<span class="keyword">return</span> factory.Core().V1().Pods().Informer(), factory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EventHandler"><a href="#EventHandler" class="headerlink" title="EventHandler"></a>EventHandler</h3><p>在informer启动之前向informer注册事件句柄；启动过程中也可以添加，但一般不鼓励。</p>
<p>对于同一个SharedIndexerInformer，可以多次使用AddEventHandler，给其注册零或多组EventHandler。（猜测这就是Shared这个前缀的来历</p>
<p>假设想要打印每个pod的变化事件，代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">informer.AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">	AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		key, _ := cache.MetaNamespaceKeyFunc(obj)</span><br><span class="line">		fmt.Println(<span class="string">"add a pod "</span>, key)</span><br><span class="line">	&#125;,</span><br><span class="line">	UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old <span class="keyword">interface</span>&#123;&#125;, <span class="built_in">new</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		key, _ := cache.MetaNamespaceKeyFunc(<span class="built_in">new</span>)</span><br><span class="line">		fmt.Println(<span class="string">"update a pod "</span>, key)</span><br><span class="line">	&#125;,</span><br><span class="line">	DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		key, _ := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)</span><br><span class="line">		fmt.Println(<span class="string">"delete a pod "</span>, key)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h3><p>启动的例子代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runSharedIndexInformerByFactory</span><span class="params">(informer cache.SharedIndexInformer, factory informers.SharedInformerFactory)</span></span> &#123;</span><br><span class="line">	withEventHandler(informer)</span><br><span class="line">	ctx, _ := context.WithTimeout(context.Background(), time.Second*<span class="number">10</span>)</span><br><span class="line">	fmt.Println(<span class="string">"### Start Informer By Factory"</span>)</span><br><span class="line">	<span class="comment">// 一般情况下，例如常驻的controller-manager中的controller会传入一个永不close的channel</span></span><br><span class="line">	<span class="comment">// factory.Start会调用注册在factory中的所有informer的Run方法</span></span><br><span class="line">	factory.Start(ctx.Done())</span><br><span class="line">	<span class="comment">// 由于informer刚启动时会从apiserver拉取大量当前的资源实例状态，所以总是等待这些这些资源实例被处理完毕(EventHandler)之后，再进行具体的业务逻辑</span></span><br><span class="line">	<span class="keyword">if</span> !factory.WaitForCacheSync(ctx.Done())[reflect.TypeOf(&amp;v1.Pod&#123;&#125;)] &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"timed out waiting for caches to sync"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;-ctx.Done()</span><br><span class="line">	fmt.Println(<span class="string">"### End Informer"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再分析下SharedIndexInformer的<a href="https://sourcegraph.com/github.com/kubernetes/client-go@release-1.18/-/blob/tools/cache/shared_informer.go#L336:31&tab=def" target="_blank" rel="noopener">Run</a>方法。</p>
<p>它做了这么几件事：</p>
<ol>
<li>使用defer处理线程奔溃</li>
<li>创建一个deltaFIFO</li>
<li>通过New(c *Config)方法创建一个Controller</li>
<li>另起一个协程运行cacheMutationDetector.Run -&gt; 监控Store中对象不被修改</li>
<li>另起一个协程运行processor.run -&gt; 由资源实例的变化事件（从deltaFIFO读取）触发EventHandler，期间用到一个RingGrowing来进行缓冲</li>
<li>阻塞地运行controller.Run -&gt; 通过reflector的listerWatcher不断获取实例，放入Indexer和deltaFIFO中</li>
</ol>
<h3 id="Goroutine及函数调用链路"><a href="#Goroutine及函数调用链路" class="headerlink" title="Goroutine及函数调用链路"></a>Goroutine及函数调用链路</h3><ol>
<li>从sharedIndexInformer.Run出发，（不考虑cacheMutationDetector）有两条函数调用路径：1.负责数据的生产；2.负责数据的消费</li>
<li>函数前带go说明另起了协程（实际代码中不一定是直接使用的go关键字），带loop说明是一个循环操作，带multi说明是多次调用（例如对deltas/listeners的遍历）</li>
</ol>
<img src="/2020/05/01/sharedIndexInformer/index/trace.png" width="1000" hegiht="600" align="center">

<p>由上图可知，最终所有的资源实例对象存储在Indexer中，每次实例的变化通知到EventHandler。</p>
<h2 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h2><img src="/2020/05/01/sharedIndexInformer/index/flow.png" width="1000" hegiht="600" align="center">

<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><p>client-go还存在一个与SharedIndexInformer功能相似的组件——Controller，两者区别在于：</p>
<ol>
<li>创建Controller时调用NewIndexerInformer，产生两个返回值——Indexer和Controller，Indexer存储资源对象，Controller负责通过Reflector获取资源对象和产生通知；而SharedIndexInformer封装地更好。</li>
<li>Controller中的EventHandler有且只能有一个，在NewIndexerInformer创建Controller时就需要指定</li>
<li>SharedIndexInformer可以选择性开启MutationDetector（用于监控缓存的资源对象是否被修改。约定想要修改资源时，要先deep copy一份在新副本上修改）</li>
<li>SharedIndexInformer的实现sharedIndexInformer使用了一个Controller</li>
</ol>
<blockquote><p>同步自 <a href="https://github.com/pangsq/read_code_of_k8s/blob/master/tools/cache/SharedIndexInformer/SharedIndexInformer.md" target="_blank" rel="noopener">https://github.com/pangsq/read_code_of_k8s/blob/master/tools/cache/SharedIndexInformer/SharedIndexInformer.md</a></p>
</blockquote>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">锋寒</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.pangsq.cn/2020/05/01/sharedIndexInformer/index/">https://blog.pangsq.cn/2020/05/01/sharedIndexInformer/index/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.pangsq.cn">锋寒的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Kubernetes/">Kubernetes</a><a class="post-meta__tags" href="/tags/Golang/">Golang</a><a class="post-meta__tags" href="/tags/Informer/">Informer</a><a class="post-meta__tags" href="/tags/Cache/">Cache</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/05/01/gin_router_1/index/"><i class="fa fa-chevron-left">  </i><span>Gin路由分析（一）</span></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By 锋寒</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>