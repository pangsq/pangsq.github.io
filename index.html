<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="锋寒"><meta name="copyright" content="锋寒"><title>锋寒的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">锋寒</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">4</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">8</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">锋寒的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">锋寒的博客</div><div id="site-sub-title"></div><div id="site-social-icons"><a class="social-icon" href="https://github.com/pangsq" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-github"></i></a><a class="social-icon" href="pangsq9413@gmail.com" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-email"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/02/controllerManagerEntry/index/">Kubernetes Controller —— Controller Manager入口分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Kuberneter/">Kuberneter</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Kuberneter/Controller/">Controller</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Golang/">Golang</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Kubernetes/">Kubernetes</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Controller/">Controller</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Entry/">Entry</a></span><div class="content"><p>branch: release-v1.18</p>
<p>commit: ff809a5d953ba778270ce8790b21d394821e1e28</p>
<h2 id="cmd-kube-controller-manager-controller-manager-go"><a href="#cmd-kube-controller-manager-controller-manager-go" class="headerlink" title="cmd/kube-controller-manager/controller-manager.go"></a><code>cmd/kube-controller-manager/controller-manager.go</code></h2><p>一个非常简洁标准的命令模样的入口</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">	command := app.NewControllerManagerCommand()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> once we switch everything over to Cobra commands, we can go back to calling</span></span><br><span class="line">	<span class="comment">// utilflag.InitFlags() (by removing its pflag.Parse() call). For now, we have to set the</span></span><br><span class="line">	<span class="comment">// normalize func and add the go flag set by hand.</span></span><br><span class="line">	<span class="comment">// utilflag.InitFlags()</span></span><br><span class="line">	logs.InitLogs()</span><br><span class="line">	<span class="keyword">defer</span> logs.FlushLogs()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := command.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体实现逻辑明显在<code>NewControllerManagerCommand()</code>中</p>
<h2 id="cmd-kube-contoller-manager-app"><a href="#cmd-kube-contoller-manager-app" class="headerlink" title="cmd/kube-contoller-manager/app/"></a><code>cmd/kube-contoller-manager/app/</code></h2><h3 id="NewContollerManagerCommand-，在controllermanager-go中"><a href="#NewContollerManagerCommand-，在controllermanager-go中" class="headerlink" title="NewContollerManagerCommand()，在controllermanager.go中"></a>NewContollerManagerCommand()，在controllermanager.go中</h3><ol>
<li>构造ControllerManager命令；初始化配置</li>
<li>接下来运行 Run(c.Complete(), wait.NeverStop)  // 见 2.3</li>
</ol>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewControllerManagerCommand creates a *cobra.Command object with default parameters</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControllerManagerCommand</span><span class="params">()</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">	s, err := options.NewKubeControllerManagerOptions() <span class="comment">// 详情见2.2</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	cmd := &amp;cobra.Command&#123;</span><br><span class="line">		Use: <span class="string">"kube-controller-manager"</span>,</span><br><span class="line">		Long: ...</span><br><span class="line">		Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">			...</span><br><span class="line"></span><br><span class="line">			c, err := s.Config(KnownControllers(), <span class="comment">// 所有支持的controllers名：sets.StringKeySet(NewControllerInitializers(IncludeCloudLoops)) </span></span><br><span class="line">			  ControllersDisabledByDefault.List()) <span class="comment">// 缺省被关闭的控制器，现在有"bootstrapsigner", "tokencleaner"</span></span><br><span class="line">			  <span class="comment">// 此处方法内部只有一个Validate(allContollers, disabledByDefaultControllers)用到了这两入参</span></span><br><span class="line">			  <span class="comment">// 注意到Run作为一个函数还没有到调用的时刻，cmd带哪些flags还得依赖从 `fs := cmd.Flags`开始的代码</span></span><br><span class="line">			...</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err := Run(c.Complete(), wait.NeverStop); err != <span class="literal">nil</span> &#123; <span class="comment">// 核心入口</span></span><br><span class="line">				fmt.Fprintf(os.Stderr, <span class="string">"%v\n"</span>, err)</span><br><span class="line">				os.Exit(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fs := cmd.Flags()</span><br><span class="line">	namedFlagSets := s.Flags(KnownControllers(), ControllersDisabledByDefault.List()) </span><br><span class="line">	<span class="comment">// 给命令行组装flags，传入这俩参数是为了描述controllers这个配置项的时候提示总共有哪些controller以及哪些是默认禁用的</span></span><br><span class="line">	<span class="comment">// controllers默认是"*" 表示启用所有默认开启的controllers，如果配置"foo"表示开启foo，"-foo"表示关闭foo，以,分隔</span></span><br><span class="line">	... <span class="comment">// 其他一些初始化cmd</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NewKubeControllerManagerOptions-在options-options-go中"><a href="#NewKubeControllerManagerOptions-在options-options-go中" class="headerlink" title="NewKubeControllerManagerOptions(),在options/options.go中"></a>NewKubeControllerManagerOptions(),在options/options.go中</h3><ol>
<li>创建一份kubeControllerManager的默认配置；追溯其源头可以到<code>pkg/controller/apis/config/v1alpha1/defaults.go</code>中的SetDefaults_KubeControllerManagerConfiguration 查看各个缺省值</li>
<li>此处展开可以了解一些controllerManager中有哪些配置项以及其可能的默认配置</li>
</ol>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewKubeControllerManagerOptions creates a new KubeControllerManagerOptions with a default config.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewKubeControllerManagerOptions</span><span class="params">()</span> <span class="params">(*KubeControllerManagerOptions, error)</span></span> &#123;</span><br><span class="line">	componentConfig, err := NewDefaultComponentConfig(ports.InsecureKubeControllerManagerPort) <span class="comment">// 又套了一层方法去实现一些通用的默认配置的初始化</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s := KubeControllerManagerOptions&#123;</span><br><span class="line">		Generic:         cmoptions.NewGenericControllerManagerConfigurationOptions(&amp;componentConfig.Generic),</span><br><span class="line">		KubeCloudShared: cmoptions.NewKubeCloudSharedOptions(&amp;componentConfig.KubeCloudShared),</span><br><span class="line">		ServiceController: &amp;cmoptions.ServiceControllerOptions&#123;</span><br><span class="line">			ServiceControllerConfiguration: &amp;componentConfig.ServiceController,</span><br><span class="line">		&#125;,</span><br><span class="line">		... <span class="comment">// 一堆controller的key-value对</span></span><br><span class="line">		... <span class="comment">// 一些认证方面的配置</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	... <span class="comment">// authentication/authorization/secureServing等默认配置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// gc资源配置就在此处了，一般我们很少配置gc相关的配置，所以通过这里可以知道k8s中一般有哪些资源可能是需要gc的</span></span><br><span class="line">	gcIgnoredResources := <span class="built_in">make</span>([]garbagecollectorconfig.GroupResource, <span class="number">0</span>, <span class="built_in">len</span>(garbagecollector.DefaultIgnoredResources()))  <span class="comment">// 忽略gc的资源，缺省的只有一个events</span></span><br><span class="line">	<span class="keyword">for</span> r := <span class="keyword">range</span> garbagecollector.DefaultIgnoredResources() &#123;</span><br><span class="line">		gcIgnoredResources = <span class="built_in">append</span>(gcIgnoredResources, garbagecollectorconfig.GroupResource&#123;Group: r.Group, Resource: r.Resource&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.GarbageCollectorController.GCIgnoredResources = gcIgnoredResources</span><br><span class="line">	s.Generic.LeaderElection.ResourceName = <span class="string">"kube-controller-manager"</span></span><br><span class="line">	s.Generic.LeaderElection.ResourceNamespace = <span class="string">"kube-system"</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Run-c-config-CompletedConfig-stopCh-lt-chan-struct-回到controllermanager-go"><a href="#Run-c-config-CompletedConfig-stopCh-lt-chan-struct-回到controllermanager-go" class="headerlink" title="Run(c *config.CompletedConfig, stopCh &lt;-chan struct{}),回到controllermanager.go"></a>Run(c *config.CompletedConfig, stopCh &lt;-chan struct{}),回到controllermanager.go</h3><ol>
<li>源码总计有130+行，算是controllerManager业务逻辑的主干了</li>
<li>具体功能有：<ol>
<li>打印version</li>
<li>向/configz这个handler中放入controllerManager目前的配置内容</li>
<li>将选主(leaderelection)情况放到healthCheck中</li>
<li>创建mux，加入/healthz、/debug/pprof、/configz、/metrics等handler</li>
<li>根据配置使用安全或非安全的模式，如果是安全模式，有Authorization和Authentication，之后启动http server</li>
<li>定义run：初始化clientBuilder为了后续能获取controller的config和client；先初始化saController再初始化其他controller；启动相关的informer</li>
<li>如果不需要选主则直接执行run，否则选主成功才执行run</li>
</ol>
</li>
</ol>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run runs the KubeControllerManagerOptions.  This should never exit.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(c *config.CompletedConfig, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	... <span class="comment">// 打印Version</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cfgz, err := configz.New(ConfigzName); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		cfgz.Set(c.ComponentConfig) <span class="comment">// configz是一个map[string]*Config&#123;&#125;，把kubeController的配置项注册进去，key为kubecontrollermanager.config.k8s.io</span></span><br><span class="line">		<span class="comment">// controller server会持有一个路径为`/configz`的handler</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		klog.Errorf(<span class="string">"unable to register configz: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Setup any healthz checks we will want to use.</span></span><br><span class="line">	<span class="comment">// 为了HA 所以集群中可能有多个controllerManager，因此controllerManager通过apiserver/etcd选主；</span></span><br><span class="line">	<span class="comment">// 此处将选主情况做进healthCheck中</span></span><br><span class="line">	<span class="keyword">var</span> checks []healthz.HealthChecker</span><br><span class="line">	<span class="keyword">var</span> electionChecker *leaderelection.HealthzAdaptor</span><br><span class="line">	<span class="keyword">if</span> c.ComponentConfig.Generic.LeaderElection.LeaderElect &#123;</span><br><span class="line">		electionChecker = leaderelection.NewLeaderHealthzAdaptor(time.Second * <span class="number">20</span>)</span><br><span class="line">		checks = <span class="built_in">append</span>(checks, electionChecker)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start the controller manager HTTP server</span></span><br><span class="line">	<span class="comment">// unsecuredMux is the handler for these controller *after* authn/authz filters have been applied</span></span><br><span class="line">	<span class="keyword">var</span> unsecuredMux *mux.PathRecorderMux</span><br><span class="line">	<span class="keyword">if</span> c.SecureServing != <span class="literal">nil</span> &#123;</span><br><span class="line">	    <span class="comment">// 1. 创建mux，基础path设置成"controller-manager" 2. 给mux加入/healthz、/debug/pprof、/configz、/metrics等handler</span></span><br><span class="line">		unsecuredMux = genericcontrollermanager.NewBaseHandler(&amp;c.ComponentConfig.Generic.Debugging, checks...)</span><br><span class="line">		handler := genericcontrollermanager.BuildHandlerChain(unsecuredMux, &amp;c.Authorization, &amp;c.Authentication)</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> handle stoppedCh returned by c.SecureServing.Serve</span></span><br><span class="line">		<span class="comment">// 开启server</span></span><br><span class="line">		<span class="keyword">if</span> _, err := c.SecureServing.Serve(handler, <span class="number">0</span>, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c.InsecureServing != <span class="literal">nil</span> &#123;</span><br><span class="line">		unsecuredMux = genericcontrollermanager.NewBaseHandler(&amp;c.ComponentConfig.Generic.Debugging, checks...)</span><br><span class="line">		insecureSuperuserAuthn := server.AuthenticationInfo&#123;Authenticator: &amp;server.InsecureSuperuser&#123;&#125;&#125;</span><br><span class="line">		handler := genericcontrollermanager.BuildHandlerChain(unsecuredMux, <span class="literal">nil</span>, &amp;insecureSuperuserAuthn)</span><br><span class="line">		<span class="keyword">if</span> err := c.InsecureServing.Serve(handler, <span class="number">0</span>, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	run := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">		rootClientBuilder := controller.SimpleControllerClientBuilder&#123;</span><br><span class="line">			ClientConfig: c.Kubeconfig,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> clientBuilder controller.ControllerClientBuilder <span class="comment">// 通过clientBuilder可以通过name获取controller的config和client</span></span><br><span class="line">		<span class="keyword">if</span> c.ComponentConfig.KubeCloudShared.UseServiceAccountCredentials &#123;</span><br><span class="line">			... <span class="comment">// 在云环境中的clientBuilder</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			clientBuilder = rootClientBuilder</span><br><span class="line">		&#125;</span><br><span class="line">		controllerContext, err := CreateControllerContext(c, rootClientBuilder, clientBuilder, ctx.Done())</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.Fatalf(<span class="string">"error building controller context: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 由于serverAccountToken的特殊性，必须先于其他controller启动</span></span><br><span class="line">		saTokenControllerInitFunc := serviceAccountTokenControllerStarter&#123;rootClientBuilder: rootClientBuilder&#125;.startServiceAccountTokenController</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动所有controllers。StartControllers见 2.4，NewControllerInitializers 见2.5</span></span><br><span class="line">		<span class="keyword">if</span> err := StartControllers(controllerContext, saTokenControllerInitFunc, NewControllerInitializers(controllerContext.LoopMode), unsecuredMux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.Fatalf(<span class="string">"error starting controllers: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 用于controller的informers</span></span><br><span class="line">		controllerContext.InformerFactory.Start(controllerContext.Stop)</span><br><span class="line">		<span class="comment">// 用于typed资源本身或动态资源的metadata的informers；目前用到这个informerFactory的有ResourceQuota和GarbageCollector</span></span><br><span class="line">		controllerContext.ObjectOrMetadataInformerFactory.Start(controllerContext.Stop)</span><br><span class="line">		<span class="built_in">close</span>(controllerContext.InformersStarted)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;&#125; <span class="comment">// 阻塞当前线程</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有启用选主（集群中只有一个controllerManager的情况下），直接run</span></span><br><span class="line">	<span class="keyword">if</span> !c.ComponentConfig.Generic.LeaderElection.LeaderElect &#123;</span><br><span class="line">		run(context.TODO()) <span class="comment">// 这里定义了一个Done() 为 &lt;-chan struct&#123;&#125;，在select中作为一个永远不会触发的条件</span></span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"unreachable"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	id, err := os.Hostname()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// add a uniquifier so that two processes on the same host don't accidentally both become active</span></span><br><span class="line">	id = id + <span class="string">"_"</span> + <span class="keyword">string</span>(uuid.NewUUID())</span><br><span class="line"></span><br><span class="line">	rl, err := resourcelock.New(c.ComponentConfig.Generic.LeaderElection.ResourceLock,</span><br><span class="line">		c.ComponentConfig.Generic.LeaderElection.ResourceNamespace,</span><br><span class="line">		c.ComponentConfig.Generic.LeaderElection.ResourceName,</span><br><span class="line">		c.LeaderElectionClient.CoreV1(),</span><br><span class="line">		c.LeaderElectionClient.CoordinationV1(),</span><br><span class="line">		resourcelock.ResourceLockConfig&#123;</span><br><span class="line">			Identity:      id,</span><br><span class="line">			EventRecorder: c.EventRecorder,</span><br><span class="line">		&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Fatalf(<span class="string">"error creating lock: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 选主，成为主才执行run</span></span><br><span class="line">	leaderelection.RunOrDie(context.TODO(), leaderelection.LeaderElectionConfig&#123;</span><br><span class="line">		Lock:          rl,</span><br><span class="line">		LeaseDuration: c.ComponentConfig.Generic.LeaderElection.LeaseDuration.Duration,</span><br><span class="line">		RenewDeadline: c.ComponentConfig.Generic.LeaderElection.RenewDeadline.Duration,</span><br><span class="line">		RetryPeriod:   c.ComponentConfig.Generic.LeaderElection.RetryPeriod.Duration,</span><br><span class="line">		Callbacks: leaderelection.LeaderCallbacks&#123;</span><br><span class="line">			OnStartedLeading: run,</span><br><span class="line">			OnStoppedLeading: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				klog.Fatalf(<span class="string">"leaderelection lost"</span>)</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		WatchDog: electionChecker,</span><br><span class="line">		Name:     <span class="string">"kube-controller-manager"</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"unreachable"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="StartControllers-在controolermanager-go中"><a href="#StartControllers-在controolermanager-go中" class="headerlink" title="StartControllers,在controolermanager.go中"></a>StartControllers,在controolermanager.go中</h3><ol>
<li>通过传入的ctx和initFunc启动saTokenController</li>
<li>通过传入的ctx和controllers，调用每个controller的initFunc分别对其进行初始化</li>
<li>往mux中添加一些debug的handler</li>
</ol>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StartControllers starts a set of controllers with a specified ControllerContext</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartControllers</span><span class="params">(ctx ControllerContext, startSATokenController InitFunc, controllers <span class="keyword">map</span>[<span class="keyword">string</span>]InitFunc, unsecuredMux *mux.PathRecorderMux)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Always start the SA token controller first using a full-power client, since it needs to mint tokens for the rest</span></span><br><span class="line">	<span class="comment">// If this fails, just return here and fail since other controllers won't be able to get credentials.</span></span><br><span class="line">	<span class="keyword">if</span> _, _, err := startSATokenController(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the cloud provider with a reference to the clientBuilder only after token controller</span></span><br><span class="line">	<span class="comment">// has started in case the cloud provider uses the client builder.</span></span><br><span class="line">	<span class="keyword">if</span> ctx.Cloud != <span class="literal">nil</span> &#123;</span><br><span class="line">		ctx.Cloud.Initialize(ctx.ClientBuilder, ctx.Stop)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> controllerName, initFn := <span class="keyword">range</span> controllers &#123;</span><br><span class="line">		<span class="keyword">if</span> !ctx.IsControllerEnabled(controllerName) &#123;</span><br><span class="line">			klog.Warningf(<span class="string">"%q is disabled"</span>, controllerName)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		time.Sleep(wait.Jitter(ctx.ComponentConfig.Generic.ControllerStartInterval.Duration, ControllerStartJitter))</span><br><span class="line"></span><br><span class="line">		klog.V(<span class="number">1</span>).Infof(<span class="string">"Starting %q"</span>, controllerName)</span><br><span class="line">		debugHandler, started, err := initFn(ctx)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.Errorf(<span class="string">"Error starting %q"</span>, controllerName)</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !started &#123;</span><br><span class="line">			klog.Warningf(<span class="string">"Skipping %q"</span>, controllerName)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> debugHandler != <span class="literal">nil</span> &amp;&amp; unsecuredMux != <span class="literal">nil</span> &#123;</span><br><span class="line">			basePath := <span class="string">"/debug/controllers/"</span> + controllerName</span><br><span class="line">			unsecuredMux.UnlistedHandle(basePath, http.StripPrefix(basePath, debugHandler))</span><br><span class="line">			unsecuredMux.UnlistedHandlePrefix(basePath+<span class="string">"/"</span>, http.StripPrefix(basePath, debugHandler))</span><br><span class="line">		&#125;</span><br><span class="line">		klog.Infof(<span class="string">"Started %q"</span>, controllerName)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NewControllerInitializers-在controllermanager-go中"><a href="#NewControllerInitializers-在controllermanager-go中" class="headerlink" title="NewControllerInitializers,在controllermanager.go中"></a>NewControllerInitializers,在controllermanager.go中</h3><p>此处定义了每个controller的初始化方法，其内容大同小异，所以2.6选取比较简单的namespace进行分析</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewControllerInitializers is a public map of named controller groups (you can start more than one in an init func)</span></span><br><span class="line"><span class="comment">// paired to their InitFunc.  This allows for structured downstream composition and subdivision.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControllerInitializers</span><span class="params">(loopMode ControllerLoopMode)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">InitFunc</span></span> &#123;</span><br><span class="line">	controllers := <span class="keyword">map</span>[<span class="keyword">string</span>]InitFunc&#123;&#125;</span><br><span class="line">	controllers[<span class="string">"endpoint"</span>] = startEndpointController</span><br><span class="line">	controllers[<span class="string">"endpointslice"</span>] = startEndpointSliceController</span><br><span class="line">	controllers[<span class="string">"replicationcontroller"</span>] = startReplicationController</span><br><span class="line">	controllers[<span class="string">"podgc"</span>] = startPodGCController</span><br><span class="line">	controllers[<span class="string">"resourcequota"</span>] = startResourceQuotaController</span><br><span class="line">	controllers[<span class="string">"namespace"</span>] = startNamespaceController</span><br><span class="line">	controllers[<span class="string">"serviceaccount"</span>] = startServiceAccountController</span><br><span class="line">	controllers[<span class="string">"garbagecollector"</span>] = startGarbageCollectorController</span><br><span class="line">	controllers[<span class="string">"daemonset"</span>] = startDaemonSetController</span><br><span class="line">	controllers[<span class="string">"job"</span>] = startJobController</span><br><span class="line">	controllers[<span class="string">"deployment"</span>] = startDeploymentController</span><br><span class="line">	controllers[<span class="string">"replicaset"</span>] = startReplicaSetController</span><br><span class="line">	controllers[<span class="string">"horizontalpodautoscaling"</span>] = startHPAController</span><br><span class="line">	controllers[<span class="string">"disruption"</span>] = startDisruptionController</span><br><span class="line">	controllers[<span class="string">"statefulset"</span>] = startStatefulSetController</span><br><span class="line">	controllers[<span class="string">"cronjob"</span>] = startCronJobController</span><br><span class="line">	controllers[<span class="string">"csrsigning"</span>] = startCSRSigningController</span><br><span class="line">	controllers[<span class="string">"csrapproving"</span>] = startCSRApprovingController</span><br><span class="line">	controllers[<span class="string">"csrcleaner"</span>] = startCSRCleanerController</span><br><span class="line">	controllers[<span class="string">"ttl"</span>] = startTTLController</span><br><span class="line">	controllers[<span class="string">"bootstrapsigner"</span>] = startBootstrapSignerController</span><br><span class="line">	controllers[<span class="string">"tokencleaner"</span>] = startTokenCleanerController</span><br><span class="line">	controllers[<span class="string">"nodeipam"</span>] = startNodeIpamController</span><br><span class="line">	controllers[<span class="string">"nodelifecycle"</span>] = startNodeLifecycleController</span><br><span class="line">	<span class="keyword">if</span> loopMode == IncludeCloudLoops &#123;</span><br><span class="line">		controllers[<span class="string">"service"</span>] = startServiceController</span><br><span class="line">		controllers[<span class="string">"route"</span>] = startRouteController</span><br><span class="line">		controllers[<span class="string">"cloud-node-lifecycle"</span>] = startCloudNodeLifecycleController</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> volume controller into the IncludeCloudLoops only set.</span></span><br><span class="line">	&#125;</span><br><span class="line">	controllers[<span class="string">"persistentvolume-binder"</span>] = startPersistentVolumeBinderController</span><br><span class="line">	controllers[<span class="string">"attachdetach"</span>] = startAttachDetachController</span><br><span class="line">	controllers[<span class="string">"persistentvolume-expander"</span>] = startVolumeExpandController</span><br><span class="line">	controllers[<span class="string">"clusterrole-aggregation"</span>] = startClusterRoleAggregrationController</span><br><span class="line">	controllers[<span class="string">"pvc-protection"</span>] = startPVCProtectionController</span><br><span class="line">	controllers[<span class="string">"pv-protection"</span>] = startPVProtectionController</span><br><span class="line">	controllers[<span class="string">"ttl-after-finished"</span>] = startTTLAfterFinishedController</span><br><span class="line">	controllers[<span class="string">"root-ca-cert-publisher"</span>] = startRootCACertPublisher</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> controllers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="startNamespaceController-在core-go中"><a href="#startNamespaceController-在core-go中" class="headerlink" title="startNamespaceController,在core.go中"></a>startNamespaceController,在core.go中</h3><ol>
<li>startNamespaceController初始化了用于namespace-controller的client(就是一个访问apiserver的kube-client实例，设置了UserAgent)，然后调用startModifiedNamespaceController</li>
<li>startModifiedNamespaceController中初始化了真正的namespace控制器，然后起了一个goroutine去管理namespace</li>
<li>启用多个goroutine（缺省为10个），每个goroutine中一个worker处理具体逻辑</li>
<li>worker中最外围是一个loop，循环往复地执行处理逻辑<ol>
<li>尝试从队列中获取一个key</li>
<li>根据这个key尝试同步namespace信息:syncNamespaceFromKey；由于namespace的操作只有delete（在enqueueNamespace这个方法中删除了除delete namespace外的其他操作）了，所以此处的同步即从apiserver中删除key对应的namespace，具体代码在<code>func (d *namespacedResourcesDeleter) deleteAllContent(ns *v1.Namespace) (int64, error)</code></li>
<li>如果成功，从队列中删除这个key并返回</li>
<li>如果不成功，判断是什么类型的错误<ol>
<li>如果是deletion.ResourcesRemainingError（namespace下还有其他资源），则在一段时间后加入队列</li>
<li>如果不是，则直接将key重新加入队列</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startNamespaceController</span><span class="params">(ctx ControllerContext)</span> <span class="params">(http.Handler, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// the namespace cleanup controller is very chatty.  It makes lots of discovery calls and then it makes lots of delete calls</span></span><br><span class="line">	<span class="comment">// the ratelimiter negatively affects its speed.  Deleting 100 total items in a namespace (that's only a few of each resource</span></span><br><span class="line">	<span class="comment">// including events), takes ~10 seconds by default.</span></span><br><span class="line">	nsKubeconfig := ctx.ClientBuilder.ConfigOrDie(<span class="string">"namespace-controller"</span>)</span><br><span class="line">	nsKubeconfig.QPS *= <span class="number">20</span></span><br><span class="line">	nsKubeconfig.Burst *= <span class="number">100</span></span><br><span class="line">	namespaceKubeClient := clientset.NewForConfigOrDie(nsKubeconfig)</span><br><span class="line">	<span class="keyword">return</span> startModifiedNamespaceController(ctx, namespaceKubeClient, nsKubeconfig)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startModifiedNamespaceController</span><span class="params">(ctx ControllerContext, namespaceKubeClient clientset.Interface, nsKubeconfig *restclient.Config)</span> <span class="params">(http.Handler, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	metadataClient, err := metadata.NewForConfig(nsKubeconfig)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	discoverResourcesFn := namespaceKubeClient.Discovery().ServerPreferredNamespacedResources</span><br><span class="line"></span><br><span class="line">	namespaceController := namespacecontroller.NewNamespaceController(</span><br><span class="line">		namespaceKubeClient,</span><br><span class="line">		metadataClient,</span><br><span class="line">		discoverResourcesFn,</span><br><span class="line">		ctx.InformerFactory.Core().V1().Namespaces(),</span><br><span class="line">		ctx.ComponentConfig.NamespaceController.NamespaceSyncPeriod.Duration,</span><br><span class="line">		v1.FinalizerKubernetes,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">go</span> namespaceController.Run(<span class="keyword">int</span>(ctx.ComponentConfig.NamespaceController.ConcurrentNamespaceSyncs), ctx.Stop)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到<code>namespace_controller.go</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run starts observing the system with the specified number of workers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nm *NamespaceController)</span> <span class="title">Run</span><span class="params">(workers <span class="keyword">int</span>, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">	<span class="keyword">defer</span> nm.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">	klog.Infof(<span class="string">"Starting namespace controller"</span>)</span><br><span class="line">	<span class="keyword">defer</span> klog.Infof(<span class="string">"Shutting down namespace controller"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForNamedCacheSync(<span class="string">"namespace"</span>, stopCh, nm.listerSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	klog.V(<span class="number">5</span>).Info(<span class="string">"Starting workers of namespace controller"</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> wait.Until(nm.worker, time.Second, stopCh)</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;-stopCh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker processes the queue of namespace objects.</span></span><br><span class="line"><span class="comment">// Each namespace can be in the queue at most once.</span></span><br><span class="line"><span class="comment">// The system ensures that no two workers can process</span></span><br><span class="line"><span class="comment">// the same namespace at the same time.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nm *NamespaceController)</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line">	workFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		key, quit := nm.queue.Get()</span><br><span class="line">		<span class="keyword">if</span> quit &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> nm.queue.Done(key)</span><br><span class="line"></span><br><span class="line">		err := nm.syncNamespaceFromKey(key.(<span class="keyword">string</span>))</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// no error, forget this entry and return</span></span><br><span class="line">			nm.queue.Forget(key)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> estimate, ok := err.(*deletion.ResourcesRemainingError); ok &#123;</span><br><span class="line">			t := estimate.Estimate/<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(<span class="string">"Content remaining in namespace %s, waiting %d seconds"</span>, key, t)</span><br><span class="line">			nm.queue.AddAfter(key, time.Duration(t)*time.Second)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// rather than wait for a full resync, re-add the namespace to the queue to be processed</span></span><br><span class="line">			nm.queue.AddRateLimited(key)</span><br><span class="line">			utilruntime.HandleError(fmt.Errorf(<span class="string">"deletion of namespace %v failed: %v"</span>, key, err))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		quit := workFunc()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> quit &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参见client-go的例子"><a href="#参见client-go的例子" class="headerlink" title="参见client-go的例子"></a>参见client-go的例子</h3><p>官方提供的一个client使用workqueue的例子很好地描述了controller的大致实现，可以作为一个非常标准的模板用于参考。</p>
<p><code>https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go</code></p>
<blockquote><p>同步自 <a href="https://github.com/pangsq/read_code_of_k8s/blob/master/controller-manager-entry.md" target="_blank" rel="noopener">https://github.com/pangsq/read_code_of_k8s/blob/master/controller-manager-entry.md</a></p>
</blockquote></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/01/gin_router_2/index/">Gin路由分析（二）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Gin/">Gin</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Gin/">Gin</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Router/">Router</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Golang/">Golang</a></span><div class="content"><blockquote>
<p>The fastest full-featured web framework for Go.</p>
</blockquote>
<blockquote>
<p>Radix tree based routing, small memory foot print. No reflection. Predictable API performance.</p>
</blockquote>
<p>官方声称Gin是最快的功能完整的Go web框架，本文研究下其实现细节。</p>
<h2 id="路由的注册"><a href="#路由的注册" class="headerlink" title="路由的注册"></a>路由的注册</h2><p>前一篇文章分析中已知handler最终落到<code>group.engine.addRoute(httpMethod, absolutePath, handlers)</code>，所以本文从addRoute开始分析。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">addRoute</span><span class="params">(method, path <span class="keyword">string</span>, handlers HandlersChain)</span></span> &#123;</span><br><span class="line">	... <span class="comment">// 1. 参数检查与打印一些调试信息</span></span><br><span class="line">	root := engine.trees.get(method)</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="comment">// 2. 惰性创建相关method的root node</span></span><br><span class="line">		root = <span class="built_in">new</span>(node)</span><br><span class="line">		root.fullPath = <span class="string">"/"</span></span><br><span class="line">		engine.trees = <span class="built_in">append</span>(engine.trees, methodTree&#123;method: method, root: root&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 3. 往root node中注册handlers</span></span><br><span class="line">	root.addRoute(path, handlers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这段代码中我们还知道这么几件事：</p>
<ol>
<li>path -&gt; handlers的映射关系维护在tree(node)中</li>
<li>每个method一个独立的tree</li>
<li>从命名上我们可以大致猜测出这就是个树形结构</li>
</ol>
<p>在更深入实现细节前，先回顾下<code>路由参数</code>的概念。</p>
<p>url路径中存在两种通配符。<code>:</code>可以匹配一段路径，<code>*</code>可以匹配0或n段路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.) path &#x3D; &#x2F;user&#x2F;:name  </span><br><span class="line"></span><br><span class="line">此handler会匹配 &#x2F;user&#x2F;john 但不会匹配 &#x2F;user&#x2F; 或者 &#x2F;user</span><br><span class="line"></span><br><span class="line">2.) path &#x3D; &#x2F;user&#x2F;:name&#x2F;*action</span><br><span class="line">此 handler 将匹配 &#x2F;user&#x2F;john&#x2F; 和 &#x2F;user&#x2F;john&#x2F;send</span><br><span class="line">如果没有其他路由匹配 &#x2F;user&#x2F;john，它将重定向到 &#x2F;user&#x2F;john&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><p>再来看看node的数据结构。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	path      <span class="keyword">string</span>	<span class="comment">// 当前节点path，一段或多段segment，例如 /a/b，/:param等等</span></span><br><span class="line">	indices   <span class="keyword">string</span>	<span class="comment">// 索引，存储子节点的首字符</span></span><br><span class="line">	children  []*node	<span class="comment">// 子节点</span></span><br><span class="line">	handlers  HandlersChain	<span class="comment">// handlers方法</span></span><br><span class="line">	priority  <span class="keyword">uint32</span>	<span class="comment">// 路径包含该节点的handler数量，即路由经由该节点的handler数</span></span><br><span class="line">	nType     nodeType	<span class="comment">// 节点类型</span></span><br><span class="line">	maxParams <span class="keyword">uint8</span>		<span class="comment">// 该节点之后的路径参数个数</span></span><br><span class="line">	wildChild <span class="keyword">bool</span>		<span class="comment">// child是否为通配符，若true，则其child的path就带:或*</span></span><br><span class="line">	fullPath  <span class="keyword">string</span>	<span class="comment">// 完整路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点类型</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	static nodeType = <span class="literal">iota</span> <span class="comment">// default // 普通节点，不含路径参数</span></span><br><span class="line">	root	<span class="comment">// 根节点</span></span><br><span class="line">	param	<span class="comment">// 路径参数节点，通配符:代表的节点</span></span><br><span class="line">	catchAll	<span class="comment">// 通配符*代表的节点</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>此外还有几个结构体要注意，先列出来：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Param <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key   <span class="keyword">string</span></span><br><span class="line">	Value <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Params []Param</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> methodTree <span class="keyword">struct</span> &#123;</span><br><span class="line">	method <span class="keyword">string</span></span><br><span class="line">	root   *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> methodTrees []methodTree</span><br></pre></td></tr></table></figure>

<h4 id="node-addRoute"><a href="#node-addRoute" class="headerlink" title="node.addRoute"></a>node.addRoute</h4><p>分析下engine.addRoute最终调用的node.addRoute方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">addRoute</span><span class="params">(path <span class="keyword">string</span>, handlers HandlersChain)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注意：随着代码的进行，n可能指向不同的对象，path也在不断地缩短，handlers保持不变</span></span><br><span class="line">	fullPath := path</span><br><span class="line">	n.priority++</span><br><span class="line">	numParams := countParams(path)	<span class="comment">// 计算路径参数个数，即path中:和*的个数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前节点没有设置path和children，则只可能是root节点，直接调用insertChild（见下一小节）</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(n.path) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(n.children) == <span class="number">0</span> &#123;</span><br><span class="line">		n.insertChild(numParams, path, fullPath, handlers)</span><br><span class="line">		n.nType = root</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	parentFullPathIndex := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">walk:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Update maxParams of the current node</span></span><br><span class="line">		<span class="keyword">if</span> numParams &gt; n.maxParams &#123;</span><br><span class="line">			n.maxParams = numParams</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 找到path和当前node.path的最长前缀；其中不可能包含:或*</span></span><br><span class="line">		i := longestCommonPrefix(path, n.path)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Split edge</span></span><br><span class="line">		<span class="comment">// node.path并不是path的前缀，h则进行对node的拆分</span></span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(n.path) &#123;</span><br><span class="line">			child := node&#123;	<span class="comment">// 新节点继承了原节点的一切</span></span><br><span class="line">				path:      n.path[i:],	<span class="comment">// 公共前缀之后的路径</span></span><br><span class="line">				wildChild: n.wildChild,</span><br><span class="line">				indices:   n.indices,</span><br><span class="line">				children:  n.children,</span><br><span class="line">				handlers:  n.handlers,</span><br><span class="line">				priority:  n.priority - <span class="number">1</span>,	<span class="comment">// 新节点权重减小</span></span><br><span class="line">				fullPath:  n.fullPath,</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Update maxParams (max of all children)</span></span><br><span class="line">			<span class="keyword">for</span> _, v := <span class="keyword">range</span> child.children &#123;</span><br><span class="line">				<span class="keyword">if</span> v.maxParams &gt; child.maxParams &#123;</span><br><span class="line">					child.maxParams = v.maxParams</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			n.children = []*node&#123;&amp;child&#125;	<span class="comment">// node的子节点只有刚创建的节点</span></span><br><span class="line">			<span class="comment">// []byte for proper unicode char conversion, see #65</span></span><br><span class="line">			n.indices = <span class="keyword">string</span>([]<span class="keyword">byte</span>&#123;n.path[i]&#125;)</span><br><span class="line">			n.path = path[:i] <span class="comment">// node的path被截断</span></span><br><span class="line">			n.handlers = <span class="literal">nil</span>	<span class="comment">// 注册的handlers被置为空</span></span><br><span class="line">			n.wildChild = <span class="literal">false</span></span><br><span class="line">			n.fullPath = fullPath[:parentFullPathIndex+i] <span class="comment">// fullPath被截断</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Make new node a child of this node</span></span><br><span class="line">		<span class="comment">// path并不是node.path的前缀，需要在当前node之后挂新的child</span></span><br><span class="line">		<span class="comment">// 由于此前已经截断过node.path，所以此处判断的前提是node.path必然已是path的前缀</span></span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(path) &#123;</span><br><span class="line">			path = path[i:]	<span class="comment">// 去除与node.path的公共前缀，剩下的path才是需要处理的</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> n.wildChild &#123;	<span class="comment">// 通过阅读node.insertChild，可知wildChild节点之后的节点必然是通配符节点</span></span><br><span class="line">				parentFullPathIndex += <span class="built_in">len</span>(n.path)</span><br><span class="line">				n = n.children[<span class="number">0</span>]	<span class="comment">// 通配符节点</span></span><br><span class="line">				n.priority++</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Update maxParams of the child node</span></span><br><span class="line">				<span class="keyword">if</span> numParams &gt; n.maxParams &#123;</span><br><span class="line">					n.maxParams = numParams</span><br><span class="line">				&#125;</span><br><span class="line">				numParams--	<span class="comment">// 由于当前节点为wildChild则表示下一个节点必然是通配符节点，numParams可先减1</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// Check if the wildcard matches</span></span><br><span class="line">				<span class="comment">// 判断n.path是当前path的前缀</span></span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(path) &gt;= <span class="built_in">len</span>(n.path) &amp;&amp; n.path == path[:<span class="built_in">len</span>(n.path)] &#123;</span><br><span class="line">					<span class="comment">// check for longer wildcard, e.g. :name and :names</span></span><br><span class="line">					<span class="comment">// len(n.path)&gt;=len(path)结合上一判断条件，代表n.path完全等于path</span></span><br><span class="line">					<span class="comment">// 或者path是n.path头部的一或n个segemt</span></span><br><span class="line">					<span class="keyword">if</span> <span class="built_in">len</span>(n.path) &gt;= <span class="built_in">len</span>(path) || path[<span class="built_in">len</span>(n.path)] == <span class="string">'/'</span> &#123;</span><br><span class="line">						<span class="comment">// 例如：</span></span><br><span class="line">						<span class="comment">// path=:a和n.path=:a能够match</span></span><br><span class="line">						<span class="comment">// path=:a/a和n.path=:a能够match</span></span><br><span class="line">						<span class="comment">// path=:aa和n.path=:a不能match</span></span><br><span class="line">						<span class="comment">// path=:a和n.path=:aa不能match</span></span><br><span class="line">						<span class="keyword">continue</span> walk</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 若不能匹配，将会panic</span></span><br><span class="line">			</span><br><span class="line">				...</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 经过之前的处理，目前的情况如下</span></span><br><span class="line">			<span class="comment">// 1. node.path与（此时的）path已无交集</span></span><br><span class="line">			<span class="comment">// 2. node非wildChild</span></span><br><span class="line">			<span class="comment">// 接下来要做的就是基于剩下的path构建新节点，注册为node的child</span></span><br><span class="line"></span><br><span class="line">			c := path[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">			<span class="comment">// slash after param</span></span><br><span class="line">			<span class="comment">// param节点之后还存在节点的情况下，此时c == '/'表示当前path并不以通配符起始，取子节点代替node，直接进入下一轮</span></span><br><span class="line">			<span class="keyword">if</span> n.nType == param &amp;&amp; c == <span class="string">'/'</span> &amp;&amp; <span class="built_in">len</span>(n.children) == <span class="number">1</span> &#123;</span><br><span class="line">				parentFullPathIndex += <span class="built_in">len</span>(n.path)</span><br><span class="line">				n = n.children[<span class="number">0</span>]</span><br><span class="line">				n.priority++</span><br><span class="line">				<span class="keyword">continue</span> walk</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check if a child with the next path byte exists</span></span><br><span class="line">			<span class="comment">// 遍历indices，找到与c匹配的child，修改所有child的权重</span></span><br><span class="line">			<span class="comment">// 将node置为匹配的child，进入下一轮</span></span><br><span class="line">			<span class="keyword">for</span> i, max := <span class="number">0</span>, <span class="built_in">len</span>(n.indices); i &lt; max; i++ &#123;</span><br><span class="line">				<span class="keyword">if</span> c == n.indices[i] &#123;</span><br><span class="line">					parentFullPathIndex += <span class="built_in">len</span>(n.path)</span><br><span class="line">					i = n.incrementChildPrio(i)</span><br><span class="line">					n = n.children[i]</span><br><span class="line">					<span class="keyword">continue</span> walk</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Otherwise insert it</span></span><br><span class="line">			<span class="comment">// 没有任何一个child的path和当前的path有公共前缀，且c非通配符的情况下</span></span><br><span class="line">			<span class="keyword">if</span> c != <span class="string">':'</span> &amp;&amp; c != <span class="string">'*'</span> &#123;</span><br><span class="line">				<span class="comment">// []byte for proper unicode char conversion, see #65</span></span><br><span class="line">				n.indices += <span class="keyword">string</span>([]<span class="keyword">byte</span>&#123;c&#125;)</span><br><span class="line">				<span class="comment">// 创建一个全新的节点，加入到node的children中，并调整所有之前已存在的child的权重</span></span><br><span class="line">				child := &amp;node&#123;</span><br><span class="line">					maxParams: numParams,</span><br><span class="line">					fullPath:  fullPath,</span><br><span class="line">				&#125;</span><br><span class="line">				n.children = <span class="built_in">append</span>(n.children, child)</span><br><span class="line">				n.incrementChildPrio(<span class="built_in">len</span>(n.indices) - <span class="number">1</span>)</span><br><span class="line">				n = child</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 调用insertChild完成节点的注册</span></span><br><span class="line">			n.insertChild(numParams, path, fullPath, handlers)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Otherwise and handle to current node</span></span><br><span class="line">		<span class="keyword">if</span> n.handlers != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"handlers are already registered for path '"</span> + fullPath + <span class="string">"'"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 此时node.path == path</span></span><br><span class="line">		n.handlers = handlers</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要流程：</p>
<ol>
<li>如果是root节点，直接调用insertChild</li>
<li>非root节点时，进入walk loop<ol>
<li>计算当前node.path和path的公共前缀</li>
<li>假设node.path并不是path的前缀<ol>
<li>新建一个节点，将原节点的一系列数据转移过去</li>
<li>原节点的path置为计算出的公共前缀，将其他信息重置</li>
<li>node指向新节点</li>
</ol>
</li>
<li>经过一番处理，此时的node.path必然已是path的前缀<ol>
<li>当node.path与path不相等时（node.path是path的前缀，但不是完整的path）<ol>
<li>path减去前缀node.path部分</li>
<li>如果当前node是wildChild<ol>
<li>node直接指向其child</li>
<li>确保当前path不会与node.path产生冲突</li>
<li>直接进入下一轮</li>
</ol>
</li>
<li>如果当前node为param节点，且存在child，而且path以/起始。以child替换node，进入下一轮</li>
<li>遍历indices，寻找与c匹配的indice。若找到则调整所有child的权重，并以匹配的child替换node，进入下一轮</li>
<li>如果当前node的所有child的path都和当前path无公共前缀，则往node的children中添加新节点，node指向新节点</li>
<li>调用insertChild</li>
</ol>
</li>
<li>当node.path与path完全相等时，直接往node上注册handlers</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="node-insertChild"><a href="#node-insertChild" class="headerlink" title="node.insertChild"></a>node.insertChild</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">insertChild</span><span class="params">(numParams <span class="keyword">uint8</span>, path <span class="keyword">string</span>, fullPath <span class="keyword">string</span>, handlers HandlersChain)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注意：n指向的对象在下面的代码中可能会不断变化，path会不断缩短，fullPath/handlers会保持不变</span></span><br><span class="line">	<span class="keyword">for</span> numParams &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Find prefix until first wildcard</span></span><br><span class="line">		wildcard, i, valid := findWildcard(path) <span class="comment">// 找到第一个通配符，返回该通配符的segment和其位置，并检验是否合法（通配符后接/或处于path末尾是合法的，即不存在两个连续的通配符）</span></span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="number">0</span> &#123; <span class="comment">// No wildcard found // 当前path中已不存在通配符的情况下跳出循环；在整个for循环中，path的长度会不断减少</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		... </span><br><span class="line">		<span class="comment">// 进行检查 确保满足：</span></span><br><span class="line">		<span class="comment">// 1. path中通配符合法，即一个segment只存在一个:或*</span></span><br><span class="line">		<span class="comment">// 2. 路径参数必须有一个名字，所以该segment长度必须大于1</span></span><br><span class="line">		<span class="comment">// 3. node不允许已存在child</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> wildcard[<span class="number">0</span>] == <span class="string">':'</span> &#123; <span class="comment">// param // 当前path的第一个segment是通配符:</span></span><br><span class="line">			<span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// 设置parent的path，这是一段不含任何通配符的path</span></span><br><span class="line">				n.path = path[:i]</span><br><span class="line">				<span class="comment">// 从通配符开始的剩余path</span></span><br><span class="line">				path = path[i:]</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			n.wildChild = <span class="literal">true</span> <span class="comment">// 指明是通配符节点</span></span><br><span class="line">			child := &amp;node&#123;		<span class="comment">// 创建新节点</span></span><br><span class="line">				nType:     param,     <span class="comment">// 节点类型</span></span><br><span class="line">				path:      wildcard,  <span class="comment">// 当前节点的path，由于是wildcard，实则就是一段segment</span></span><br><span class="line">				maxParams: numParams, <span class="comment">// 从当前节点往后（递归遍历其child）存在多少个param</span></span><br><span class="line">				fullPath:  fullPath, <span class="comment">// handler的完整路径，后续搜索时可以根据这个判断，node是否可对应handler</span></span><br><span class="line">			&#125;</span><br><span class="line">			n.children = []*node&#123;child&#125; <span class="comment">// 将创建的节点注册为父亲节点的child</span></span><br><span class="line">			n = child		<span class="comment">// 之后若继续处理，则以刚创建的child为父亲节点</span></span><br><span class="line">			n.priority++	<span class="comment">// 即将刚创建的child的priority设置为1</span></span><br><span class="line">			numParams--		<span class="comment">// 剩余路径参数减少</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果当前处理的segment不是最后一段，那么为剩余的path创建新的子节点，进入下一轮</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(wildcard) &lt; <span class="built_in">len</span>(path) &#123;</span><br><span class="line">				path = path[<span class="built_in">len</span>(wildcard):]</span><br><span class="line"></span><br><span class="line">				child := &amp;node&#123;</span><br><span class="line">					maxParams: numParams,</span><br><span class="line">					priority:  <span class="number">1</span>,</span><br><span class="line">					fullPath:  fullPath,</span><br><span class="line">				&#125;</span><br><span class="line">				n.children = []*node&#123;child&#125;</span><br><span class="line">				n = child</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 直到path不再有剩余，设置handlers并结束</span></span><br><span class="line">			n.handlers = handlers</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 排除当前第一个segment是通配符:的情况，剩下自然是处理*的情况，剩下自然是处理</span></span><br><span class="line">		<span class="comment">// 由于*可以匹配0或n个segment，所以最终只会往parent上注册一个child就可以，而不需要考虑child的child</span></span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 进行检查 确保满足</span></span><br><span class="line">		<span class="comment">// 1. 含*的segment之后没有其他segment；当前path中只存在一个通配符</span></span><br><span class="line">		<span class="comment">// 2. parent的path不以/结尾</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// currently fixed width 1 for '/'</span></span><br><span class="line">		i--</span><br><span class="line">		<span class="keyword">if</span> path[i] != <span class="string">'/'</span> &#123; <span class="comment">// 确保*前是/</span></span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"no / before catch-all in path '"</span> + fullPath + <span class="string">"'"</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		n.path = path[:i]</span><br><span class="line"></span><br><span class="line">		<span class="comment">// First node: catchAll node with empty path</span></span><br><span class="line">		child := &amp;node&#123;</span><br><span class="line">			wildChild: <span class="literal">true</span>,</span><br><span class="line">			nType:     catchAll,</span><br><span class="line">			maxParams: <span class="number">1</span>,</span><br><span class="line">			fullPath:  fullPath,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// update maxParams of the parent node</span></span><br><span class="line">		<span class="keyword">if</span> n.maxParams &lt; <span class="number">1</span> &#123;</span><br><span class="line">			n.maxParams = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		n.children = []*node&#123;child&#125;</span><br><span class="line">		n.indices = <span class="keyword">string</span>(<span class="string">'/'</span>)</span><br><span class="line">		n = child</span><br><span class="line">		n.priority++ <span class="comment">//priority设置为1</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// second node: node holding the variable</span></span><br><span class="line">		child = &amp;node&#123;</span><br><span class="line">			path:      path[i:],</span><br><span class="line">			nType:     catchAll,</span><br><span class="line">			maxParams: <span class="number">1</span>,</span><br><span class="line">			handlers:  handlers,</span><br><span class="line">			priority:  <span class="number">1</span>,</span><br><span class="line">			fullPath:  fullPath,</span><br><span class="line">		&#125;</span><br><span class="line">		n.children = []*node&#123;child&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If no wildcard was found, simply insert the path and handle</span></span><br><span class="line">	n.path = path</span><br><span class="line">	n.handlers = handlers</span><br><span class="line">	n.fullPath = fullPath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要流程：</p>
<ol>
<li>在numParams &gt; 0的情况下，循环处理path中剩余的含通配符的segment<ol>
<li>取出当前path中最前面的通配符segment</li>
<li>如果含通配符:<ol>
<li>如果该segment之前还有静态路径，将node的path设置为该segment之前的静态路径</li>
<li>创建一个param类型的node作为其child</li>
<li>如果该segment还没到path尾部，则再创建一个param类型的node作为child的child，之后处理的node转为这个最新的child</li>
<li>如果该segment已到path尾部，则注册handlers，并结束整个方法</li>
</ol>
</li>
<li>如果含通配符*<ol>
<li>将node的path设置为该segment之前的静态路径（不含/）</li>
<li>创建一个catchAll类型节点，作为node的child</li>
<li>再创建一个catchAll类型节点，作为前一个节点的child，其path为这段segment，handlers注册在这个节点上</li>
<li>结束整个方法</li>
</ol>
</li>
</ol>
</li>
<li>当numParams == 0，即不存在路由参数的情况下，直接设置n.path/handlers/fullPath</li>
</ol>
<h2 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h2><p>存入trees中的router和handlers在什么时候使用？</p>
<p>下方是相应的调用链，不细展开了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(address, engine) -&gt; engine.ServeHTTP(writer, req) -&gt; engine.handleHTTPRequest(c) -&gt; root.getValue(rPath, c.Params, unescape)</span><br></pre></td></tr></table></figure>

<h2 id="路由的检索"><a href="#路由的检索" class="headerlink" title="路由的检索"></a>路由的检索</h2><p>接下来从getValue出发，研究下Gin是怎么根据url定位到相应handlers的。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">getValue</span><span class="params">(path <span class="keyword">string</span>, po Params, unescape <span class="keyword">bool</span>)</span> <span class="params">(value nodeValue)</span></span> &#123;</span><br><span class="line">	value.params = po</span><br><span class="line">walk: <span class="comment">// Outer loop for walking the tree</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		prefix := n.path</span><br><span class="line">		<span class="comment">// path == n.path</span></span><br><span class="line">		<span class="keyword">if</span> path == prefix &#123;</span><br><span class="line">			<span class="comment">// 若node.handlers不为空，则返回注册的handlers</span></span><br><span class="line">			<span class="keyword">if</span> value.handlers = n.handlers; value.handlers != <span class="literal">nil</span> &#123;</span><br><span class="line">				value.fullPath = n.fullPath</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 当path为"/"且wildChild为true时，设置重定向</span></span><br><span class="line">			<span class="keyword">if</span> path == <span class="string">"/"</span> &amp;&amp; n.wildChild &amp;&amp; n.nType != root &#123;</span><br><span class="line">				value.tsr = <span class="literal">true</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果children中某个child的path以/开始，满足以下任一情况时，设置重定向</span></span><br><span class="line">			<span class="comment">// 1. 该child的path就是/，且handlers非nil</span></span><br><span class="line">			<span class="comment">// 2. 该child是catchAll类型，且子child的handlers非nil（这里的逻辑有点不能理解，按前面分析的insertChild方法，树上只有通配符*会产生连续的两个catchAll节点，而第一个catchAll节点的path是空的，不可能满足此处的条件</span></span><br><span class="line">			indices := n.indices</span><br><span class="line">			<span class="keyword">for</span> i, max := <span class="number">0</span>, <span class="built_in">len</span>(indices); i &lt; max; i++ &#123;</span><br><span class="line">				<span class="keyword">if</span> indices[i] == <span class="string">'/'</span> &#123;</span><br><span class="line">					n = n.children[i]</span><br><span class="line">					value.tsr = (<span class="built_in">len</span>(n.path) == <span class="number">1</span> &amp;&amp; n.handlers != <span class="literal">nil</span>) ||</span><br><span class="line">						(n.nType == catchAll &amp;&amp; n.children[<span class="number">0</span>].handlers != <span class="literal">nil</span>)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// node.path是path前缀的情况</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; <span class="built_in">len</span>(prefix) &amp;&amp; path[:<span class="built_in">len</span>(prefix)] == prefix &#123;</span><br><span class="line">			path = path[<span class="built_in">len</span>(prefix):]	<span class="comment">// 截断path</span></span><br><span class="line">			<span class="comment">// 非wildChild的情况，因为wildChild的话，直接处理child即可</span></span><br><span class="line">			<span class="keyword">if</span> !n.wildChild &#123;</span><br><span class="line">				c := path[<span class="number">0</span>]</span><br><span class="line">				indices := n.indices</span><br><span class="line">				<span class="comment">// 根据indices快速（？）寻找匹配的child，进入下一轮</span></span><br><span class="line">				<span class="keyword">for</span> i, max := <span class="number">0</span>, <span class="built_in">len</span>(indices); i &lt; max; i++ &#123;</span><br><span class="line">					<span class="keyword">if</span> c == indices[i] &#123;</span><br><span class="line">						n = n.children[i]</span><br><span class="line">						<span class="keyword">continue</span> walk</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 没有匹配的child的话，如果path为/且当前nodes含handlers，则设置重定向</span></span><br><span class="line">				<span class="comment">// 例如 当前url中是 /a/b/c/，而注册在案的路由只有 /a/b/c，那么就可以顺利地进行重定向</span></span><br><span class="line">				value.tsr = path == <span class="string">"/"</span> &amp;&amp; n.handlers != <span class="literal">nil</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 对于wildChild，直接处理其child</span></span><br><span class="line">			n = n.children[<span class="number">0</span>]</span><br><span class="line">			<span class="keyword">switch</span> n.nType &#123;</span><br><span class="line">			<span class="keyword">case</span> param:</span><br><span class="line">				<span class="comment">// 找到:能匹配到的一段segment</span></span><br><span class="line">				end := <span class="number">0</span></span><br><span class="line">				<span class="keyword">for</span> end &lt; <span class="built_in">len</span>(path) &amp;&amp; path[end] != <span class="string">'/'</span> &#123;</span><br><span class="line">					end++</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 扩容params，达到必然满足要求的最小容量</span></span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">cap</span>(value.params) &lt; <span class="keyword">int</span>(n.maxParams) &#123;</span><br><span class="line">					value.params = <span class="built_in">make</span>(Params, <span class="number">0</span>, n.maxParams)</span><br><span class="line">				&#125;</span><br><span class="line">				i := <span class="built_in">len</span>(value.params)</span><br><span class="line">				value.params = value.params[:i+<span class="number">1</span>] <span class="comment">// expand slice within preallocated capacity</span></span><br><span class="line">				<span class="comment">// param的键</span></span><br><span class="line">				value.params[i].Key = n.path[<span class="number">1</span>:]</span><br><span class="line">				<span class="comment">// 从path中获取param对应的值</span></span><br><span class="line">				val := path[:end]</span><br><span class="line">				<span class="comment">// 转义</span></span><br><span class="line">				<span class="keyword">if</span> unescape &#123;</span><br><span class="line">					<span class="keyword">var</span> err error</span><br><span class="line">					<span class="keyword">if</span> value.params[i].Value, err = url.QueryUnescape(val); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						value.params[i].Value = val <span class="comment">// fallback, in case of error</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					value.params[i].Value = val</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 由上面逻辑可知，params与path中实际的路由参数组是逆序的</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// 还未到path末尾的话，则截断path，node指向child，继续</span></span><br><span class="line">				<span class="keyword">if</span> end &lt; <span class="built_in">len</span>(path) &#123;</span><br><span class="line">					<span class="keyword">if</span> <span class="built_in">len</span>(n.children) &gt; <span class="number">0</span> &#123;</span><br><span class="line">						path = path[end:]</span><br><span class="line">						n = n.children[<span class="number">0</span>]</span><br><span class="line">						<span class="keyword">continue</span> walk</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 如果没有children可用了，则重定向</span></span><br><span class="line">					value.tsr = <span class="built_in">len</span>(path) == end+<span class="number">1</span></span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> value.handlers = n.handlers; value.handlers != <span class="literal">nil</span> &#123;</span><br><span class="line">					value.fullPath = n.fullPath</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(n.children) == <span class="number">1</span> &#123;</span><br><span class="line">					<span class="comment">// 重定向</span></span><br><span class="line">					n = n.children[<span class="number">0</span>]</span><br><span class="line">					value.tsr = n.path == <span class="string">"/"</span> &amp;&amp; n.handlers != <span class="literal">nil</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="comment">// 直接将路由参数匹配完剩下的path</span></span><br><span class="line">			<span class="keyword">case</span> catchAll:</span><br><span class="line">				<span class="comment">// save param value</span></span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">cap</span>(value.params) &lt; <span class="keyword">int</span>(n.maxParams) &#123;</span><br><span class="line">					value.params = <span class="built_in">make</span>(Params, <span class="number">0</span>, n.maxParams)</span><br><span class="line">				&#125;</span><br><span class="line">				i := <span class="built_in">len</span>(value.params)</span><br><span class="line">				value.params = value.params[:i+<span class="number">1</span>] <span class="comment">// expand slice within preallocated capacity</span></span><br><span class="line">				value.params[i].Key = n.path[<span class="number">2</span>:]</span><br><span class="line">				<span class="keyword">if</span> unescape &#123;</span><br><span class="line">					<span class="keyword">var</span> err error</span><br><span class="line">					<span class="keyword">if</span> value.params[i].Value, err = url.QueryUnescape(path); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						value.params[i].Value = path <span class="comment">// fallback, in case of error</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					value.params[i].Value = path</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				value.handlers = n.handlers</span><br><span class="line">				value.fullPath = n.fullPath</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">"invalid node type"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 重定向</span></span><br><span class="line">		value.tsr = (path == <span class="string">"/"</span>) ||</span><br><span class="line">			(<span class="built_in">len</span>(prefix) == <span class="built_in">len</span>(path)+<span class="number">1</span> &amp;&amp; prefix[<span class="built_in">len</span>(path)] == <span class="string">'/'</span> &amp;&amp;</span><br><span class="line">				path == prefix[:<span class="built_in">len</span>(prefix)<span class="number">-1</span>] &amp;&amp; n.handlers != <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本阅读完了Gin的router模块（<a href="https://github.com/julienschmidt/httprouter" target="_blank" rel="noopener">https://github.com/julienschmidt/httprouter</a> 也就是这个项目），其对于radix的处理逻辑有点复杂，但大致思想我们已可以感受到。</p>
<p>所以Gin为什么快，源于其Radix的实现，令具有公共前缀的路由尽可能地复用相同的节点，使得树的深度尽量浅，以获得高效的查询效率。</p>
<p>举个例子，需要组建如下所示的路由：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">"/ping"</span>, <span class="literal">nil</span>)</span><br><span class="line">r.GET(<span class="string">"/p/*segs"</span>, <span class="literal">nil</span>))</span><br><span class="line">r.GET(<span class="string">"/ping/:seg"</span>, <span class="literal">nil</span>)</span><br><span class="line">r.Group(<span class="string">"/v1"</span>).GET(<span class="string">"/get"</span>))</span><br></pre></td></tr></table></figure>

<p>最终内存中树结构看起来是这样的：</p>
<img src="/2020/05/01/gin_router_2/index/radix.png" width="1000" height="600" align="center">


<h2 id="Gin的不足"><a href="#Gin的不足" class="headerlink" title="Gin的不足"></a>Gin的不足</h2><p>Gin在使用路由参数时依旧存在一些bug，与依赖的httprouter项目一直没修复相关，所以目前还没看到有改进计划，见<a href="https://github.com/gin-gonic/gin/issues/2016" target="_blank" rel="noopener">https://github.com/gin-gonic/gin/issues/2016</a></p>
<p>bug例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1) 同一位值，参数和静态路径冲突</span><br><span class="line">r.GET(&quot;&#x2F;ping&#x2F;:seg&#x2F;1&quot;, nil)</span><br><span class="line">r.GET(&quot;&#x2F;ping&#x2F;seg&#x2F;1&quot;, nil)</span><br><span class="line"></span><br><span class="line">2）同一位置，不同名的参数冲突</span><br><span class="line">r.GET(&quot;&#x2F;ping&#x2F;:seg&#x2F;1&quot;, nil)</span><br><span class="line">r.GET(&quot;&#x2F;ping&#x2F;:se&quot;, nil)</span><br><span class="line">或者</span><br><span class="line">r.GET(&quot;&#x2F;ping&#x2F;:seg&#x2F;1&quot;, nil)</span><br><span class="line">r.GET(&quot;&#x2F;ping&#x2F;:se&#x2F;2&quot;, nil)</span><br></pre></td></tr></table></figure>

<p>这样的bug可以归纳为：路由参数是排他的，一个位置（前缀相同）上只要存在了路由参数，就不能再定义静态路径或其他名字参数了，因为httprouter中并没有给静态路径和路由参数定义优先级…</p>
<p>要避免这个问题，方法也简单，只要遵守两点：</p>
<ol>
<li>不要在同一位置放不同名称的参数</li>
<li>想要在同一位置放参数和静态路径，可以选择统一成路由参数，再通过handler进行分发，示例如下<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//r.GET("/ping/:seg/1", handler1)</span></span><br><span class="line"><span class="comment">//r.GET("/ping/seg/1", handler2)</span></span><br><span class="line">r.GET(<span class="string">"/ping/:seg/1"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	seg := c.Param(<span class="string">"seg"</span>)</span><br><span class="line">	<span class="keyword">if</span> seg == <span class="string">"seg"</span> &#123;</span><br><span class="line">		handler1(c)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		handler2(c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>另外有点不合理的是Gin并没有对HANDLE/GET/POST/Group/Use等方法做非nil的判断，导致只有在request进来的时候才会提示空指针问题。</p>
<blockquote><p>同步自 <a href="https://github.com/pangsq/useGin/blob/master/articles/router_analysis_2.md" target="_blank" rel="noopener">https://github.com/pangsq/useGin/blob/master/articles/router_analysis_2.md</a></p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/01/gin_router_1/index/">Gin路由分析（一）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Gin/">Gin</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Gin/">Gin</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Router/">Router</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Golang/">Golang</a></span><div class="content"><p>Gin是Golang开发的一个Web框架，特点是轻量、高效。</p>
<p>由于Golang本身net/http功能已经很强大且易用，一般小型Web项目用自带的库足矣。</p>
<p>Gin更多地是关注复杂的router逻辑和方便中间件的嵌入（如认证、日志等），以便于团队协作和代码的工程化管理。</p>
<p>本文来分析下Gin的router。</p>
<h2 id="从一个普普通通的Gin使用例子开始"><a href="#从一个普普通通的Gin使用例子开始" class="headerlink" title="从一个普普通通的Gin使用例子开始"></a>从一个普普通通的Gin使用例子开始</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; r :&#x3D; gin.New()</span><br><span class="line">r :&#x3D; gin.Default() &#x2F;&#x2F; Default()会在New的基础上，注入默认的Logger和Recovery两个handler</span><br><span class="line">rg :&#x3D; r.Group(&quot;&#x2F;v1&quot;, middleware1, middleware2) &#x2F;&#x2F; 创建一个RouterGroup，并注册两个middleware</span><br><span class="line">rg1 :&#x3D; rg.Use(middleware2)  &#x2F;&#x2F; 注册一个middlerware</span><br><span class="line">rg1.Handle(http.MethodGet, &quot;&#x2F;ping&quot;, handler1)  &#x2F;&#x2F; 注册一个request handler</span><br><span class="line">r.Run()</span><br></pre></td></tr></table></figure>

<p>先搞明白各种方法（除了Run）的返回类型。</p>
<ol>
<li>Default/New 返回的是 *Engine</li>
<li>Group 返回的是 *RouterGroup</li>
<li>Use 返回的是 IRoutes</li>
<li>Handler 返回的是 IRoutes</li>
</ol>
<h3 id="IRoutes"><a href="#IRoutes" class="headerlink" title="IRoutes"></a>IRoutes</h3><p>首先来看看出现的接口IRoutes，涵盖了各种http handler的注册。</p>
<p>Use用于中间件的注册，Handle是通用的handler注册接口（可以在入参中指定是httpMethod）,Any匹配任意httpMethod，从GET到HEAD是特定httpMethod的handler注册，而StaticFile/Static/StaticFS用于静态资源的注册。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IRoutes <span class="keyword">interface</span> &#123;</span><br><span class="line">	Use(...HandlerFunc) IRoutes</span><br><span class="line"></span><br><span class="line">	Handle(<span class="keyword">string</span>, <span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">	Any(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">	GET(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">	POST(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">	DELETE(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">	PATCH(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">	PUT(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">	OPTIONS(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">	HEAD(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line"></span><br><span class="line">	StaticFile(<span class="keyword">string</span>, <span class="keyword">string</span>) IRoutes</span><br><span class="line">	Static(<span class="keyword">string</span>, <span class="keyword">string</span>) IRoutes</span><br><span class="line">	StaticFS(<span class="keyword">string</span>, http.FileSystem) IRoutes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处先引出IRouter接口，下文即将用到。</p>
<p>IRouter比起IRoutes仅多另一个Group方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IRouter <span class="keyword">interface</span> &#123;</span><br><span class="line">	IRoutes</span><br><span class="line">	Group(<span class="keyword">string</span>, ...HandlerFunc) *RouterGroup</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">	RouterGroup</span><br><span class="line"></span><br><span class="line">	... <span class="comment">//其他暂不关心的成员</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> _ IRouter = &amp;Engine&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Engine中与路由相关的是一个RouterGroup。按Golang匿名成员的写法，Engine继承了RouterGroup的方法，我们可以将Engine看做是功能更加丰富的RouterGroup。</p>
<h3 id="RouterGroup"><a href="#RouterGroup" class="headerlink" title="RouterGroup"></a>RouterGroup</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RouterGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	Handlers HandlersChain</span><br><span class="line">	basePath <span class="keyword">string</span></span><br><span class="line">	engine   *Engine</span><br><span class="line">	root     <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ IRouter = &amp;RouterGroup&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>RouterGroup是Gin路由功能的核心组件，它实现了IRouter/IRoutes接口。</p>
<p>在例子中Use/Handler返回的实际也是它，但通过IRoutes接口限制，避免了对Use/Handler结果再调用Group。</p>
<p>RouterGroup的成员：</p>
<ol>
<li>Handlers HandlersChain  // 存放中间件方法的数组。由于中间件（如认证、日志等）本质也是和业务逻辑相同的HandlerFunc，所以最终会在调用业务逻辑的HandlerFunc前先调用这些HandlerFunc</li>
<li>basePath string         // 基础url路径</li>
<li>engine *Engine          // Engine是一个项目中唯一的，所有的RouterGroup都会指向同一个</li>
<li>root bool               // Engine本身也是个RouterGroup，它被认为是root</li>
</ol>
<h2 id="关于RouterGroup的一切"><a href="#关于RouterGroup的一切" class="headerlink" title="关于RouterGroup的一切"></a>关于RouterGroup的一切</h2><p>RouterGroup的设计并不复杂，在routergroup.go中完全实现。</p>
<h3 id="Use-——-中间件的添加"><a href="#Use-——-中间件的添加" class="headerlink" title="Use —— 中间件的添加"></a>Use —— 中间件的添加</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">Use</span><span class="params">(middleware ...HandlerFunc)</span> <span class="title">IRoutes</span></span> &#123;</span><br><span class="line">	group.Handlers = <span class="built_in">append</span>(group.Handlers, middleware...)</span><br><span class="line">	<span class="keyword">return</span> group.returnObj()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将middleware添加到group.Handlers，并返回本身（如果是root，则返回engine）</p>
<h3 id="Group-——-创建子RouterGroup"><a href="#Group-——-创建子RouterGroup" class="headerlink" title="Group —— 创建子RouterGroup"></a>Group —— 创建子RouterGroup</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">Group</span><span class="params">(relativePath <span class="keyword">string</span>, handlers ...HandlerFunc)</span> *<span class="title">RouterGroup</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;RouterGroup&#123;</span><br><span class="line">		Handlers: group.combineHandlers(handlers),</span><br><span class="line">		basePath: group.calculateAbsolutePath(relativePath),</span><br><span class="line">		engine:   group.engine,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>创建新的RouterGroup</li>
<li>新RouterGroup继承此时原RouterGroup的Handlers，并添加新的handlers。<ol>
<li>此后若原RouterGroup继续使用Use添加handler，新RouterGroup的handlers不随之改变</li>
<li>此处的handlers均是middlewares</li>
</ol>
</li>
<li>计算新RouterGroup的basePath</li>
<li>engine依旧指向同一个engine</li>
</ol>
<h3 id="handle-——-注册业务逻辑的handler"><a href="#handle-——-注册业务逻辑的handler" class="headerlink" title="handle —— 注册业务逻辑的handler"></a>handle —— 注册业务逻辑的handler</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">handle</span><span class="params">(httpMethod, relativePath <span class="keyword">string</span>, handlers HandlersChain)</span> <span class="title">IRoutes</span></span> &#123;</span><br><span class="line">	absolutePath := group.calculateAbsolutePath(relativePath)</span><br><span class="line">	handlers = group.combineHandlers(handlers)</span><br><span class="line">	group.engine.addRoute(httpMethod, absolutePath, handlers)</span><br><span class="line">	<span class="keyword">return</span> group.returnObj()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>计算url的绝对路径</li>
<li>计算包含一些列middlewares和最终handler的handlers</li>
<li>调用engine.addRoute将route注册<ol>
<li>此后若group的Handlers有变化，也不对已经注册的这条路由有任何影响</li>
</ol>
</li>
<li>返回group</li>
</ol>
<p>Handle/Any/Get/POST/DELETE/PATCH/PUT/OPTIONS/HEAD/StaticFile/Static/StaticFS的实现均基于handle。</p>
<p>挑一个比较特殊的Any看看</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">Any</span><span class="params">(relativePath <span class="keyword">string</span>, handlers ...HandlerFunc)</span> <span class="title">IRoutes</span></span> &#123;</span><br><span class="line">	group.handle(http.MethodGet, relativePath, handlers)</span><br><span class="line">	group.handle(http.MethodPost, relativePath, handlers)</span><br><span class="line">	group.handle(http.MethodPut, relativePath, handlers)</span><br><span class="line">	group.handle(http.MethodPatch, relativePath, handlers)</span><br><span class="line">	group.handle(http.MethodHead, relativePath, handlers)</span><br><span class="line">	group.handle(http.MethodOptions, relativePath, handlers)</span><br><span class="line">	group.handle(http.MethodDelete, relativePath, handlers)</span><br><span class="line">	group.handle(http.MethodConnect, relativePath, handlers)</span><br><span class="line">	group.handle(http.MethodTrace, relativePath, handlers)</span><br><span class="line">	<span class="keyword">return</span> group.returnObj()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很直接，将所有的httpMethod都注册。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>通过New/Default创建Engine</li>
<li>Engine/RouterGroup存放basePath和handlers（用于中间件），使用Use可以往handlers中添加新的middleware</li>
<li>基于Engine或RouterGroup可以创建新的RouterGroup，新的RouterGroup继承创建时Engine或RouterGroup的handlers</li>
<li>使用Engine或RouterGroup的Handle/Any/Get/…等方法注册业务用handler，会使用其中包含的handlers（HandlersChain）和basePath</li>
</ol>
<blockquote><p>同步自 <a href="https://github.com/pangsq/useGin/blob/master/articles/router_analysis_1.md" target="_blank" rel="noopener">https://github.com/pangsq/useGin/blob/master/articles/router_analysis_1.md</a></p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/01/sharedIndexInformer/index/">Kubernetes运行机制 —— SharedIndexInformer</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Kubernetes/">Kubernetes</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Golang/">Golang</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Kubernetes/">Kubernetes</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Informer/">Informer</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Cache/">Cache</a></span><div class="content"><p>SharedIndexInformer是k8s的client-go中一个功能强大的工具，通过它可以在client端缓存apiserver中的资源实例状态，以提高对整集群管理、调谐的效率。</p>
<p>无论在controller-manager/scheduler等原生组件中还是用kubebuilder编写crd的controller中都会用到它，因此对它内部的实现进行了解是很有必要的。</p>
<p>SharedIndexInformer的运行大致可以表述成：</p>
<ol>
<li>利用ListWatch机制不断从apiserver处获取某一类型的资源实例，存入本地内存中的一个Indexer（带索引和其他丰富接口的缓存）。</li>
<li>并辅以一个Queue（按照先后顺序）对外进行通知（资源实例的变化——增删改 到来时触发用户事先自定义好的事件句柄）。</li>
<li>一般情况下，触发的事件句柄会把资源变化事件放入一个workQueue，另有线程（可以有多个并行）从中拾取事件进行处理（基于本类型或其他类型资源的Indexer作出正确的决策）。当然这是后话，本文暂不具体展开。</li>
</ol>
<p>下文以三个层次对SharedIndexInformer进行分析，分别是：</p>
<ol>
<li>静态：数据结构，出于利用索引提高读性能、顺序访问、线程安全、缓冲、阻塞等待等目的而实现，如Indexer、Queue、RingGrowing等</li>
<li>动态：运行机制，创建、初始化、运行、运行时的各种goroutine被带起的时机</li>
<li>动静结合：完整的数据处理流程，从访问apiserver获取资源到分发、处理、存储资源的整个流程</li>
</ol>
<p>：如下文出现代码均以release-1.18分支为例。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>SharedIndexInformer，在cache包中提供了对应的实现sharedIndexInformer，其依赖一些自定义的特殊结构，先讲讲它们。</p>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>Store，一个通用的对象存储和处理的接口，可以简单理解成：以一个map为核心（存取数据），并提供丰富的接口方法（Add/Update/Delete/List/ListKeys/Get/GetByKey/Replace/Resync）。</p>
<p>Store在client-go/tools/cache库中并没有直接的实现，而是延伸出了两种新接口：Indexer和Queue，分别作为带索引的Store和维护处理顺序的Store。在具体业务逻辑中，这两者往往结合使用。</p>
<p>Store/Indexer/Queue的继承关系与实现的结构体如下图所示：</p>
<p><img src="/2020/05/01/sharedIndexInformer/index/store.png" alt="store"></p>
<h4 id="Indexer"><a href="#Indexer" class="headerlink" title="Indexer"></a>Indexer</h4><p>实现Indexer的结构体是cache，而cache的核心在ThreadSafeStore（cache封装了ThreadSafeStore的相应方法，而Add/Update/Delete等方法实现上是先调用keyFunc获取对象的key再调用后者相应方法）。</p>
<p>keyFunc作用是计算某个对象的key，相同key的对象就可以确定是同一个对象实例的副本。由于底层数据存储的实现上是一个map，自然就可以用对象实例的新副本覆盖旧副本（或者如DeltaFIFO中那样保存不同版本）。</p>
<p>对于k8s的资源对象，普遍使用的keyFunc是MetaNamespaceKeyFunc，如对Pod就可以计算 <code>Pod的namespace/Pod的name</code> 作为key。</p>
<h5 id="threadSafeMap"><a href="#threadSafeMap" class="headerlink" title="threadSafeMap"></a>threadSafeMap</h5><p>threadSafeMap实现了ThreadSafeStore，具体是如何实现的，有必要贴下其结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type threadSafeMap struct &#123;</span><br><span class="line">	lock  sync.RWMutex</span><br><span class="line">	items map[string]interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">	indexers Indexers</span><br><span class="line">	indices Indices</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type IndexFunc func(obj interface&#123;&#125;) ([]string, error)</span><br><span class="line"></span><br><span class="line">type Index map[string]sets.String</span><br><span class="line"></span><br><span class="line">type Indexers map[string]IndexFunc</span><br><span class="line"></span><br><span class="line">type Indices map[string]Index</span><br></pre></td></tr></table></figure>

<p>简单说明：</p>
<ol>
<li>items作为存储对象key-value对的 核心结构</li>
<li>indexers存储一系列索引方法</li>
<li>indices存储通过将indexers中的索引方法作用在items上计算得出的索引key和索引values(此处有点绕，结合实例才方便理解)</li>
</ol>
<p>举个例子：(模仿<a href="https://github.com/kubernetes/kubernetes/blob/29e4e66b597e8fed0a41b77d99653941ae742103/pkg/controller/nodelifecycle/node_lifecycle_controller.go#L130:1" target="_blank" rel="noopener">nodeNameKeyIndex</a>以nodename为索引)</p>
<p>假设此时items中含我们预设的Pod（精简了结构的），其key-value对如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;default&#x2F;pod1&quot; -&gt; Pod&#123;</span><br><span class="line">    nodename: &quot;node1&quot;</span><br><span class="line">&#125;</span><br><span class="line">&quot;default&#x2F;pod2&quot; -&gt; Pod&#123;</span><br><span class="line">    nodename: &quot;node1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时该Indexer包含一个nodename索引，那么Indexers的key-value对如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;nodename&quot; -&gt;  nodeNameKeyIndex</span><br></pre></td></tr></table></figure>

<p>nodeNameKeyIndex代码逻辑为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func nodeNameKeyIndex(obj interface&#123;&#125;) ([]string, error) &#123;</span><br><span class="line">	pod, ok :&#x3D; obj.(*Pod)</span><br><span class="line">	if !ok &#123;</span><br><span class="line">		return []string&#123;&#125;, nil</span><br><span class="line">	&#125;</span><br><span class="line">	if pod.nodename &#x3D;&#x3D; &quot;&quot; &#123;</span><br><span class="line">		return []string&#123;&#125;, nil</span><br><span class="line">	&#125;</span><br><span class="line">	return []string&#123;pod.nodename&#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么最终indices的数据组织如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;nodename&quot; -&gt; &#123;</span><br><span class="line">    &quot;node1&quot; -&gt; &#123; &quot;default&#x2F;pod1&quot;, &quot;default&#x2F;pod2&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Indexer的使用例子"><a href="#Indexer的使用例子" class="headerlink" title="Indexer的使用例子"></a>Indexer的使用例子</h5><p>代码放在<a href="https://github.com/pangsq/read_code_of_k8s/blob/master/tools/cache/SharedIndexInformer/example/main.go" target="_blank" rel="noopener">SharedIndexInformer/example/main.go</a></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Resource <span class="keyword">struct</span> &#123;</span><br><span class="line">	Namespace <span class="keyword">string</span></span><br><span class="line">	Name      <span class="keyword">string</span></span><br><span class="line">	Nodename  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertEquals</span><span class="params">(obj, target <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> obj != target &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"%v is not equal to %v"</span>, obj, target))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cache.MetaNamespaceKeyFunc是client-go中常用的keyFunc(计算object的key)，将`namespace/name`作为对象的唯一键</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">metaNamespaceKeyFunc</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> res, ok := obj.(*Resource); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> res.Namespace + <span class="string">"/"</span> + res.Name, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"Wrong resource type"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">useIndexer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	metaNamespaceKeyFunc := <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> res, ok := obj.(*Resource); ok &#123;</span><br><span class="line">			<span class="keyword">return</span> res.Namespace + <span class="string">"/"</span> + res.Name, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"Wrong resource type"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 以nodename为键的索引</span></span><br><span class="line">	indexByNodename := <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">		res := obj.(*Resource)</span><br><span class="line">		nodename := res.Nodename</span><br><span class="line">		<span class="keyword">return</span> []<span class="keyword">string</span>&#123;nodename&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 索引可以在初始化Indexer的时候放入，也可以通过AddIndexers添加</span></span><br><span class="line">	resourceIndexer := cache.NewIndexer(cache.KeyFunc(metaNamespaceKeyFunc),</span><br><span class="line">		cache.Indexers&#123;<span class="string">"byNodename"</span>: indexByNodename&#125;)</span><br><span class="line">	defaultRes1 := &amp;Resource&#123;</span><br><span class="line">		Namespace: <span class="string">"default"</span>,</span><br><span class="line">		Name:      <span class="string">"res1"</span>,</span><br><span class="line">		Nodename:  <span class="string">"node1"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	extendRes1 := &amp;Resource&#123;</span><br><span class="line">		Namespace: <span class="string">"extend"</span>,</span><br><span class="line">		Name:      <span class="string">"res1"</span>,</span><br><span class="line">		Nodename:  <span class="string">"node1"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// listWatch的list会调用Replace将现存的事例批量导入到Indexer中</span></span><br><span class="line">	<span class="comment">// resourceVersion在目前client-go实现的几个Store中并没有实际使用到</span></span><br><span class="line">	resourceIndexer.Replace([]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		defaultRes1, extendRes1,</span><br><span class="line">	&#125;, <span class="string">"0"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据对象获取对象</span></span><br><span class="line">	res, _, _ := resourceIndexer.Get(defaultRes1)</span><br><span class="line">	assertEquals(res.(*Resource).Nodename, <span class="string">"node1"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过key获取对象</span></span><br><span class="line">	res, _, _ = resourceIndexer.GetByKey(<span class="string">"default/res1"</span>)</span><br><span class="line">	assertEquals(res.(*Resource).Nodename, <span class="string">"node1"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加对象，如果已存在则是修改已有对象，实际实现上与Update并无二致</span></span><br><span class="line">	newRes := &amp;Resource&#123; <span class="comment">// 构造与res1同一个对象（namespace和name一致即可判定为同一资源对象），仅修改nodename</span></span><br><span class="line">		Namespace: <span class="string">"default"</span>,</span><br><span class="line">		Name:      <span class="string">"res1"</span>,</span><br><span class="line">		Nodename:  <span class="string">"node2"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	resourceIndexer.Add(newRes)</span><br><span class="line">	<span class="comment">// 修改后，存在以node2为键的byNodename索引</span></span><br><span class="line">	reses, _ := resourceIndexer.ByIndex(<span class="string">"byNodename"</span>, <span class="string">"node2"</span>)</span><br><span class="line">	assertEquals(<span class="built_in">len</span>(reses), <span class="number">1</span>)</span><br><span class="line">	assertEquals(reses[<span class="number">0</span>].(*Resource).Name, <span class="string">"res1"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>实现Queue的结构体有FIFO和DeltaFIFO，两者差别在于前者存放对象的一个最新版本，而后者可以存放对象的多个历史版本。</p>
<p>Delta具体是何物，与对象本身有什么联系，通过阅读下面的代码很容易理解。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Deltas []Delta</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Delta <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type   DeltaType</span><br><span class="line">	Object <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Added   DeltaType = <span class="string">"Added"</span></span><br><span class="line">	Updated DeltaType = <span class="string">"Updated"</span></span><br><span class="line">	Deleted DeltaType = <span class="string">"Deleted"</span></span><br><span class="line">	Replaced DeltaType = <span class="string">"Replaced"</span></span><br><span class="line">	Sync DeltaType = <span class="string">"Sync"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>FIFO和DeltaFIFO使用<code>queue []string</code>数组来维护先后顺序，并用sync.Cond来实现Pop时的阻塞（相较于异步非阻塞，同步阻塞的方法对于使用者的心智负担无疑是更小的）</p>
<h5 id="Queue的使用例子"><a href="#Queue的使用例子" class="headerlink" title="Queue的使用例子"></a>Queue的使用例子</h5><p>代码放在<a href="https://github.com/pangsq/read_code_of_k8s/blob/master/tools/cache/SharedIndexInformer/example/main.go" target="_blank" rel="noopener">SharedIndexInformer/example/main.go</a></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">useQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">	queue := cache.NewDeltaFIFO(metaNamespaceKeyFunc, <span class="literal">nil</span>)</span><br><span class="line">	lock := sync.Mutex&#123;&#125;</span><br><span class="line">	cond := sync.NewCond(&amp;lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ch := make(chan struct&#123;&#125;)</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		defaultRes1 := &amp;Resource&#123;</span><br><span class="line">			Namespace: <span class="string">"default"</span>,</span><br><span class="line">			Name:      <span class="string">"res1"</span>,</span><br><span class="line">			Nodename:  <span class="string">"node1"</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		extendRes1 := &amp;Resource&#123;</span><br><span class="line">			Namespace: <span class="string">"extend"</span>,</span><br><span class="line">			Name:      <span class="string">"res1"</span>,</span><br><span class="line">			Nodename:  <span class="string">"node1"</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Replace一般用于初始化</span></span><br><span class="line">		queue.Replace([]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">			defaultRes1, extendRes1,</span><br><span class="line">		&#125;, <span class="string">"0"</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 等待初始化放入(Sync)的资源被消费完毕</span></span><br><span class="line">		lock.Lock()</span><br><span class="line">		<span class="keyword">for</span> !queue.HasSynced() &#123;</span><br><span class="line">			cond.Wait()</span><br><span class="line">		&#125;</span><br><span class="line">		lock.Unlock()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 修改资源</span></span><br><span class="line">		defaultRes2 := &amp;Resource&#123;</span><br><span class="line">			Namespace: <span class="string">"default"</span>,</span><br><span class="line">			Name:      <span class="string">"res2"</span>,</span><br><span class="line">			Nodename:  <span class="string">"node1"</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		newDefaultRes2 := &amp;Resource&#123;</span><br><span class="line">			Namespace: <span class="string">"default"</span>,</span><br><span class="line">			Name:      <span class="string">"res2"</span>,</span><br><span class="line">			Nodename:  <span class="string">"node2"</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		queue.Add(defaultRes2)</span><br><span class="line">		queue.Update(newDefaultRes2)</span><br><span class="line"></span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		queue.Close()</span><br><span class="line">		<span class="comment">// close()</span></span><br><span class="line">	&#125;()</span><br><span class="line">	records := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 设计一个简单的处理逻辑：仅仅负责将资源信息打印出来</span></span><br><span class="line">	<span class="comment">// 真正业务中常是将资源事例放入一个workqueue中</span></span><br><span class="line">	recordFunc := <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		deltas := obj.(cache.Deltas)</span><br><span class="line">		<span class="comment">// 取最新的状态</span></span><br><span class="line">		res := deltas.Newest().Object.(*Resource)</span><br><span class="line"></span><br><span class="line">		record := fmt.Sprintf(<span class="string">"%v/%v is on %s , last change is %v, oldest change is %v"</span>,</span><br><span class="line">			res.Namespace, res.Name, res.Nodename, deltas.Newest().Type, deltas.Oldest().Type)</span><br><span class="line">		records = <span class="built_in">append</span>(records, record)</span><br><span class="line">		<span class="comment">// fmt.Println(record)</span></span><br><span class="line">		cond.Signal()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		_, err := queue.Pop(cache.PopProcessFunc(recordFunc))</span><br><span class="line">		<span class="comment">// 一般处理器会限流</span></span><br><span class="line">		time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			assertEquals(err, cache.ErrFIFOClosed)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// for _, rec := range records &#123;</span></span><br><span class="line">	<span class="comment">// 	fmt.Println(rec)</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	assertEquals(records[<span class="number">0</span>], <span class="string">"default/res1 is on node1 , last change is Sync, oldest change is Sync"</span>)     <span class="comment">// 按照顺序，default/res1是最先被添加到Queue的</span></span><br><span class="line">	assertEquals(records[<span class="number">1</span>], <span class="string">"extend/res1 is on node1 , last change is Sync, oldest change is Sync"</span>)      <span class="comment">// 按照顺序，extend/res1是第二个被添加到Queue的</span></span><br><span class="line">	assertEquals(records[<span class="number">2</span>], <span class="string">"default/res2 is on node2 , last change is Updated, oldest change is Added"</span>) <span class="comment">// default/res2最后加入，Deltas中存在它的两个版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="RingGrowing"><a href="#RingGrowing" class="headerlink" title="RingGrowing"></a>RingGrowing</h4><p>一个可增长的环形buffer，作为读写速度不一致时的缓冲区。</p>
<h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>SharedIndexInformer的创建一般有两种：直接创建、借助工厂类。</p>
<h4 id="直接创建"><a href="#直接创建" class="headerlink" title="直接创建"></a>直接创建</h4><p>直接上<a href="https://github.com/pangsq/read_code_of_k8s/blob/master/tools/cache/SharedIndexInformer/example/main.go" target="_blank" rel="noopener">例子</a></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createSharedIndexInformer</span><span class="params">(c *kubernetes.Clientset)</span> <span class="title">cache</span>.<span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">	namespace := v1.NamespaceAll</span><br><span class="line">	podListWatcher := cache.NewListWatchFromClient(c.CoreV1().RESTClient(), <span class="string">"pods"</span>, namespace, fields.Everything())</span><br><span class="line">	<span class="comment">// 也可以选择下面这种写法</span></span><br><span class="line">	<span class="comment">// podListWatcher = &amp;cache.ListWatch&#123;</span></span><br><span class="line">	<span class="comment">// 	ListFunc: func(options metav1.ListOptions) (runtime.Object, error) &#123;</span></span><br><span class="line">	<span class="comment">// 		return c.CoreV1().Pods(namespace).List(context.TODO(), options)</span></span><br><span class="line">	<span class="comment">// 	&#125;,</span></span><br><span class="line">	<span class="comment">// 	WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) &#123;</span></span><br><span class="line">	<span class="comment">// 		return c.CoreV1().Pods(namespace).Watch(context.TODO(), options)</span></span><br><span class="line">	<span class="comment">// 	&#125;,</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	informer := cache.NewSharedIndexInformer(podListWatcher, &amp;v1.Pod&#123;&#125;, <span class="number">0</span>, cache.Indexers&#123;&#125;)</span><br><span class="line">	<span class="comment">// go informer.Run(make(chan struct&#123;&#125;)) // informer.Run本身是阻塞的，所以一般另起一个goroutine；暂时先不启动</span></span><br><span class="line">	<span class="keyword">return</span> informer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="借助工厂类"><a href="#借助工厂类" class="headerlink" title="借助工厂类"></a>借助工厂类</h4><p>这种方式更鼓励使用，client-go也为此针对每个资源写了相应的构造方法，见<a href="https://github.com/kubernetes/client-go/tree/release-1.18/informers" target="_blank" rel="noopener">informers</a></p>
<p><a href="https://github.com/pangsq/read_code_of_k8s/blob/master/tools/cache/SharedIndexInformer/example/main.go" target="_blank" rel="noopener">例子</a>如下</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createSharedIndexInformerByFactory</span><span class="params">(c *kubernetes.Clientset)</span> <span class="params">(cache.SharedIndexInformer, informers.SharedInformerFactory)</span></span> &#123;</span><br><span class="line">	factory := informers.NewSharedInformerFactoryWithOptions(c, <span class="number">0</span>, informers.WithNamespace(v1.NamespaceAll))</span><br><span class="line">	<span class="comment">// factory.Start(make(chan struct&#123;&#125;)) // factory.Start非阻塞；暂时先不启动</span></span><br><span class="line">	<span class="keyword">return</span> factory.Core().V1().Pods().Informer(), factory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EventHandler"><a href="#EventHandler" class="headerlink" title="EventHandler"></a>EventHandler</h3><p>在informer启动之前向informer注册事件句柄；启动过程中也可以添加，但一般不鼓励。</p>
<p>对于同一个SharedIndexerInformer，可以多次使用AddEventHandler，给其注册零或多组EventHandler。（猜测这就是Shared这个前缀的来历</p>
<p>假设想要打印每个pod的变化事件，代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">informer.AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">	AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		key, _ := cache.MetaNamespaceKeyFunc(obj)</span><br><span class="line">		fmt.Println(<span class="string">"add a pod "</span>, key)</span><br><span class="line">	&#125;,</span><br><span class="line">	UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old <span class="keyword">interface</span>&#123;&#125;, <span class="built_in">new</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		key, _ := cache.MetaNamespaceKeyFunc(<span class="built_in">new</span>)</span><br><span class="line">		fmt.Println(<span class="string">"update a pod "</span>, key)</span><br><span class="line">	&#125;,</span><br><span class="line">	DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		key, _ := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)</span><br><span class="line">		fmt.Println(<span class="string">"delete a pod "</span>, key)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h3><p>启动的例子代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runSharedIndexInformerByFactory</span><span class="params">(informer cache.SharedIndexInformer, factory informers.SharedInformerFactory)</span></span> &#123;</span><br><span class="line">	withEventHandler(informer)</span><br><span class="line">	ctx, _ := context.WithTimeout(context.Background(), time.Second*<span class="number">10</span>)</span><br><span class="line">	fmt.Println(<span class="string">"### Start Informer By Factory"</span>)</span><br><span class="line">	<span class="comment">// 一般情况下，例如常驻的controller-manager中的controller会传入一个永不close的channel</span></span><br><span class="line">	<span class="comment">// factory.Start会调用注册在factory中的所有informer的Run方法</span></span><br><span class="line">	factory.Start(ctx.Done())</span><br><span class="line">	<span class="comment">// 由于informer刚启动时会从apiserver拉取大量当前的资源实例状态，所以总是等待这些这些资源实例被处理完毕(EventHandler)之后，再进行具体的业务逻辑</span></span><br><span class="line">	<span class="keyword">if</span> !factory.WaitForCacheSync(ctx.Done())[reflect.TypeOf(&amp;v1.Pod&#123;&#125;)] &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"timed out waiting for caches to sync"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;-ctx.Done()</span><br><span class="line">	fmt.Println(<span class="string">"### End Informer"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再分析下SharedIndexInformer的<a href="https://sourcegraph.com/github.com/kubernetes/client-go@release-1.18/-/blob/tools/cache/shared_informer.go#L336:31&tab=def" target="_blank" rel="noopener">Run</a>方法。</p>
<p>它做了这么几件事：</p>
<ol>
<li>使用defer处理线程奔溃</li>
<li>创建一个deltaFIFO</li>
<li>通过New(c *Config)方法创建一个Controller</li>
<li>另起一个协程运行cacheMutationDetector.Run -&gt; 监控Store中对象不被修改</li>
<li>另起一个协程运行processor.run -&gt; 由资源实例的变化事件（从deltaFIFO读取）触发EventHandler，期间用到一个RingGrowing来进行缓冲</li>
<li>阻塞地运行controller.Run -&gt; 通过reflector的listerWatcher不断获取实例，放入Indexer和deltaFIFO中</li>
</ol>
<h3 id="Goroutine及函数调用链路"><a href="#Goroutine及函数调用链路" class="headerlink" title="Goroutine及函数调用链路"></a>Goroutine及函数调用链路</h3><ol>
<li>从sharedIndexInformer.Run出发，（不考虑cacheMutationDetector）有两条函数调用路径：1.负责数据的生产；2.负责数据的消费</li>
<li>函数前带go说明另起了协程（实际代码中不一定是直接使用的go关键字），带loop说明是一个循环操作，带multi说明是多次调用（例如对deltas/listeners的遍历）</li>
</ol>
<img src="/2020/05/01/sharedIndexInformer/index/trace.png" width="1000" hegiht="600" align="center">

<p>由上图可知，最终所有的资源实例对象存储在Indexer中，每次实例的变化通知到EventHandler。</p>
<h2 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h2><img src="/2020/05/01/sharedIndexInformer/index/flow.png" width="1000" hegiht="600" align="center">

<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><p>client-go还存在一个与SharedIndexInformer功能相似的组件——Controller，两者区别在于：</p>
<ol>
<li>创建Controller时调用NewIndexerInformer，产生两个返回值——Indexer和Controller，Indexer存储资源对象，Controller负责通过Reflector获取资源对象和产生通知；而SharedIndexInformer封装地更好。</li>
<li>Controller中的EventHandler有且只能有一个，在NewIndexerInformer创建Controller时就需要指定</li>
<li>SharedIndexInformer可以选择性开启MutationDetector（用于监控缓存的资源对象是否被修改。约定想要修改资源时，要先deep copy一份在新副本上修改）</li>
<li>SharedIndexInformer的实现sharedIndexInformer使用了一个Controller</li>
</ol>
<blockquote><p>同步自 <a href="https://github.com/pangsq/read_code_of_k8s/blob/master/tools/cache/SharedIndexInformer/SharedIndexInformer.md" target="_blank" rel="noopener">https://github.com/pangsq/read_code_of_k8s/blob/master/tools/cache/SharedIndexInformer/SharedIndexInformer.md</a></p>
</blockquote>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By 锋寒</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>