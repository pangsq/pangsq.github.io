<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="锋寒"><meta name="copyright" content="锋寒"><title>锋寒的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">锋寒</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">10</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">27</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">6</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">锋寒的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">锋寒的博客</div><div id="site-sub-title"></div><div id="site-social-icons"><a class="social-icon" href="https://github.com/pangsq" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-github"></i></a><a class="social-icon" href="pangsq9413@gmail.com" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-email"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/07/11/servicemesh/tracing/">使用istio的tracing功能的一个简单例子</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ServiceMesh/">ServiceMesh</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Istio/">Istio</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Tracing/">Tracing</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/OpenTelemetry/">OpenTelemetry</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Jaeger/">Jaeger</a></span><div class="content"><p>Istio内置了链路追踪的能力（调用链），依赖的是envoy能够在劫持的流量中自动注入用于构成链路的Trace信息（例如OpenZipkin的b3 propagation，在Http中的header是X-B3-xxx），并且将该信息上报给外部的Trace服务（例如LightStep/Zipkin/Jaeger/Datadog等）。</p>
<p>而为了将这种能力进化成<code>分布式</code>的链路追踪，需要程序能将入站请求中的Trace信息传递给出站请求(参考 <a href="https://istio.io/docs/tasks/telemetry/distributed-tracing/overview/#trace-context-propagation" target="_blank" rel="noopener">https://istio.io/docs/tasks/telemetry/distributed-tracing/overview/#trace-context-propagation</a> ),用户的业务代码因此需要进行修改。<br>Istio宣称的所谓的对业务代码”零侵入”是不可靠的，业务代码不进行任何更改而想享受分布式追踪的能力，除非是以下场景 </p>
<ol>
<li>程序使用了特殊的框架，能够自动从上下文中获取入站请求的Trace信息并注入到出站请求中。参考后文给的代码示例，我们将通过指导或提供我们的sdk仅可能地简化用户代码中对<code>Trace信息传递</code>这一逻辑。</li>
<li>分布式追踪退化到仅能追溯一跳请求。假设用户并不对Trace信息进行传递，那么如果有服务调用关系为<code>A-&gt;B-&gt;C</code>，最终通过调用链我们仅能查看到<code>A-&gt;B,B-&gt;C</code>。</li>
</ol>
<p>当我们构建起完整的链路追踪，我们在jaeger上得到的trace信息将如下图所示：（从中我们能获取服务间的调用关系/调用的耗时/服务内部处理的耗时/错误的源头）</p>
<p><img src="/2021/07/11/servicemesh/tracing/jaeger-example.png" alt="jaeger-example"></p>
<h2 id="Istio中Trace实现原理"><a href="#Istio中Trace实现原理" class="headerlink" title="Istio中Trace实现原理"></a>Istio中Trace实现原理</h2><p>作为Sidecar的envoy会自动生成TraceId和SpanId并向Jaeger/Zipkin等上报，可以通过下方示意图理解。</p>
<p><img src="/2021/07/11/servicemesh/tracing/trace_spans_flow.png" alt="trace_spans_flow"></p>
<ol>
<li>TraceId和第一个SpanId既可以由input的proxy生成也可以由ouput的proxy生成，也就是说调用链的第一个请求来自于网格外或网格内都可以生成Trace信息</li>
<li>Sampled=1时，envoy才会将Span上报。我们的程序在传递Trace信息时一般将Sampled信息原样传递，因此第一个请求中的Sampled尤为重要；我们通过给第一个请求主动配置相应header或通过ingressgateway访问服务时Sampled才会等于1</li>
<li>通过Span的时间戳我们可以计算网络的耗时和程序自身的耗时，以上图为例：SpanId=2的span的总耗时减SpanId=3的span的总耗时约等于服务B的耗时（我们将本地通信的耗时忽略不计）;SpanId=1的span起始时间减去SpanId=2的span的起始时间约等于服务A请求到服务B请求的网络耗时（envoy处理请求的耗时忽略不计）</li>
</ol>
<h2 id="分布式追踪示例"><a href="#分布式追踪示例" class="headerlink" title="分布式追踪示例"></a>分布式追踪示例</h2><p>在<a href="https://github.com/pangsq/tutorials/tree/main/servicemesh/tracing下" target="_blank" rel="noopener">tracing-example</a>中提供了一个简单例子，其中包含一个go的服务(go-service)和一个java的服务(java-service)，他们的逻辑相同，都是:</p>
<ol>
<li>将请求转发给预先设置的后置服务（go-service -&gt; java-service, java-service -&gt; go-service），保留path信息并传递trace信息 </li>
<li>queryParam参数中包含一个ttl值，每次转发ttl减1，当减到0时，将请求转发给httpbin</li>
</ol>
<p><img src="/2021/07/11/servicemesh/tracing/forward.png" alt="forward"></p>
<p><code>go-service</code>中用于在http request间传递Trace信息的方式是通过context.Context，生成和使用该context见<a href="https://github.com/pangsq/tutorials/blob/main/servicemesh/tracing/go-service/tracing/propagators.go" target="_blank" rel="noopener">propagators</a></p>
<p><code>java-service</code>中的方式是通过自动生成spring的scoped=request的bean,详见<a href="https://github.com/pangsq/tutorials/blob/main/servicemesh/tracing/java-service/src/main/java/com/example/restservice/TracingContext.java" target="_blank" rel="noopener">TraceContext</a>，将Span的信息存储在该bean中，这种做法能保证无论outgoing的请求生成在哪个controller或service中都能拿到相关上下文input请求中的Span信息</p>
<p>两个服务的编译方式和部署方式见各项目中的<code>README.md</code>，httpbin的部署见<a href="https://github.com/pangsq/tutorials/blob/main/servicemesh/tracing/httpbin.yaml" target="_blank" rel="noopener">httpbin.yaml</a></p>
<p>在将服务部署好后通过网关访问</p>
<p><img src="/2021/07/11/servicemesh/tracing/curl_go_service_example.png" alt="curl_go_service_example"></p>
<p>在jaeger上查看trace (通过调用链我们可以看到请求在go-service和java-service间反复横跳</p>
<p><img src="/2021/07/11/servicemesh/tracing/curl_go_service_result.png" alt="curl_go_service_result"></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref:"></a>Ref:</h2><ul>
<li><a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/observability/tracing" target="_blank" rel="noopener">envoy-tracing</a></li>
<li><a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#x-b3-traceid" target="_blank" rel="noopener">envoy-headers</a></li>
<li><a href="https://www.jaegertracing.io/docs/1.23/architecture/" target="_blank" rel="noopener">jaeger-architecture</a></li>
<li><a href="https://zhaohuabing.com/post/2019-06-22-using-opentracing-with-istio/" target="_blank" rel="noopener">洞若观火：使用OpenTracing增强Istio的调用链跟踪</a></li>
<li><a href="https://www.infoq.cn/article/pqy*pfphox9oqq9icrtt" target="_blank" rel="noopener">Istio 调用链埋点原理剖析—是否真的“零修改”？</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/08/08/istio-xds/index/">从xDS开始读懂istio的实现</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ServiceMesh/">ServiceMesh</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Istio/">Istio</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Pilot/">Pilot</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Envoy/">Envoy</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/XDS/">XDS</a></span><div class="content"><p>Istio在架构上分为控制面和数据面两个部分，控制面指的是pilot、citadel、galley等用于发送配置、对网格进行管理的组件（1.6版本之后这些组件合并成istiod组件），数据面指的是以sidecar形式部署在工作负载边上用于劫持并处理业务流量的代理（默认是envoy）。</p>
<p>通俗地可以理解为Istio由一个指挥者（istiod）和多个干活的人（envoy）组成，由指挥者向干活的人下发的命令我们称之为xDS（发现协议），或者我们将xDS视做envoy用于如何处理流量的规则。</p>
<p>在istiod侧，存在一些配置概念（作为k8s的CRD）如vitualService/destinationRule，istiod通过将它们翻译成相应的xDS，再向envoy下发；通过定义这些CRD以及k8s中存在的service，我们可以很方便地定义服务治理的路由、流量权重、熔断等等规则，但这些配置究竟如何在envoy侧生效的呢，对于我们来说往往是个黑盒。</p>
<p>这篇文章的目的在于研究istiod是如何根据控制面侧的配置生成数据面侧所需的xDS协议数据。</p>
<h2 id="pilot中概念与xDS对应关系"><a href="#pilot中概念与xDS对应关系" class="headerlink" title="pilot中概念与xDS对应关系"></a>pilot中概念与xDS对应关系</h2><p>为了直观地感受控制面配置变化对envoy的影响，本节直接通过创建不同资源的前后对比来显示不同资源转化成的xDS配置。</p>
<p>准备工作：</p>
<ol>
<li><p>安装istio 1.5.0+</p>
</li>
<li><p>kubectl label ns default istio-injection=enabled</p>
</li>
<li><p>kubectl apply -f demo.yaml # 创建一个pod，用于之后观察其sidecar envoy中的规则</p>
 <details>
 <summary>demo.yaml</summary>

 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"36000000000"</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">centos:7.2.1511</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">centos</span></span><br></pre></td></tr></table></figure>
 </details></li>
<li><p>观察目前envoy中的规则</p>
 <details>
 <summary>listeners</summary>

 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">☁  bin  .&#x2F;istioctl proxy-config listener demo</span><br><span class="line">ADDRESS            PORT      TYPE</span><br><span class="line">10.244.0.186       15020     TCP</span><br><span class="line">10.97.23.35        15443     TCP</span><br><span class="line">10.102.119.234     443       TCP</span><br><span class="line">10.102.119.234     15443     TCP</span><br><span class="line">10.96.0.10         53        TCP</span><br><span class="line">10.101.83.24       443       TCP</span><br><span class="line">10.96.0.1          443       TCP</span><br><span class="line">10.110.220.255     15011     TCP</span><br><span class="line">10.110.220.255     15012     TCP</span><br><span class="line">10.101.83.24       15012     TCP</span><br><span class="line">10.97.23.35        31400     TCP</span><br><span class="line">10.110.220.255     443       TCP</span><br><span class="line">10.97.23.35        443       TCP</span><br><span class="line">0.0.0.0            20001     TCP</span><br><span class="line">10.96.0.10         9153      TCP</span><br><span class="line">10.97.23.35        15031     TCP</span><br><span class="line">10.97.23.35        15030     TCP</span><br><span class="line">10.100.78.178      16686     TCP</span><br><span class="line">0.0.0.0            8080      TCP</span><br><span class="line">10.97.23.35        15020     TCP</span><br><span class="line">0.0.0.0            15010     TCP</span><br><span class="line">10.97.23.35        15029     TCP</span><br><span class="line">0.0.0.0            14250     TCP</span><br><span class="line">10.108.46.165      14267     TCP</span><br><span class="line">0.0.0.0            9411      TCP</span><br><span class="line">10.97.23.35        15032     TCP</span><br><span class="line">0.0.0.0            3000      TCP</span><br><span class="line">10.108.46.165      14268     TCP</span><br><span class="line">0.0.0.0            15014     TCP</span><br><span class="line">10.108.46.165      14250     TCP</span><br><span class="line">0.0.0.0            80        TCP</span><br><span class="line">0.0.0.0            9090      TCP</span><br><span class="line">0.0.0.0            15001     TCP</span><br><span class="line">0.0.0.0            15006     TCP</span><br><span class="line">0.0.0.0            15090     HTTP</span><br></pre></td></tr></table></figure>
 </details>

 <details>
 <summary>clusters</summary>

 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">☁  bin  .&#x2F;istioctl proxy-config cluster demo</span><br><span class="line">SERVICE FQDN                                                 PORT      SUBSET         DIRECTION     TYPE</span><br><span class="line">BlackHoleCluster                                             -         -              -             STATIC</span><br><span class="line">InboundPassthroughClusterIpv4                                -         -              -             ORIGINAL_DST</span><br><span class="line">PassthroughCluster                                           -         -              -             ORIGINAL_DST</span><br><span class="line">grafana.istio-system.svc.cluster.local                       3000      -              outbound      EDS</span><br><span class="line">httpbin.org                                                  80        -              outbound      STRICT_DNS</span><br><span class="line">istio-egressgateway.istio-system.svc.cluster.local           80        -              outbound      EDS</span><br><span class="line">istio-egressgateway.istio-system.svc.cluster.local           443       -              outbound      EDS</span><br><span class="line">istio-egressgateway.istio-system.svc.cluster.local           15443     -              outbound      EDS</span><br><span class="line">istio-ingressgateway.istio-system.svc.cluster.local          80        -              outbound      EDS</span><br><span class="line">istio-ingressgateway.istio-system.svc.cluster.local          443       -              outbound      EDS</span><br><span class="line">istio-ingressgateway.istio-system.svc.cluster.local          15020     -              outbound      EDS</span><br><span class="line">istio-ingressgateway.istio-system.svc.cluster.local          15029     -              outbound      EDS</span><br><span class="line">istio-ingressgateway.istio-system.svc.cluster.local          15030     -              outbound      EDS</span><br><span class="line">istio-ingressgateway.istio-system.svc.cluster.local          15031     -              outbound      EDS</span><br><span class="line">istio-ingressgateway.istio-system.svc.cluster.local          15032     -              outbound      EDS</span><br><span class="line">istio-ingressgateway.istio-system.svc.cluster.local          15443     -              outbound      EDS</span><br><span class="line">istio-ingressgateway.istio-system.svc.cluster.local          31400     -              outbound      EDS</span><br><span class="line">istio-pilot.istio-system.svc.cluster.local                   443       -              outbound      EDS</span><br><span class="line">istio-pilot.istio-system.svc.cluster.local                   8080      -              outbound      EDS</span><br><span class="line">istio-pilot.istio-system.svc.cluster.local                   15010     -              outbound      EDS</span><br><span class="line">istio-pilot.istio-system.svc.cluster.local                   15011     -              outbound      EDS</span><br><span class="line">istio-pilot.istio-system.svc.cluster.local                   15012     -              outbound      EDS</span><br><span class="line">istio-pilot.istio-system.svc.cluster.local                   15014     -              outbound      EDS</span><br><span class="line">istiod.istio-system.svc.cluster.local                        443       -              outbound      EDS</span><br><span class="line">istiod.istio-system.svc.cluster.local                        15012     -              outbound      EDS</span><br><span class="line">jaeger-collector-headless.istio-system.svc.cluster.local     14250     -              outbound      ORIGINAL_DST</span><br><span class="line">jaeger-collector.istio-system.svc.cluster.local              14250     -              outbound      EDS</span><br><span class="line">jaeger-collector.istio-system.svc.cluster.local              14267     -              outbound      EDS</span><br><span class="line">jaeger-collector.istio-system.svc.cluster.local              14268     -              outbound      EDS</span><br><span class="line">jaeger-query.istio-system.svc.cluster.local                  16686     -              outbound      EDS</span><br><span class="line">kiali.istio-system.svc.cluster.local                         20001     -              outbound      EDS</span><br><span class="line">kube-dns.kube-system.svc.cluster.local                       53        -              outbound      EDS</span><br><span class="line">kube-dns.kube-system.svc.cluster.local                       9153      -              outbound      EDS</span><br><span class="line">kubernetes.default.svc.cluster.local                         443       -              outbound      EDS</span><br><span class="line">mgmtCluster                                                  15020     mgmt-15020     inbound       STATIC</span><br><span class="line">prometheus.istio-system.svc.cluster.local                    9090      -              outbound      EDS</span><br><span class="line">prometheus_stats                                             -         -              -             STATIC</span><br><span class="line">sds-grpc                                                     -         -              -             STATIC</span><br><span class="line">tracing.istio-system.svc.cluster.local                       80        -              outbound      EDS</span><br><span class="line">xds-grpc                                                     -         -              -             STRICT_DNS</span><br><span class="line">zipkin                                                       -         -              -             STRICT_DNS</span><br><span class="line">zipkin.istio-system.svc.cluster.local                        9411      -              outbound      EDS</span><br></pre></td></tr></table></figure>
 </details>

 <details>
 <summary>routes</summary>

 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">☁  bin  .&#x2F;istioctl proxy-config route demo  </span><br><span class="line">NOTE: This output only contains routes loaded via RDS.</span><br><span class="line">NAME                                                          VIRTUAL HOSTS</span><br><span class="line">istio-ingressgateway.istio-system.svc.cluster.local:15020     1</span><br><span class="line">jaeger-collector.istio-system.svc.cluster.local:14250         1</span><br><span class="line">jaeger-collector.istio-system.svc.cluster.local:14268         1</span><br><span class="line">kube-dns.kube-system.svc.cluster.local:9153                   1</span><br><span class="line">istio-ingressgateway.istio-system.svc.cluster.local:15029     1</span><br><span class="line">istio-ingressgateway.istio-system.svc.cluster.local:15031     1</span><br><span class="line">jaeger-collector.istio-system.svc.cluster.local:14267         1</span><br><span class="line">jaeger-query.istio-system.svc.cluster.local:16686             1</span><br><span class="line">istio-ingressgateway.istio-system.svc.cluster.local:15030     1</span><br><span class="line">istio-ingressgateway.istio-system.svc.cluster.local:15032     1</span><br><span class="line">80                                                            5</span><br><span class="line">3000                                                          2</span><br><span class="line">8080                                                          2</span><br><span class="line">9090                                                          2</span><br><span class="line">9411                                                          2</span><br><span class="line">14250                                                         3</span><br><span class="line">15010                                                         2</span><br><span class="line">15014                                                         2</span><br><span class="line">20001                                                         2</span><br><span class="line">                                                            1</span><br></pre></td></tr></table></figure>
 </details>

 <details>
 <summary>endpoints</summary>

 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">☁  bin  .&#x2F;istioctl proxy-config endpoint demo</span><br><span class="line">ENDPOINT                        STATUS      OUTLIER CHECK     CLUSTER</span><br><span class="line">10.101.83.24:15012              HEALTHY     OK                xds-grpc</span><br><span class="line">10.244.0.173:8080               HEALTHY     OK                outbound|8080||istio-pilot.istio-system.svc.cluster.local</span><br><span class="line">10.244.0.173:15010              HEALTHY     OK                outbound|15010||istio-pilot.istio-system.svc.cluster.local</span><br><span class="line">10.244.0.173:15011              HEALTHY     OK                outbound|15011||istio-pilot.istio-system.svc.cluster.local</span><br><span class="line">10.244.0.173:15012              HEALTHY     OK                outbound|15012||istio-pilot.istio-system.svc.cluster.local</span><br><span class="line">10.244.0.173:15012              HEALTHY     OK                outbound|15012||istiod.istio-system.svc.cluster.local</span><br><span class="line">10.244.0.173:15014              HEALTHY     OK                outbound|15014||istio-pilot.istio-system.svc.cluster.local</span><br><span class="line">10.244.0.173:15017              HEALTHY     OK                outbound|443||istio-pilot.istio-system.svc.cluster.local</span><br><span class="line">10.244.0.173:15017              HEALTHY     OK                outbound|443||istiod.istio-system.svc.cluster.local</span><br><span class="line">10.244.0.175:3000               HEALTHY     OK                outbound|3000||grafana.istio-system.svc.cluster.local</span><br><span class="line">10.244.0.176:53                 HEALTHY     OK                outbound|53||kube-dns.kube-system.svc.cluster.local</span><br><span class="line">10.244.0.176:9153               HEALTHY     OK                outbound|9153||kube-dns.kube-system.svc.cluster.local</span><br><span class="line">10.244.0.177:53                 HEALTHY     OK                outbound|53||kube-dns.kube-system.svc.cluster.local</span><br><span class="line">10.244.0.177:9153               HEALTHY     OK                outbound|9153||kube-dns.kube-system.svc.cluster.local</span><br><span class="line">10.244.0.179:9090               HEALTHY     OK                outbound|9090||prometheus.istio-system.svc.cluster.local</span><br><span class="line">10.244.0.181:20001              HEALTHY     OK                outbound|20001||kiali.istio-system.svc.cluster.local</span><br><span class="line">10.244.0.182:9411               HEALTHY     OK                outbound|9411||zipkin.istio-system.svc.cluster.local</span><br><span class="line">10.244.0.182:14250              HEALTHY     OK                outbound|14250||jaeger-collector.istio-system.svc.cluster.local</span><br><span class="line">10.244.0.182:14267              HEALTHY     OK                outbound|14267||jaeger-collector.istio-system.svc.cluster.local</span><br><span class="line">10.244.0.182:14268              HEALTHY     OK                outbound|14268||jaeger-collector.istio-system.svc.cluster.local</span><br><span class="line">10.244.0.182:16686              HEALTHY     OK                outbound|16686||jaeger-query.istio-system.svc.cluster.local</span><br><span class="line">10.244.0.182:16686              HEALTHY     OK                outbound|80||tracing.istio-system.svc.cluster.local</span><br><span class="line">10.244.0.184:80                 HEALTHY     OK                outbound|80||istio-egressgateway.istio-system.svc.cluster.local</span><br><span class="line">10.244.0.184:443                HEALTHY     OK                outbound|443||istio-egressgateway.istio-system.svc.cluster.local</span><br><span class="line">10.244.0.184:15443              HEALTHY     OK                outbound|15443||istio-egressgateway.istio-system.svc.cluster.local</span><br><span class="line">10.97.98.215:9411               HEALTHY     OK                zipkin</span><br><span class="line">127.0.0.1:15000                 HEALTHY     OK                prometheus_stats</span><br><span class="line">127.0.0.1:15020                 HEALTHY     OK                inbound|15020|mgmt-15020|mgmtCluster</span><br><span class="line">192.168.31.176:6443             HEALTHY     OK                outbound|443||kubernetes.default.svc.cluster.local</span><br><span class="line">3.220.112.94:80                 HEALTHY     OK                outbound|80||httpbin.org</span><br><span class="line">54.236.246.173:80               HEALTHY     OK                outbound|80||httpbin.org</span><br><span class="line">unix:&#x2F;&#x2F;&#x2F;etc&#x2F;istio&#x2F;proxy&#x2F;SDS     HEALTHY     OK                sds-grpc</span><br></pre></td></tr></table></figure>
 </details>

</li>
</ol>
<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>创建的service如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">6666</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">http-app</span></span><br></pre></td></tr></table></figure>

<p>该service中端口协议为http（如果是tcp的话下面的规则有所不同）。</p>
<p>前后envoy规则对比如下：</p>
<h4 id="listeners"><a href="#listeners" class="headerlink" title="listeners"></a>listeners</h4><p>新增一条规则。这条规则的特征是接收所有端口为8888的连接，而对地址无要求；这是由于创建的service中已经指明对于该服务的代理是L7的，因此会根据host再做路由。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADDRESS            PORT      TYPE</span><br><span class="line">0.0.0.0            8888      TCP</span><br></pre></td></tr></table></figure>

<p>如果端口的协议是L4的话，那么此处ADDRESS会是service的clusterIP。</p>
<h4 id="clusters"><a href="#clusters" class="headerlink" title="clusters"></a>clusters</h4><p>新增一条规则。cluster的命名直接用了service在k8s中的fqdn。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SERVICE FQDN                                                 PORT      SUBSET         DIRECTION     TYPE</span><br><span class="line">app.default.svc.cluster.local                                8888      -              outbound      EDS</span><br></pre></td></tr></table></figure>

<h4 id="routes"><a href="#routes" class="headerlink" title="routes"></a>routes</h4><p>新增一条规则。virtualHosts个数为2是因为其中一条是通配所有domain的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                                                          VIRTUAL HOSTS</span><br><span class="line">8888                                                          2</span><br></pre></td></tr></table></figure>

<details>
<summary>route</summary>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">☁  bin  .&#x2F;istioctl proxy-config route demo --name app.default.svc.cluster.local:8888 -o json</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;8888&quot;,</span><br><span class="line">        &quot;virtualHosts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;allow_any&quot;,</span><br><span class="line">                &quot;domains&quot;: [</span><br><span class="line">                    &quot;*&quot;</span><br><span class="line">                ],</span><br><span class="line">                &quot;routes&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;match&quot;: &#123;</span><br><span class="line">                            &quot;prefix&quot;: &quot;&#x2F;&quot;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;route&quot;: &#123;</span><br><span class="line">                            &quot;cluster&quot;: &quot;PassthroughCluster&quot;,</span><br><span class="line">                            &quot;timeout&quot;: &quot;0s&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;app.default.svc.cluster.local:8888&quot;,</span><br><span class="line">                &quot;domains&quot;: [</span><br><span class="line">                    &quot;app.default.svc.cluster.local&quot;,</span><br><span class="line">                    &quot;app.default.svc.cluster.local:8888&quot;,</span><br><span class="line">                    &quot;app&quot;,</span><br><span class="line">                    &quot;app:8888&quot;,</span><br><span class="line">                    &quot;app.default.svc.cluster&quot;,</span><br><span class="line">                    &quot;app.default.svc.cluster:8888&quot;,</span><br><span class="line">                    &quot;app.default.svc&quot;,</span><br><span class="line">                    &quot;app.default.svc:8888&quot;,</span><br><span class="line">                    &quot;app.default&quot;,</span><br><span class="line">                    &quot;app.default:8888&quot;,</span><br><span class="line">                    &quot;10.105.148.44&quot;,</span><br><span class="line">                    &quot;10.105.148.44:8888&quot;</span><br><span class="line">                ],</span><br><span class="line">                &quot;routes&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;name&quot;: &quot;default&quot;,</span><br><span class="line">                        &quot;match&quot;: &#123;</span><br><span class="line">                            &quot;prefix&quot;: &quot;&#x2F;&quot;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;route&quot;: &#123;</span><br><span class="line">                            &quot;cluster&quot;: &quot;outbound|8888||app.default.svc.cluster.local&quot;,</span><br><span class="line">                            &quot;timeout&quot;: &quot;0s&quot;,</span><br><span class="line">                            &quot;retryPolicy&quot;: &#123;</span><br><span class="line">                                &quot;retryOn&quot;: &quot;connect-failure,refused-stream,unavailable,cancelled,resource-exhausted,retriable-status-codes&quot;,</span><br><span class="line">                                &quot;numRetries&quot;: 2,</span><br><span class="line">                                &quot;retryHostPredicate&quot;: [</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        &quot;name&quot;: &quot;envoy.retry_host_predicates.previous_hosts&quot;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                ],</span><br><span class="line">                                &quot;hostSelectionRetryMaxAttempts&quot;: &quot;5&quot;,</span><br><span class="line">                                &quot;retriableStatusCodes&quot;: [</span><br><span class="line">                                    503</span><br><span class="line">                                ]</span><br><span class="line">                            &#125;,</span><br><span class="line">                            &quot;maxGrpcTimeout&quot;: &quot;0s&quot;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;decorator&quot;: &#123;</span><br><span class="line">                            &quot;operation&quot;: &quot;app.default.svc.cluster.local:8888&#x2F;*&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;validateClusters&quot;: false</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</details>

<h3 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h3><p>创建的pod如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"36000000000"</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">centos:7.2.1511</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">centos</span></span><br></pre></td></tr></table></figure>

<p>envoy前后规则变化如下：</p>
<h4 id="endpoints"><a href="#endpoints" class="headerlink" title="endpoints"></a>endpoints</h4><p>新增一条规则。istio通过service的selector选到了pod，将其作为服务的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENDPOINT                        STATUS      OUTLIER CHECK     CLUSTER</span><br><span class="line">10.244.0.187:6666               HEALTHY     OK                outbound|8888||app.default.svc.cluster.local</span><br></pre></td></tr></table></figure>

<h3 id="destinationRule"><a href="#destinationRule" class="headerlink" title="destinationRule"></a>destinationRule</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.istio.io&#x2F;v1alpha3</span><br><span class="line">kind: DestinationRule</span><br><span class="line">metadata:</span><br><span class="line">  name: app</span><br><span class="line">spec:</span><br><span class="line">  host: app</span><br><span class="line">  subsets:</span><br><span class="line">  - name: v1</span><br><span class="line">    labels:</span><br><span class="line">      version: v1</span><br></pre></td></tr></table></figure>

<h4 id="clusters-1"><a href="#clusters-1" class="headerlink" title="clusters"></a>clusters</h4><p>新增一条规则。通过destinationRule将cluster拆分成多个的cluster。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SERVICE FQDN                                                 PORT      SUBSET         DIRECTION     TYPE</span><br><span class="line">app.default.svc.cluster.local                                8888      v1             outbound      EDS</span><br></pre></td></tr></table></figure>

<h3 id="virtualService"><a href="#virtualService" class="headerlink" title="virtualService"></a>virtualService</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.istio.io&#x2F;v1alpha3</span><br><span class="line">kind: VirtualService</span><br><span class="line">metadata:</span><br><span class="line">  name: app</span><br><span class="line">spec:</span><br><span class="line">  hosts:</span><br><span class="line">  - app</span><br><span class="line">  http:</span><br><span class="line">  - route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: app</span><br><span class="line">        subset: v1</span><br></pre></td></tr></table></figure>

<h4 id="routes-1"><a href="#routes-1" class="headerlink" title="routes"></a>routes</h4><p>路由规则的变化在其route的cluster变为了virtualService中指定的subset=v1的cluster。</p>
<details>
<summary>route</summary>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">☁  bin  .&#x2F;istioctl proxy-config route demo  --name 8888 -o json</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;8888&quot;,</span><br><span class="line">        &quot;virtualHosts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;allow_any&quot;,</span><br><span class="line">                &quot;domains&quot;: [</span><br><span class="line">                    &quot;*&quot;</span><br><span class="line">                ],</span><br><span class="line">                &quot;routes&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;match&quot;: &#123;</span><br><span class="line">                            &quot;prefix&quot;: &quot;&#x2F;&quot;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;route&quot;: &#123;</span><br><span class="line">                            &quot;cluster&quot;: &quot;PassthroughCluster&quot;,</span><br><span class="line">                            &quot;timeout&quot;: &quot;0s&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;app.default.svc.cluster.local:8888&quot;,</span><br><span class="line">                &quot;domains&quot;: [</span><br><span class="line">                    &quot;app.default.svc.cluster.local&quot;,</span><br><span class="line">                    &quot;app.default.svc.cluster.local:8888&quot;,</span><br><span class="line">                    &quot;app&quot;,</span><br><span class="line">                    &quot;app:8888&quot;,</span><br><span class="line">                    &quot;app.default.svc.cluster&quot;,</span><br><span class="line">                    &quot;app.default.svc.cluster:8888&quot;,</span><br><span class="line">                    &quot;app.default.svc&quot;,</span><br><span class="line">                    &quot;app.default.svc:8888&quot;,</span><br><span class="line">                    &quot;app.default&quot;,</span><br><span class="line">                    &quot;app.default:8888&quot;,</span><br><span class="line">                    &quot;10.105.148.44&quot;,</span><br><span class="line">                    &quot;10.105.148.44:8888&quot;</span><br><span class="line">                ],</span><br><span class="line">                &quot;routes&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;match&quot;: &#123;</span><br><span class="line">                            &quot;prefix&quot;: &quot;&#x2F;&quot;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;route&quot;: &#123;</span><br><span class="line">                            &quot;cluster&quot;: &quot;outbound|8888|v1|app.default.svc.cluster.local&quot;,</span><br><span class="line">                            &quot;timeout&quot;: &quot;0s&quot;,</span><br><span class="line">                            &quot;retryPolicy&quot;: &#123;</span><br><span class="line">                                &quot;retryOn&quot;: &quot;connect-failure,refused-stream,unavailable,cancelled,resource-exhausted,retriable-status-codes&quot;,</span><br><span class="line">                                &quot;numRetries&quot;: 2,</span><br><span class="line">                                &quot;retryHostPredicate&quot;: [</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        &quot;name&quot;: &quot;envoy.retry_host_predicates.previous_hosts&quot;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                ],</span><br><span class="line">                                &quot;hostSelectionRetryMaxAttempts&quot;: &quot;5&quot;,</span><br><span class="line">                                &quot;retriableStatusCodes&quot;: [</span><br><span class="line">                                    503</span><br><span class="line">                                ]</span><br><span class="line">                            &#125;,</span><br><span class="line">                            &quot;maxGrpcTimeout&quot;: &quot;0s&quot;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;metadata&quot;: &#123;</span><br><span class="line">                            &quot;filterMetadata&quot;: &#123;</span><br><span class="line">                                &quot;istio&quot;: &#123;</span><br><span class="line">                                    &quot;config&quot;: &quot;&#x2F;apis&#x2F;networking.istio.io&#x2F;v1alpha3&#x2F;namespaces&#x2F;default&#x2F;virtual-service&#x2F;app&quot;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;decorator&quot;: &#123;</span><br><span class="line">                            &quot;operation&quot;: &quot;app.default.svc.cluster.local:8888&#x2F;*&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;validateClusters&quot;: false</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</details>

<h2 id="pilot源码实现"><a href="#pilot源码实现" class="headerlink" title="pilot源码实现"></a>pilot源码实现</h2><p>istiod的主体是pilot。pilot分为pilot-discovery和pilot-agent两部分，前者集成在istiod中，后者部署在sidecar中，管理envoy的生命周期。<br>pilot-discovery会将来自kubernetes/mcp/配置文件中的配置信息转化xDS协议数据推送给envoy。</p>
<p>主要模块有3个：</p>
<ol>
<li>ServiceController：服务发现控制器，从kubernetes、serviceentry（也是k8s中的crd）中获取服务和服务实例地址(对consul的支持在1.6.x中移除)</li>
<li>ConfigController：配置管理控制器，从kubernetes、mcp、file中获取流量治理策略的配置</li>
<li>DiscoveryService：将ServiceController和ConfigController中的数据转换成xDS协议下发给envoy<ol>
<li>DiscoveryService的实现中，ConfigGenerator负责取ConfigController配置</li>
<li>EndpointShardsByService负责存放服务发现数据，由ServiceController维护</li>
<li>Generators负责生成xDS格式的数据 </li>
</ol>
</li>
</ol>
<p><img src="/2020/08/08/istio-xds/index/pilot-discovery.png" alt="pilot-discovery"></p>
<p>pilot-discovery与envoy通信建立在grpc连接上，当控制面监听到配置的变化时向envoy推送数据如下图所示：</p>
<p><img src="/2020/08/08/istio-xds/index/channel.png" alt="channel"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/07/26/volume-manager/">kubelet源码阅读 -- volumeManager</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Kubernetes/">Kubernetes</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Kubernetes/Source/">Source</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Kubernetes/">Kubernetes</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Kubelet/">Kubelet</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Volume/">Volume</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Source/">Source</a></span><div class="content"><p>volumeManager是kubelet中对volumes进行attached/mounted/unmounted/detached等操作的执行者。</p>
<p>代码版本：release-1.11   commit:901674</p>
<h2 id="volumeManager"><a href="#volumeManager" class="headerlink" title="volumeManager"></a>volumeManager</h2><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Run中启动volumeManager独立的协程</span><br><span class="line">   <span class="keyword">go</span> kl.volumeManager.Run(kl.sourcesReady, wait.NeverStop))</span><br><span class="line"><span class="number">2.</span> syncPod中阻塞等待Pod的attach和mount完成</span><br><span class="line">   <span class="keyword">if</span> !kl.podIsTerminated(pod) </span><br><span class="line">       <span class="keyword">if</span> err := kl.volumeManager.WaitForAttachAndMount(pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="comment">// record event和log error</span></span><br><span class="line">           <span class="keyword">return</span> err</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> volumeManager <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">// kube client，由DesiredStateOfWorldPopulator调用从API server获取PV和PVC</span></span><br><span class="line">   kubeClient clientset.Interface</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 用于访问各种不同volume插件</span></span><br><span class="line">   volumePluginMgr *volume.VolumePluginMgr</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 记录volumes的目标状态，如哪些volumes需要被attached，哪些pod引用volumes。</span></span><br><span class="line">   <span class="comment">// kubelet pod manager将会用到这个信息</span></span><br><span class="line">   <span class="comment">// 简称dsw</span></span><br><span class="line">   desiredStateOfWorld cache.DesiredStateOfWorld</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 记录volumes的当前状态，与desiredStateOfWorld相对应</span></span><br><span class="line">   <span class="comment">// kubelet pod manager同样会用到这个信息</span></span><br><span class="line">   <span class="comment">// 简称asw</span></span><br><span class="line">   actualStateOfWorld cache.ActualStateOfWorld</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 生成异步的attach/detach/mount/unmount操作</span></span><br><span class="line">   operationExecutor operationexecutor.OperationExecutor</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 调整actualStateOfWorld</span></span><br><span class="line">   <span class="comment">// 调谐器，通过operationExecutor的attach/detach/mount/unmount操作对volumes进行异步的周期性的调谐</span></span><br><span class="line">   <span class="comment">// 从 actualStateOfWorld 到 desiredStateOfWorld</span></span><br><span class="line">   reconciler reconciler.Reconciler</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 维护desiredStateOfWorld</span></span><br><span class="line">   <span class="comment">// 调用podManager异步地周期性地生成desiredStateOfWorld</span></span><br><span class="line">   desiredStateOfWorldPopulator populator.DesiredStateOfWorldPopulator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> VolumeManager <span class="keyword">interface</span> &#123;</span><br><span class="line">   <span class="comment">// 启动volume manager，触发所有异步的loops</span></span><br><span class="line">   Run(sourcesReady config.SourcesReady, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 同步阻塞地等待volumes被attached和mounted（从actualStateOfWorld中获取状态）</span></span><br><span class="line">   <span class="comment">// 等待时间超过podAttachAndMountTimeout时返回错误</span></span><br><span class="line">   WaitForAttachAndMount(pod *v1.Pod) error</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回Pod的已成功attached和mounted的volumes</span></span><br><span class="line">   GetMountedVolumesForPod(podName types.UniquePodName) container.VolumeMap</span><br><span class="line"></span><br><span class="line">   <span class="comment">// pv的annations中可定义pv.beta.kubernetes.io/gid以指定额外的user group id</span></span><br><span class="line">   <span class="comment">// 当pod.Spec.SecurityContext.SupplementalGroups也包含该gid时，该gid就算作pod的extraSupplementalGroups</span></span><br><span class="line">   <span class="comment">// kuberuntime在创建容器时将会用到这个信息，将用户组添加到容器中；与fsGroup搭配使用，fsGroup指定挂载volume的用户组</span></span><br><span class="line">   GetExtraSupplementalGroupsForPod(pod *v1.Pod) []<span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取正在使用的volumes。"正在使用"的标准是volume在desiredStateOfWorld中（即当volume被attached前就算作in use），直到desiredStateOfWorld和actualStateOfWorld中不再有这个volume或者被unmounted</span></span><br><span class="line">   GetVolumesInUse() []v1.UniqueVolumeName</span><br><span class="line"></span><br><span class="line">   <span class="comment">// kubelet启动后初始的actual states被全部同步完成</span></span><br><span class="line">   ReconcilerStatesHasBeenSynced() <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// volume是否被attached</span></span><br><span class="line">   VolumeIsAttached(volumeName v1.UniqueVolumeName) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将dsw记录的volumes标记为in use</span></span><br><span class="line">   MarkVolumesAsReportedInUse(volumesReportedAsInUse []v1.UniqueVolumeName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p>volumeManager的启动会带起desiredStateOfWorldPopulator.Run和reconciler.Run两个协程</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// kubelet的配置来源有三种：file/http/apiserver；传入的sourcesReady可以用于判断三种来源是否都已ready</span></span><br><span class="line"><span class="keyword">go</span> vm.desiredStateOfWorldPopulator.Run(sourcesReady, stopCh)</span><br><span class="line"><span class="keyword">go</span> vm.reconciler.Run(stopCh)</span><br></pre></td></tr></table></figure>

<h2 id="desiredStateOfWorld"><a href="#desiredStateOfWorld" class="headerlink" title="desiredStateOfWorld"></a>desiredStateOfWorld</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> desiredStateOfWorld <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">// dsw核心就是此map，用于记录每个volume被哪些pod使用</span></span><br><span class="line">   volumesToMount <span class="keyword">map</span>[v1.UniqueVolumeName]volumeToMount</span><br><span class="line">   <span class="comment">// 维护已知的volumePlugin。用于区分volume是否是attachable的，影响UniqueVolumeName的生成</span></span><br><span class="line">   <span class="comment">// attachable的volumeName格式为&#123;pluginName&#125;/&#123;volumePlugin.GetVolumeName(volumeName)&#125;，而非attachable的volumeName格式为&#123;pluginName&#125;/&#123;podName&#125;-&#123;volumeSpec.Name&#125;</span></span><br><span class="line">   <span class="comment">// 例如对于csiPlugin来说，最终的volumeName为kubernetes.io/csi/&#123;csi.Driver&#125;^&#123;csi.VolumeHandle&#125;</span></span><br><span class="line">   volumePluginMgr *volume.VolumePluginMgr</span><br><span class="line">   sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> volumeToMount <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">// volumeName</span></span><br><span class="line">   volumeName v1.UniqueVolumeName</span><br><span class="line">   <span class="comment">// 使用该volume的pods</span></span><br><span class="line">   podsToMount <span class="keyword">map</span>[types.UniquePodName]podToMount</span><br><span class="line">   <span class="comment">// volume是否是attachable的</span></span><br><span class="line">   pluginIsAttachable <span class="keyword">bool</span></span><br><span class="line">   <span class="comment">// volume的gid，从annotation中获取</span></span><br><span class="line">   volumeGidValue <span class="keyword">string</span></span><br><span class="line">   <span class="comment">// node.Status.VolumesInUse是否已包含本volume</span></span><br><span class="line">   reportedInUse <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="actualStateOfWorld"><a href="#actualStateOfWorld" class="headerlink" title="actualStateOfWorld"></a>actualStateOfWorld</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> actualStateOfWorld <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">// 节点名</span></span><br><span class="line">   nodeName types.NodeName</span><br><span class="line">   <span class="comment">// 记录attached的volume</span></span><br><span class="line">   attachedVolumes <span class="keyword">map</span>[v1.UniqueVolumeName]attachedVolume</span><br><span class="line">   <span class="comment">// 维护所有volumePlugin</span></span><br><span class="line">   volumePluginMgr *volume.VolumePluginMgr</span><br><span class="line">   </span><br><span class="line">   sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> attachedVolume <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">// volumeName</span></span><br><span class="line">   volumeName v1.UniqueVolumeName</span><br><span class="line">   <span class="comment">// 已成功mount的pod</span></span><br><span class="line">   mountedPods <span class="keyword">map</span>[volumetypes.UniquePodName]mountedPod</span><br><span class="line">   <span class="comment">// volume spec，unmount会用到以下的路径</span></span><br><span class="line">   <span class="comment">// /var/lib/kubelet/pods/&#123;podUID&#125;/volumes/&#123;escapeQualifiedPluginName&#125;/&#123;volumeSpecName&#125;/</span></span><br><span class="line">   spec *volume.Spec</span><br><span class="line">   <span class="comment">// pluginName</span></span><br><span class="line">   pluginName <span class="keyword">string</span></span><br><span class="line">   <span class="comment">// pluginIsAttachable</span></span><br><span class="line">   pluginIsAttachable <span class="keyword">bool</span></span><br><span class="line">   <span class="comment">// volume是否被挂载在一个公共的mount path目录底下</span></span><br><span class="line">   globallyMounted <span class="keyword">bool</span></span><br><span class="line">   <span class="comment">// volume attach的路径</span></span><br><span class="line">   devicePath <span class="keyword">string</span></span><br><span class="line">   <span class="comment">// 块设备被挂载的路径</span></span><br><span class="line">   deviceMountPath <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="desiredStateOfWorldPopulator"><a href="#desiredStateOfWorldPopulator" class="headerlink" title="desiredStateOfWorldPopulator"></a>desiredStateOfWorldPopulator</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dswp *desiredStateOfWorldPopulator)</span> <span class="title">Run</span><span class="params">(sourcesReady config.SourcesReady, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 周期性地执行populaterLoopFunc;hasAddedPods状态信息是reconciler将会用到</span></span><br><span class="line">   <span class="comment">// 而对于populaterLoopFunc本身，无论sources是否AllReady都不影响运行</span></span><br><span class="line">   wait.PollUntil(dswp.loopSleepDuration, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">      done := sourcesReady.AllReady()</span><br><span class="line">      dswp.populatorLoopFunc()()</span><br><span class="line">      <span class="keyword">return</span> done, <span class="literal">nil</span></span><br><span class="line">   &#125;, stopCh)</span><br><span class="line">   dswp.hasAddedPodsLock.Lock()</span><br><span class="line">   dswp.hasAddedPods = <span class="literal">true</span></span><br><span class="line">   dswp.hasAddedPodsLock.Unlock()</span><br><span class="line">   wait.Until(dswp.populatorLoopFunc(), dswp.loopSleepDuration, stopCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dswp *desiredStateOfWorldPopulator)</span> <span class="title">populatorLoopFunc</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      dswp.findAndAddNewPods()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// findAndRemoveDeletedPods()是一个非常耗时的操作，所以通过设置调用间隔以限制调用速率</span></span><br><span class="line">      <span class="keyword">if</span> time.Since(dswp.timeOfLastGetPodStatus) &lt; dswp.getPodStatusRetryDuration &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      dswp.findAndRemoveDeletedPods()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dswp *desiredStateOfWorldPopulator)</span> <span class="title">findAndAddNewPods</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// Map unique pod name to outer volume name to MountedVolume.</span></span><br><span class="line">   mountedVolumesForPod := <span class="built_in">make</span>(<span class="keyword">map</span>[volumetypes.UniquePodName]<span class="keyword">map</span>[<span class="keyword">string</span>]cache.MountedVolume)</span><br><span class="line">   <span class="comment">// 如果开启了实时扩容功能，那么正在被使用中的pod volume，其容量会发生变化，所以先将asw中的moutedVolumes记录下来，具体用处下文分析</span></span><br><span class="line">   <span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.ExpandInUsePersistentVolumes) &#123;</span><br><span class="line">      <span class="keyword">for</span> _, mountedVolume := <span class="keyword">range</span> dswp.actualStateOfWorld.GetMountedVolumes() &#123;</span><br><span class="line">         mountedVolumes, exist := mountedVolumesForPod[mountedVolume.PodName]</span><br><span class="line">         <span class="keyword">if</span> !exist &#123;</span><br><span class="line">            mountedVolumes = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]cache.MountedVolume)</span><br><span class="line">            mountedVolumesForPod[mountedVolume.PodName] = mountedVolumes</span><br><span class="line">         &#125;</span><br><span class="line">         mountedVolumes[mountedVolume.OuterVolumeSpecName] = mountedVolume</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 记录有resize过的volumes，因为一个volume的resize只要执行一次即可</span></span><br><span class="line">   <span class="comment">// 如果多个pod都使用同一个volume，为了避免多次执行，所以记录下volume</span></span><br><span class="line">   processedVolumesForFSResize := sets.NewString()</span><br><span class="line">   <span class="comment">// kubelet的多个组件都会用到podManager，podManager维护节点上的pods</span></span><br><span class="line">   <span class="keyword">for</span> _, pod := <span class="keyword">range</span> dswp.podManager.GetPods() &#123;</span><br><span class="line">      <span class="keyword">if</span> dswp.isPodTerminated(pod) &#123;</span><br><span class="line">         <span class="comment">// Do not (re)add volumes for terminated pods</span></span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      dswp.processPodVolumes(pod, mountedVolumesForPod, processedVolumesForFSResize)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dswp *desiredStateOfWorldPopulator)</span> <span class="title">processPodVolumes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   pod *v1.Pod,</span></span></span><br><span class="line"><span class="function"><span class="params">   mountedVolumesForPod <span class="keyword">map</span>[volumetypes.UniquePodName]<span class="keyword">map</span>[<span class="keyword">string</span>]cache.MountedVolume,</span></span></span><br><span class="line"><span class="function"><span class="params">   processedVolumesForFSResize sets.String)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> pod == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   uniquePodName := util.GetUniquePodName(pod)</span><br><span class="line">   <span class="comment">// 已经处理过的pod不再处理；已处理过的pod会记录在dswp.pods.processedPods中</span></span><br><span class="line">   <span class="keyword">if</span> dswp.podPreviouslyProcessed(uniquePodName) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   allVolumesAdded := <span class="literal">true</span></span><br><span class="line">   <span class="comment">// 生成两个volumeMap，分别对应普通的挂载卷和块设备</span></span><br><span class="line">   mountsMap, devicesMap := dswp.makeVolumeMap(pod.Spec.Containers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Process volume spec for each volume defined in pod</span></span><br><span class="line">   <span class="keyword">for</span> _, podVolume := <span class="keyword">range</span> pod.Spec.Volumes &#123;</span><br><span class="line">       <span class="comment">// 如果podVolume是pvc类型的，则根据pvc名字找到与其bound的pv，获取pv信息</span></span><br><span class="line">      pvc, volumeSpec, volumeGidValue, err :=</span><br><span class="line">         dswp.createVolumeSpec(podVolume, pod.Name, pod.Namespace, mountsMap, devicesMap)</span><br><span class="line">      <span class="comment">// error handle</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将volume信息记录在dsw中</span></span><br><span class="line">      _, err = dswp.desiredStateOfWorld.AddPodToVolume(</span><br><span class="line">         uniquePodName, pod, volumeSpec, podVolume.Name, volumeGidValue)</span><br><span class="line">      <span class="comment">// error handle</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 如果开启volume扩容功能，那么会通过pvc.Status.Capacity[v1.ResourceStorage]和pvc.Spec.Capacity[v1.ResourceStorage]进行比较，</span></span><br><span class="line">      <span class="comment">// 来判断是否执行dswp.actualStateOfWorld.MarkFSResizeRequired</span></span><br><span class="line">      <span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.ExpandInUsePersistentVolumes) &#123;</span><br><span class="line">         dswp.checkVolumeFSResize(pod, podVolume, pvc, volumeSpec,</span><br><span class="line">            uniquePodName, mountedVolumesForPod, processedVolumesForFSResize)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// some of the volume additions may have failed, should not mark this pod as fully processed</span></span><br><span class="line">   <span class="keyword">if</span> allVolumesAdded &#123;</span><br><span class="line">       <span class="comment">// 记录过已处理过的pod，即放入dswp.pods.processedPods中</span></span><br><span class="line">      dswp.markPodProcessed(uniquePodName)</span><br><span class="line">      <span class="comment">// 当所有pod的所有volume添加后，个别类型volume可能需要remount，例如DownwardAPI</span></span><br><span class="line">      dswp.actualStateOfWorld.MarkRemountRequired(uniquePodName)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dswp *desiredStateOfWorldPopulator)</span> <span class="title">findAndRemoveDeletedPods</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> runningPods []*kubecontainer.Pod</span><br><span class="line"></span><br><span class="line">   runningPodsFetched := <span class="literal">false</span></span><br><span class="line">   <span class="comment">// 从dsw中获取所有volumes，</span></span><br><span class="line">   <span class="keyword">for</span> _, volumeToMount := <span class="keyword">range</span> dswp.desiredStateOfWorld.GetVolumesToMount() &#123;</span><br><span class="line">      pod, podExists := dswp.podManager.GetPodByUID(volumeToMount.Pod.UID)</span><br><span class="line">      <span class="keyword">if</span> podExists &#123;</span><br><span class="line">         <span class="comment">// Skip running pods</span></span><br><span class="line">         <span class="keyword">if</span> !dswp.isPodTerminated(pod) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> dswp.keepTerminatedPodVolumes &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 一次findAndRemoveDeletedPods中只执行一次dswp.kubeContainerRuntime.GetPods</span></span><br><span class="line">      <span class="keyword">if</span> !runningPodsFetched &#123;</span><br><span class="line">         <span class="keyword">var</span> getPodsErr error</span><br><span class="line">         runningPods, getPodsErr = dswp.kubeContainerRuntime.GetPods(<span class="literal">false</span>)</span><br><span class="line">         <span class="comment">// handle error</span></span><br><span class="line"></span><br><span class="line">         runningPodsFetched = <span class="literal">true</span></span><br><span class="line">         dswp.timeOfLastGetPodStatus = time.Now()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      runningContainers := <span class="literal">false</span></span><br><span class="line">      <span class="comment">// 检查volume对应的pod是否存在，且其包含的container是否存在</span></span><br><span class="line">      <span class="keyword">for</span> _, runningPod := <span class="keyword">range</span> runningPods &#123;</span><br><span class="line">         <span class="keyword">if</span> runningPod.ID == volumeToMount.Pod.UID &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(runningPod.Containers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">               runningContainers = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> runningContainers &#123;</span><br><span class="line">        <span class="comment">// 如果相关的（即使用了该volume的pod包含的）containers还存在，则暂时不从volumeManager中将其移除</span></span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> !dswp.actualStateOfWorld.VolumeExists(volumeToMount.VolumeName) &amp;&amp; podExists &#123;</span><br><span class="line">         <span class="comment">// 如果asw中不包含该volume了，且pod还存在</span></span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// dsw记录了volume和pod信息，即volume被使用在哪些pod中</span></span><br><span class="line">      <span class="comment">// 此方法在volume下移除pod信息，如果一个volume不被任何pod使用，则该volume也需要被删除</span></span><br><span class="line">      dswp.desiredStateOfWorld.DeletePodFromVolume(</span><br><span class="line">         volumeToMount.PodName, volumeToMount.VolumeName)</span><br><span class="line">         <span class="comment">//从dswp.pods.processedPods中移除</span></span><br><span class="line">      dswp.deleteProcessedPod(volumeToMount.PodName)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 输入信息：</span><br><span class="line">a) 处理的对象是podManager.GetPods()</span><br><span class="line">b) actualStateOfWorld.GetMountedVolumes()，获取asw中已挂载的volume，用于resize处理</span><br><span class="line">c) desiredStateOfWorld.GetVolumesToMount()，获取dsw中记录的volumeMount，即volume被哪个pod挂载信息，以便之后处理pod已不存在的情况下删除volumeToMount信息</span><br><span class="line">d) podManager.GetPodByUID(...)，用于检查pod是否还存在</span><br><span class="line"></span><br><span class="line">2. 输出操作：对新增的pod执行abc,对删除的pod执行d</span><br><span class="line">a) 通过desiredStateOfWorld.AddPodToVolume(...)将pod的volume信息记录在dsw中（每个pod只处理一次)</span><br><span class="line">b) 调用actualStateOfWorld.MarkFSResizeRequired(...)将需要扩容调整的volume做标记</span><br><span class="line">c) 调用actualStateOfWorld.MarkRemountRequired(...)对需要remount的volume进行remount</span><br><span class="line">d) 调用desiredStateOfWorld.DeletePodFromVolume(...)将pod的volume信息从dsw中删除</span><br></pre></td></tr></table></figure>

<h2 id="reconciler"><a href="#reconciler" class="headerlink" title="reconciler"></a>reconciler</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rc *reconciler)</span> <span class="title">Run</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   wait.Until(rc.reconciliationLoopFunc(), rc.loopSleepDuration, stopCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rc *reconciler)</span> <span class="title">reconciliationLoopFunc</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="comment">// 主要调谐方法，接下来重点分析</span></span><br><span class="line">       <span class="comment">// 按照顺序，对有需要的volume进行1) unmounted 2) attached/mounted 3) detached/unmounted</span></span><br><span class="line">      rc.reconcile()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> rc.populatorHasAddedPods() &amp;&amp; !rc.StatesHasBeenSynced() &#123;</span><br><span class="line">         glog.Infof(<span class="string">"Reconciler: start to sync state"</span>)</span><br><span class="line">         <span class="comment">// 通过遍历所有pods的volume目录，观察到当前节点上的真实情况，与dsw和asw做比较，已处理不一致的情况(kubelet重启时会遗留mounted volumes)</span></span><br><span class="line">         rc.sync()</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rc *reconciler)</span> <span class="title">reconcile</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 确保应该unmounted的volumes是unmounted的</span></span><br><span class="line">   <span class="keyword">for</span> _, mountedVolume := <span class="keyword">range</span> rc.actualStateOfWorld.GetMountedVolumes() &#123;</span><br><span class="line">      <span class="keyword">if</span> !rc.desiredStateOfWorld.PodExistsInVolume(mountedVolume.PodName, mountedVolume.VolumeName) &#123;</span><br><span class="line">         err := rc.operationExecutor.UnmountVolume(</span><br><span class="line">            mountedVolume.MountedVolume, rc.actualStateOfWorld, rc.kubeletPodsDir)</span><br><span class="line">         <span class="comment">// handle error</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 确保应该attached/mounted的volumes是attached的</span></span><br><span class="line">   <span class="keyword">for</span> _, volumeToMount := <span class="keyword">range</span> rc.desiredStateOfWorld.GetVolumesToMount() &#123;</span><br><span class="line">      volMounted, devicePath, err := rc.actualStateOfWorld.PodExistsInVolume(volumeToMount.PodName, volumeToMount.VolumeName)</span><br><span class="line">      volumeToMount.DevicePath = devicePath</span><br><span class="line">      <span class="keyword">if</span> cache.IsVolumeNotAttachedError(err) &#123;</span><br><span class="line">         <span class="keyword">if</span> rc.controllerAttachDetachEnabled || !volumeToMount.PluginIsAttachable &#123;</span><br><span class="line">            <span class="comment">// 如果controllerAttachDetachEnabled(即由controller-manager做attach操作)或volumePlugin不是attachable的，则等待volume被attach</span></span><br><span class="line">            err := rc.operationExecutor.VerifyControllerAttachedVolume(</span><br><span class="line">               volumeToMount.VolumeToMount,</span><br><span class="line">               rc.nodeName,</span><br><span class="line">               rc.actualStateOfWorld)</span><br><span class="line">            <span class="comment">// handle error</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在kubelet内部对其attach</span></span><br><span class="line">            volumeToAttach := operationexecutor.VolumeToAttach&#123;</span><br><span class="line">               VolumeName: volumeToMount.VolumeName,</span><br><span class="line">               VolumeSpec: volumeToMount.VolumeSpec,</span><br><span class="line">               NodeName:   rc.nodeName,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            err := rc.operationExecutor.AttachVolume(volumeToAttach, rc.actualStateOfWorld)</span><br><span class="line">            <span class="comment">// handle error</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> !volMounted || cache.IsRemountRequiredError(err) &#123;</span><br><span class="line">         <span class="comment">// Volume is not mounted, or is already mounted, but requires remounting</span></span><br><span class="line">         remountingLogStr := <span class="string">""</span></span><br><span class="line">         isRemount := cache.IsRemountRequiredError(err)</span><br><span class="line">         err := rc.operationExecutor.MountVolume(</span><br><span class="line">            rc.waitForAttachTimeout,</span><br><span class="line">            volumeToMount.VolumeToMount,</span><br><span class="line">            rc.actualStateOfWorld,</span><br><span class="line">            isRemount)</span><br><span class="line">         <span class="comment">// handle error</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> cache.IsFSResizeRequiredError(err) &amp;&amp;</span><br><span class="line">         utilfeature.DefaultFeatureGate.Enabled(features.ExpandInUsePersistentVolumes) &#123;</span><br><span class="line">         glog.V(<span class="number">4</span>).Infof(volumeToMount.GenerateMsgDetailed(<span class="string">"Starting operationExecutor.ExpandVolumeFSWithoutUnmounting"</span>, <span class="string">""</span>))</span><br><span class="line">         err := rc.operationExecutor.ExpandVolumeFSWithoutUnmounting(</span><br><span class="line">            volumeToMount.VolumeToMount,</span><br><span class="line">            rc.actualStateOfWorld)</span><br><span class="line">         <span class="comment">// handle error</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 确保detached/unmounted的volume是detached/unmounted的</span></span><br><span class="line">   <span class="keyword">for</span> _, attachedVolume := <span class="keyword">range</span> rc.actualStateOfWorld.GetUnmountedVolumes() &#123;</span><br><span class="line">      <span class="keyword">if</span> !rc.desiredStateOfWorld.VolumeExists(attachedVolume.VolumeName) &amp;&amp;</span><br><span class="line">         !rc.operationExecutor.IsOperationPending(attachedVolume.VolumeName, nestedpendingoperations.EmptyUniquePodName) &#123;</span><br><span class="line">         <span class="keyword">if</span> attachedVolume.GloballyMounted &#123;</span><br><span class="line">            err := rc.operationExecutor.UnmountDevice(</span><br><span class="line">               attachedVolume.AttachedVolume, rc.actualStateOfWorld, rc.mounter)</span><br><span class="line">            <span class="comment">// handle error</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 由controller-manager进行detach或者不需要dettach</span></span><br><span class="line">            <span class="keyword">if</span> rc.controllerAttachDetachEnabled || !attachedVolume.PluginIsAttachable &#123;</span><br><span class="line">                <span class="comment">// 直接从asw.attachedVolumes中删除</span></span><br><span class="line">               rc.actualStateOfWorld.MarkVolumeAsDetached(attachedVolume.VolumeName, attachedVolume.NodeName)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 由kubelet内部进行detach</span></span><br><span class="line">               err := rc.operationExecutor.DetachVolume(</span><br><span class="line">                  attachedVolume.AttachedVolume, <span class="literal">false</span> <span class="comment">/* verifySafeToDetach */</span>, rc.actualStateOfWorld)</span><br><span class="line">               <span class="comment">// handle error</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rc *reconciler)</span> <span class="title">sync</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> rc.updateLastSyncTime()</span><br><span class="line">   rc.syncStates()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rc *reconciler)</span> <span class="title">syncStates</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 遍历podsDir获取真实的volume挂载情况</span></span><br><span class="line">   podVolumes, err := getVolumesFromPodDir(rc.kubeletPodsDir)</span><br><span class="line">   <span class="comment">// handle error</span></span><br><span class="line">   volumesNeedUpdate := <span class="built_in">make</span>(<span class="keyword">map</span>[v1.UniqueVolumeName]*reconstructedVolume)</span><br><span class="line">   volumeNeedReport := []v1.UniqueVolumeName&#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> _, volume := <span class="keyword">range</span> podVolumes &#123;</span><br><span class="line">      <span class="keyword">if</span> rc.actualStateOfWorld.VolumeExistsWithSpecName(volume.podName, volume.volumeSpecName) &#123;</span><br><span class="line">         <span class="comment">// 与asw一致则不做任何处理</span></span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      volumeInDSW := rc.desiredStateOfWorld.VolumeExistsWithSpecName(volume.podName, volume.volumeSpecName)</span><br><span class="line">      <span class="comment">// 重建volume，调用rc.operationExecutor.ReconstructVolumeOperation</span></span><br><span class="line">      reconstructedVolume, err := rc.reconstructVolume(volume)</span><br><span class="line">      <span class="comment">// handle error</span></span><br><span class="line">      <span class="keyword">if</span> volumeInDSW &#123;</span><br><span class="line">         <span class="comment">// 如果在dsw中包含该volume，则需要将该volume上报为in use</span></span><br><span class="line">         volumeNeedReport = <span class="built_in">append</span>(volumeNeedReport, reconstructedVolume.volumeName)</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新volume</span></span><br><span class="line">      volumesNeedUpdate[reconstructedVolume.volumeName] = reconstructedVolume</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(volumesNeedUpdate) &gt; <span class="number">0</span> &#123;</span><br><span class="line">       <span class="comment">// 更新volumes状态。从node.Status.VolumesAttached中获取devicePath，并调用actualStateOfWorld.MarkVolumeAsAttached/actualStateOfWorld.MarkVolumeAsMounted/actualStateOfWorld.MarkDeviceAsMounted</span></span><br><span class="line">      <span class="keyword">if</span> err = rc.updateStates(volumesNeedUpdate); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         glog.Errorf(<span class="string">"Error occurred during reconstruct volume from disk: %v"</span>, err)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(volumeNeedReport) &gt; <span class="number">0</span> &#123;</span><br><span class="line">       <span class="comment">// 将volume标记为in use</span></span><br><span class="line">      rc.desiredStateOfWorld.MarkVolumesReportedInUse(volumeNeedReport)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. reconcile进行如下调谐</span><br><span class="line">a) 对asw中存在但dsw中不存在的volume，调用operationExecutor.UnmountVolume</span><br><span class="line">b) 对dsw中存在的volume，如果asw表明该volume未attach则调用operationExecutor.AttachVolume，</span><br><span class="line">    如果asw表明该volume为unmounted或者remountRequired则调用operationExecutor.MountVolume，</span><br><span class="line">    如果asw表明该volume为resizeRequired则调用operationExecutor.ExpandVolumeFSWithoutUnmounting</span><br><span class="line">c) 对asw中的unmountedVolumes(即没有pod使用的volume)进行清理，调用operationExecutor.UnmountDevice或MarkVolumeAsDetached或operationExecutor.DetachVolume</span><br><span class="line"></span><br><span class="line">2. sync进行如下调谐</span><br><span class="line">a) 如果真实的mount信息与asw不符，则调用operationExecutor.ReconstructVolumeOperation根据遍历podsDir得到的信息对podVolume进行重建</span><br><span class="line">b) 将确实的volume信息加入到asw中，并标记dsw中相应的volume为in use</span><br></pre></td></tr></table></figure>

<h2 id="operationExecutor"><a href="#operationExecutor" class="headerlink" title="operationExecutor"></a>operationExecutor</h2><p>只记下最为关键的MountVolume操作</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(oe *operationExecutor)</span> <span class="title">MountVolume</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   waitForAttachTimeout time.Duration,</span></span></span><br><span class="line"><span class="function"><span class="params">   volumeToMount VolumeToMount,</span></span></span><br><span class="line"><span class="function"><span class="params">   actualStateOfWorld ActualStateOfWorldMounterUpdater,</span></span></span><br><span class="line"><span class="function"><span class="params">   isRemount <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">if</span> fsVolume &#123;</span><br><span class="line">      <span class="comment">// filesystem情况</span></span><br><span class="line">      generatedOperations, err = oe.operationGenerator.GenerateMountVolumeFunc(</span><br><span class="line">         waitForAttachTimeout, volumeToMount, actualStateOfWorld, isRemount)</span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 块设备情况</span></span><br><span class="line">      generatedOperations, err = oe.operationGenerator.GenerateMapVolumeFunc(</span><br><span class="line">         waitForAttachTimeout, volumeToMount, actualStateOfWorld)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 执行mount</span></span><br><span class="line">   <span class="keyword">return</span> oe.pendingOperations.Run(</span><br><span class="line">      volumeToMount.VolumeName, podName, generatedOperations)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(og *operationGenerator)</span> <span class="title">GenerateMountVolumeFunc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   waitForAttachTimeout time.Duration,</span></span></span><br><span class="line"><span class="function"><span class="params">   volumeToMount VolumeToMount,</span></span></span><br><span class="line"><span class="function"><span class="params">   actualStateOfWorld ActualStateOfWorldMounterUpdater,</span></span></span><br><span class="line"><span class="function"><span class="params">   isRemount <span class="keyword">bool</span>)</span> <span class="params">(volumetypes.GeneratedOperations, error)</span></span> &#123;</span><br><span class="line">   <span class="comment">// Get mounter plugin</span></span><br><span class="line">   volumePlugin, err :=</span><br><span class="line">      og.volumePluginMgr.FindPluginBySpec(volumeToMount.VolumeSpec)</span><br><span class="line">   <span class="comment">// handle error</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查nodeAffinity是否匹配</span></span><br><span class="line">   affinityErr := checkNodeAffinity(og, volumeToMount, volumePlugin)</span><br><span class="line">   <span class="comment">// handle error</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 调用volume插件的NewMounter生成具体的mounter工具</span></span><br><span class="line">   volumeMounter, newMounterErr := volumePlugin.NewMounter(</span><br><span class="line">      volumeToMount.VolumeSpec,</span><br><span class="line">      volumeToMount.Pod,</span><br><span class="line">      volume.VolumeOptions&#123;&#125;)</span><br><span class="line">   <span class="comment">// handle error</span></span><br><span class="line">   <span class="comment">// 检查mount配置项是否支持</span></span><br><span class="line">   mountCheckError := checkMountOptionSupport(og, volumeToMount, volumePlugin)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// handl error</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取attacher</span></span><br><span class="line">   attachableVolumePlugin, _ :=</span><br><span class="line">      og.volumePluginMgr.FindAttachablePluginBySpec(volumeToMount.VolumeSpec)</span><br><span class="line">   <span class="keyword">var</span> volumeAttacher volume.Attacher</span><br><span class="line">   <span class="keyword">if</span> attachableVolumePlugin != <span class="literal">nil</span> &#123;</span><br><span class="line">      volumeAttacher, _ = attachableVolumePlugin.NewAttacher()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 挂载路径用户组</span></span><br><span class="line">   <span class="keyword">var</span> fsGroup *<span class="keyword">int64</span></span><br><span class="line">   <span class="keyword">if</span> volumeToMount.Pod.Spec.SecurityContext != <span class="literal">nil</span> &amp;&amp;</span><br><span class="line">      volumeToMount.Pod.Spec.SecurityContext.FSGroup != <span class="literal">nil</span> &#123;</span><br><span class="line">      fsGroup = volumeToMount.Pod.Spec.SecurityContext.FSGroup</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 具体的挂载方法</span></span><br><span class="line">   mountVolumeFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(error, error)</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> volumeAttacher != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="comment">// 调用volumeAttacher，等待volume被attach</span></span><br><span class="line">         <span class="comment">// 对于csi来说，controller-manager的attachDetachController会调用csi的attacher生成volumeAttachment和更新ode.Status.VolumesAttached状态，然后由external-attacher进行attach操作并修改volumeAttachment</span></span><br><span class="line">         <span class="comment">// 之后由kubelet在此处等待attach（即监听volumeAttachment）。v1.11版本中此处存在bug，某些情况下kubelet会尝试获取错误的volumeAttachment，是由于其将node.Status.VolumesAttached中的devicePath作为volumeAttachment名了</span></span><br><span class="line">         devicePath, err := volumeAttacher.WaitForAttach(</span><br><span class="line">            volumeToMount.VolumeSpec, volumeToMount.DevicePath, volumeToMount.Pod, waitForAttachTimeout)</span><br><span class="line">         <span class="comment">// handle error</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 将</span></span><br><span class="line">         deviceMountPath, err :=</span><br><span class="line">            volumeAttacher.GetDeviceMountPath(volumeToMount.VolumeSpec)</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Mount device to global mount path</span></span><br><span class="line">         err = volumeAttacher.MountDevice(</span><br><span class="line">            volumeToMount.VolumeSpec,</span><br><span class="line">            devicePath,</span><br><span class="line">            deviceMountPath)</span><br><span class="line">         <span class="comment">// handle error</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 记录device已mount</span></span><br><span class="line">         markDeviceMountedErr := actualStateOfWorld.MarkDeviceAsMounted(</span><br><span class="line">            volumeToMount.VolumeName, devicePath, deviceMountPath)</span><br><span class="line">            <span class="comment">// handle error</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// resize挂载卷</span></span><br><span class="line">         resizeSimpleError, resizeDetailedError := og.resizeFileSystem(volumeToMount, devicePath, deviceMountPath, volumePlugin.GetPluginName())</span><br><span class="line">         <span class="comment">// handle error</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> og.checkNodeCapabilitiesBeforeMount &#123;</span><br><span class="line">         <span class="comment">// 检查是否可以mount</span></span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行mount操作</span></span><br><span class="line">      mountErr := volumeMounter.SetUp(fsGroup)</span><br><span class="line">      <span class="comment">// handle error</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 更新asw</span></span><br><span class="line">      markVolMountedErr := actualStateOfWorld.MarkVolumeAsMounted(</span><br><span class="line">         volumeToMount.PodName,</span><br><span class="line">         volumeToMount.Pod.UID,</span><br><span class="line">         volumeToMount.VolumeName,</span><br><span class="line">         volumeMounter,</span><br><span class="line">         <span class="literal">nil</span>,</span><br><span class="line">         volumeToMount.OuterVolumeSpecName,</span><br><span class="line">         volumeToMount.VolumeGidValue,</span><br><span class="line">         volumeToMount.VolumeSpec)</span><br><span class="line">      <span class="comment">// handle error</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   eventRecorderFunc := <span class="comment">// event记录方法</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> volumetypes.GeneratedOperations&#123;</span><br><span class="line">      OperationFunc:     mountVolumeFunc,</span><br><span class="line">      EventRecorderFunc: eventRecorderFunc,</span><br><span class="line">      CompleteFunc:      util.OperationCompleteHook(volumePlugin.GetPluginName(), <span class="string">"volume_mount"</span>),</span><br><span class="line">   &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/07/controller-ReplicaSet-Replication/">Kubernetes Controller —— ReplicaSet 和 Replication</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Kubernetes/">Kubernetes</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Kubernetes/Controller/">Controller</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Kubernetes/">Kubernetes</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Controller/">Controller</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ReplicaSet/">ReplicaSet</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Replication/">Replication</a></span><div class="content"><p>现下，Deployment算是k8s中使用最广泛的控制器，而ReplicaSet和Replication我们一般不会直接用到，但也值得研究下它们的实现。</p>
<p>在Deployment出现前，Replication往往是部署无状态应用（无论单副本还是多副本）的首选；而Deployment又工作在ReplicaSet之上，借助多个ReplicaSet来实现多版本控制。</p>
<blockquote>
<p>ReplicaSetController is responsible for synchronizing ReplicaSet objects stored in the system with actual running pods.</p>
</blockquote>
<blockquote>
<p>ReplicationManager is responsible for synchronizing ReplicationController objects stored</p>
</blockquote>
<p>本文的代码基于<a href="https://github.com/kubernetes/kubernetes/tree/release-1.18。" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/tree/release-1.18。</a></p>
<h2 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h2><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">startReplicaSetController</span><br><span class="line">    <span class="keyword">go</span> replicaset.NewReplicaSetController(</span><br><span class="line">        ctx.InformerFactory.Apps().V1().ReplicaSets(),</span><br><span class="line">        ctx.InformerFactory.Core().V1().Pods(),</span><br><span class="line">        ctx.ClientBuilder.ClientOrDie(<span class="string">"replicaset-controller"</span>),</span><br><span class="line">        replicaset.BurstReplicas,</span><br><span class="line">    ).Run(<span class="keyword">int</span>(ctx.ComponentConfig.ReplicaSetController.ConcurrentRSSyncs), ctx.Stop)</span><br></pre></td></tr></table></figure>

<p>从启动方法可以清楚，ReplicaSetController关注集群中的ReplicaSets和Pods。</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplicaSetController <span class="keyword">struct</span> &#123;</span><br><span class="line">    schema.GroupVersionKind</span><br><span class="line">    kubeClient clientset.Interface</span><br><span class="line">    podControl controller.PodControlInterface</span><br><span class="line">    burstReplicas <span class="keyword">int</span></span><br><span class="line">    syncHandler <span class="function"><span class="keyword">func</span><span class="params">(rsKey <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line">    expectations *controller.UIDTrackingControllerExpectations</span><br><span class="line">    rsLister appslisters.ReplicaSetLister</span><br><span class="line">    rsListerSynced cache.InformerSynced</span><br><span class="line">    podLister corelisters.PodLister</span><br><span class="line">    podListerSynced cache.InformerSynced</span><br><span class="line">    queue workqueue.RateLimitingInterface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>schema.GroupVersionKind</code>: group,version,kind</li>
<li><code>kubeClient</code>: 用于和apiserver通信</li>
<li><code>podControl</code>: 操作pod的接口，含CreatePods/CreatePodsOnNode/CreatePodsWithControllerRef/DeletePod/PatchPod等方法</li>
<li><code>burstReplicas</code>: 调整ReplicaSet的Pods时，单次最大进行的Pod数量</li>
<li><code>syncHandler</code>: 调谐方法</li>
<li><code>expectations</code>: 存放针对各个rs 期望创建或删除的Pod个数（如果是删除，还会存放待删除Pod的key——namespace/name）</li>
<li><code>rsLister</code>: 列出ReplicaSet的工具（从Informer中的Indexer中获取数据，不直接访问apiserver）</li>
<li><code>rsListerSynced</code>: 初始时rsInformer通过ListerWatcher的list获取的所有ReplicaSet是否已经分发到EventHandler处理完毕</li>
<li><code>podLister</code>: 列出Pod的工具（从Informer中的Indexer中获取数据，不直接访问apiserver）</li>
<li><code>podListerSynced</code>: 初始时podInformer通过ListerWatcher的list获取的所有Pod是否已经分发到EventHandler处理完毕</li>
<li><code>queue</code>: 限流的工作队列</li>
</ol>
<h3 id="Informer与EventHandler"><a href="#Informer与EventHandler" class="headerlink" title="Informer与EventHandler"></a>Informer与EventHandler</h3><p>结构体存在两种Informer：PodInformer和ReplicaSetInformer。</p>
<p>这两个Informer注册的EventHandler如下图所示：</p>
<img src="/2020/05/07/controller-ReplicaSet-Replication/replicaset.png" width="1000" hegiht="600" align="center">

<ol>
<li><code>addPod</code>: 分3种情况<ol>
<li><code>pod.DeletionTimestamp != nil</code>该Pod已经处于pending deletion状态，直接调用deletePod</li>
<li>该Pod存在关联的Controller，且该Controller是已知的ReplicaSet，则调用CreateObserved（调低expectations中相应RS的期望创建Pod数）并将RS的key加入到queue中</li>
<li>该Pod不存在任何关联的Controller（这种情况下称该Pod是Orphan），但存在同一namespace内labelSelector与Pod的labels匹配的RS，将这些RS的key加入到queue中（后续Worker处理可以尝试将Pod与RS关联）</li>
</ol>
</li>
<li><code>updatePod</code>: 分2种情况<ol>
<li><code>curPod.DeletionTimestamp != nil</code> 则调用deletePod删除curPod，如果oldPod与curPod的labels不相同，则也将oldPod删除</li>
<li>如果oldPod存在关联的ReplicaSet，则将该RS的key加入到queue中<ol>
<li>如果当前curPod有关联的ReplicaSet，则将RS的key加入到queue中</li>
<li>如果当前curPod是Orphan，则依旧将labels匹配的RS的key加入到queue中</li>
</ol>
</li>
</ol>
</li>
<li><code>deletePod</code>: 如果该Pod不是Orphan，则调用DeletionObserved（调低expectations中相应RS的期望删除Pod数）并将RS的key加入到queue中</li>
<li><code>addRS</code>: 直接将该RS的key加入到queue中</li>
<li><code>updateRS</code>: 如果<code>curRS.UID != oldRS.UID</code>，则调用deleteRS将oldRS删除；将curRS的key加入queue</li>
<li><code>deleteRS</code>: 调用DeleteExpectations（由于RS本身不存在了，因此存于expectations中的期望创建或删除Pod数也就没意义了），将RS的key加入到queue中</li>
</ol>
<h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p>Worker的调谐逻辑见<a href="https://github.com/kubernetes/kubernetes/blob/a654bda3de8174c0a27b098c6f768ee8f47ffbe6/pkg/controller/replicaset/replica_set.go#L568" target="_blank" rel="noopener">syncReplicaSet</a>方法，它会从queue中拾取需要调谐的ReplicaSet（格式是namespace/name），然后分情况进行处理</p>
<ol>
<li>ReplicaSet不存在，则直接从expectations中删除期望值即可</li>
<li>ReplicaSet存在，给labels匹配但没有ControllerRef的Pods指定Controller</li>
<li>ReplicaSet存在，判断当前activePods数量与ReplicaSet的Replicas否相等，不等则调用<code>manageReplicas</code>对ReplicaSet拥有的Pod数进行调整，最后更新ReplicaSet的状态<ol>
<li><code>manageReplicas</code>时若activePods不足，则在expectations中设置期望创建的Pod数量，然后创建指定Controller的Pods</li>
<li><code>manageReplicas</code>时若activePods超过，则筛选出要删除的Pods，添加进expectations，之后删除这些Pods</li>
</ol>
</li>
</ol>
<p>在创建或删除Pods分别有一些策略：</p>
<h4 id="创建Pods策略"><a href="#创建Pods策略" class="headerlink" title="创建Pods策略"></a>创建Pods策略</h4><ol>
<li>一次<code>manageReplicas</code>创建的Pods数量不超过burstReplicas（默认是500）</li>
<li>执行批量创建Pod时使用slowStartBatch（慢启动）策略：分批次创建，每次并发启动n个goroutine创建n个Pod，n从1开始指数增长（1-&gt;2-&gt;3-&gt;4-&gt;,,,），直到所有Pods创建完毕；但只要出现一个异常，就不再进行下一批次的创建</li>
</ol>
<h4 id="删除Pods策略"><a href="#删除Pods策略" class="headerlink" title="删除Pods策略"></a>删除Pods策略</h4><ol>
<li>一次<code>manageReplicas</code>删除的Pods数量不超过burstReplicas（默认是500）</li>
<li>选取最适合被删除的Pods。列出待删除Pods的候选项时，还会获取该ReplicaSet的Owner拥有的所有ReplicaSets关联的Pods（例如一个Deployment拥有两个ReplicaSet——a和b，则manageReplicas(a)时也将b的Pods考虑在内），用作Pods打分时的参考</li>
<li>在给这些Pods打分时，使用下列策略（有优先级，只要一条符合就不再往下判断）：<ol>
<li>根据是否被调度。没有被调度（NodeName为空）的Pod更适合被删除</li>
<li>根据Pod状态。Pending比Unknown更适合被删除，Unknown比Running更适合被删除</li>
<li>根据是否就绪。NotReady比Ready更适合被删除</li>
<li>根据所处节点上候选Pod数量（包含了同Owner的ReplicaSet的Pod）。Pod越多越适合被删除（例如ReplicaSet的Replicas为2，但当前节点a上有2个该ReplicaSet的Pod，而节点b上只有1个，那么a上的某个Pod更适合被删除）</li>
<li>根据就绪时间。当两个Pod都是Ready状态，晚Ready的更适合被删除</li>
<li>根据重启次数。重启次数越多，越适合被删除</li>
<li>根据创建时间。创建越晚，越适合被删除</li>
</ol>
</li>
</ol>
<h2 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h2><p>在本文对Controller进行分析的时候，Replication已与ReplicaSet完全无差别（除了名字），因为Replication的实现复用了ReplicaSet的源码。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// It is actually just a wrapper around ReplicaSetController.</span></span><br><span class="line"><span class="keyword">type</span> ReplicationManager <span class="keyword">struct</span> &#123;</span><br><span class="line">    replicaset.ReplicaSetController</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>ReplicaSet（RS）和Replication（RC）是k8s中非常经典的编排控制器，功能简单（维持应用副本数量），但它的实现上也体现了一些Controller技巧和思想：</p>
<ol>
<li>使用<code>slowStartBatch</code>来避免创建Pod时的拥塞。类比tcp发包时要考虑批量的报文进入网络可能产生的拥塞，创建Pod也要考虑k8s的承压能力；并发创建数量由小慢慢变大，可以提前发现问题。</li>
<li>使用<code>expectations</code>记录(ExpectCreations/ExpectDeletions)期望创建或删除的资源量，再通过观察(CreationObserved/DeletionObserved)资源变化，将资源量的调整做成一个异步的、命令式的过程。</li>
<li>Pod所处StartUp阶段可以作为Pod竞争时衡量优先级的一个方面。</li>
</ol>
<blockquote><p>同步自 <a href="https://github.com/pangsq/read_code_of_k8s/blob/master/controllers/ReplicaSet_and_Replication.md" target="_blank" rel="noopener">https://github.com/pangsq/read_code_of_k8s/blob/master/controllers/ReplicaSet_and_Replication.md</a></p>
</blockquote></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/05/workQueue/">Kubernetes运行机制 —— WorkQueue</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Kubernetes/">Kubernetes</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Kubernetes/">Kubernetes</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/WorkQueue/">WorkQueue</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/RateLimit/">RateLimit</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Golang/">Golang</a></span><div class="content"><p>WorkQueue工作队列，源码在k8s.io/client-go/util/workqueue包中。</p>
<p>一般其会作用在这样的场景中：</p>
<ol>
<li>SharedIndexInformer通过ListerWatcher机制从apiserver中不断获取资源对象实例的变化(delta);</li>
<li>注册到SharedIndexInformer的EventHandler将delta或delta 的key（下文统一称呼为item）存入到WorkQueue（具体是RateLimitingQueue）</li>
<li>Controller/Operator的多个Worker线程不断从WorkQueue获取item，进行处理（对集群调谐）</li>
</ol>
<p>可见WorkQueue起到了承接Informer（生产者）和Worker（消费者）的作用，而client-go中实现的WorkQueue具体特点有啥，<code>k8s.io/client-go/util/workqueue/doc.go</code>归纳了基础的4点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  * Fair: items processed in the order in which they are added.</span><br><span class="line">&#x2F;&#x2F;  * Stingy: a single item will not be processed multiple times concurrently,</span><br><span class="line">&#x2F;&#x2F;      and if an item is added multiple times before it can be processed, it</span><br><span class="line">&#x2F;&#x2F;      will only be processed once.</span><br><span class="line">&#x2F;&#x2F;  * Multiple consumers and producers. In particular, it is allowed for an</span><br><span class="line">&#x2F;&#x2F;      item to be reenqueued while it is being processed.</span><br><span class="line">&#x2F;&#x2F;  * Shutdown notifications.</span><br></pre></td></tr></table></figure>

<ol>
<li>公平。保证处理顺序，先来先处理</li>
<li>同一个item不能同时被多次处理；只要item还没被处理，那么多次地添加，最终也只处理一次</li>
<li>多生产者多消费者，支持并发，WorkQueue本身也是线程安全的。同时支持item在处理后可以选择放回队列</li>
<li>关闭时有通知</li>
</ol>
<p>实际上，最被广泛使用的WorkQueue的实现还带有限流功能。</p>
<p>那client-go究竟是如何实现功能这么丰富的工作队列的呢？</p>
<p>答案是逐级实现：Queue（普通队列）-&gt; DelayingQueue（延迟队列）-&gt; RateLimitingQueue（限流队列）</p>
<p>本文基于<a href="https://github.com/kubernetes/client-go/tree/release-1.18" target="_blank" rel="noopener">release-1.18分支</a>进行分析。</p>
<h2 id="普通队列——Queue"><a href="#普通队列——Queue" class="headerlink" title="普通队列——Queue"></a>普通队列——Queue</h2><p>普通队列，实现了前文提到的WorkQueue的4点基础功能。</p>
<h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>接口是<code>Interface</code>。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Add(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	Len() <span class="keyword">int</span></span><br><span class="line">	Get() (item <span class="keyword">interface</span>&#123;&#125;, shutdown <span class="keyword">bool</span>)</span><br><span class="line">	Done(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	ShutDown()</span><br><span class="line">	ShuttingDown() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Add</code> 往队列中添加item</li>
<li><code>Len</code> 队列中当前可处理的item数量</li>
<li><code>Get</code> 从队列中获取可处理的item（阻塞地等待到有可处理的item或队列被关闭）</li>
<li><code>Done</code> 处理完毕item，从队列中移除该item（常用的套路是，先Get获取item，进行处理，然后主动调用Done；如没有调用Done就结束处理逻辑，则会出现逻辑错误，该item将永远不会被处理到）</li>
<li><code>ShutDown</code> 关闭队列</li>
<li><code>ShuttingDown</code> 判断队列是否被关闭</li>
</ol>
<h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>实现<code>Interface</code>的结构体是<code>Type</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">struct</span> &#123;</span><br><span class="line">	queue []t</span><br><span class="line">	dirty set</span><br><span class="line">	processing set</span><br><span class="line">	cond *sync.Cond</span><br><span class="line">	shuttingDown <span class="keyword">bool</span></span><br><span class="line">	metrics queueMetrics</span><br><span class="line">	unfinishedWorkUpdatePeriod time.Duration</span><br><span class="line">	clock                      clock.Clock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中核心的三个存放item的数据结构分别是queue、dirty、processing，它们三个分别表示</p>
<ol>
<li><code>dirty</code> 待处理的items</li>
<li><code>queue</code> 可处理的items</li>
<li><code>processing</code> 正在处理的items</li>
</ol>
<h3 id="运行分析"><a href="#运行分析" class="headerlink" title="运行分析"></a>运行分析</h3><p>item在WorkQueue中的状态转换如下图所示：</p>
<img src="/2020/05/05/workQueue/queue.png" width="1000" hegiht="600" align="center">

<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><ol>
<li><code>Start</code>: item刚从Informer中获取到，即将加入到队列中</li>
<li><code>dirty,queue</code>: item在可处理状态，等待Worker拾取</li>
<li><code>processing</code>: item正在被某个Worker处理中</li>
<li><code>processing,dirty</code>: item正在被某个Worker处理，并且又有相同item加入队列中</li>
<li><code>End</code>: item被处理完毕，队列中不存在item</li>
</ol>
<h4 id="状态迁移"><a href="#状态迁移" class="headerlink" title="状态迁移"></a>状态迁移</h4><ol>
<li><code>Add.1</code>: （Informer的EventHandler）使用Add方法，尝试将item加入到队列中时，队列中没有正在处理的相同item</li>
<li><code>Add.2</code>: （Informer的EventHandler）使用Add方法，尝试将item加入到队列中时，队列中有正在处理的相同的item，此时该item不可被处理（为了保证多个Worker不能同时对一个item进行处理）</li>
<li><code>Add.3</code>: （Informer的EventHandler）使用Add方法，尝试将item加入到队列中时，如果此时dirty中已存在item，那么不改变item的状态（同一item只处理一次）</li>
<li><code>Add.4</code>: 同Add.3</li>
<li><code>Get</code>: （Worker）尝试从队列中获取一个可处理的item</li>
<li><code>Done.1</code>: （Worker）处理完毕item时，队列中没有待处理的相同item</li>
<li><code>Done.2</code>: （Worker）处理完毕item时，队列中有待处理的相同item，则该待处理的item进入可处理状态</li>
</ol>
<h2 id="延迟队列——DelayingQueue"><a href="#延迟队列——DelayingQueue" class="headerlink" title="延迟队列——DelayingQueue"></a>延迟队列——DelayingQueue</h2><p>延迟队列，相较于普通的Queue，多了一个功能：添加item，一段时间后该item才会处于可处理状态。这个功能是为下文限流队列的实现做铺垫。</p>
<h3 id="DelayingInterface"><a href="#DelayingInterface" class="headerlink" title="DelayingInterface"></a>DelayingInterface</h3><p>接口是<code>DelayingInterface</code>。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DelayingInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Interface</span><br><span class="line">	AddAfter(item <span class="keyword">interface</span>&#123;&#125;, duration time.Duration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相较于Interface，仅仅多了AddAfter一个方法。</p>
<h3 id="delayingType"><a href="#delayingType" class="headerlink" title="delayingType"></a>delayingType</h3><p>实现<code>DelayingInterface</code>的结构体是<code>delayingType</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> delayingType <span class="keyword">struct</span> &#123;</span><br><span class="line">	Interface</span><br><span class="line">	clock clock.Clock</span><br><span class="line">	stopCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	stopOnce sync.Once</span><br><span class="line">	heartbeat clock.Ticker</span><br><span class="line">	waitingForAddCh <span class="keyword">chan</span> *waitFor</span><br><span class="line">	metrics retryMetrics</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitFor <span class="keyword">struct</span> &#123;</span><br><span class="line">	data    t</span><br><span class="line">	readyAt time.Time</span><br><span class="line">	index <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现延迟的关键点在waitFor这个结构体。</p>
<h3 id="运行分析-1"><a href="#运行分析-1" class="headerlink" title="运行分析"></a>运行分析</h3><p>使用<code>AddAfter</code>加入item，实际上是添加一项带就绪时间的waitFor到waitingForAddCh这个通道。随后waitingLoop()协程不断从waitingForAddCh中取出waitFor，插入到一个堆（waitForPriorityQueue）中。</p>
<p>堆的根存放的是持有最近<code>readyAt</code>时间的waitFor。waitingLoop()等待根上的item就绪，然后将其放入待处理队列中。</p>
<img src="/2020/05/05/workQueue/delayingQueue.png" width="1000" hegiht="600" align="center">

<h2 id="限流队列——RateLimitingQueue"><a href="#限流队列——RateLimitingQueue" class="headerlink" title="限流队列——RateLimitingQueue"></a>限流队列——RateLimitingQueue</h2><p>限流队列，其实现依赖于DelayingQueue，考虑到Worker的处理能力有限，使用限流器对item加入队列的速度进行限制。</p>
<h3 id="RateLimitingInterface"><a href="#RateLimitingInterface" class="headerlink" title="RateLimitingInterface"></a>RateLimitingInterface</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RateLimitingInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">	DelayingInterface</span><br><span class="line">	AddRateLimited(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	Forget(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	NumRequeues(item <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>AddRateLimited</code>: 借助限流器，添加的item在等待限流器设置的一段时间后才进入可处理状态</li>
<li><code>Forget</code>: （限流器中可能会记录item的尝试处理次数）从限流器中删除item</li>
<li><code>NumRequeues</code>: item重新入队（尝试处理、失败）的次数</li>
</ol>
<h3 id="rateLimitingType"><a href="#rateLimitingType" class="headerlink" title="rateLimitingType"></a>rateLimitingType</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> rateLimitingType <span class="keyword">struct</span> &#123;</span><br><span class="line">	DelayingInterface</span><br><span class="line">	rateLimiter RateLimiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *rateLimitingType)</span> <span class="title">AddRateLimited</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	q.DelayingInterface.AddAfter(item, q.rateLimiter.When(item))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *rateLimitingType)</span> <span class="title">NumRequeues</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> q.rateLimiter.NumRequeues(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *rateLimitingType)</span> <span class="title">Forget</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	q.rateLimiter.Forget(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这块代码很简洁，具体的逻辑都由rateLimiter进行实现。</p>
<h3 id="RateLimiter"><a href="#RateLimiter" class="headerlink" title="RateLimiter"></a>RateLimiter</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RateLimiter <span class="keyword">interface</span> &#123;</span><br><span class="line">	When(item <span class="keyword">interface</span>&#123;&#125;) time.Duration</span><br><span class="line">	Forget(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	NumRequeues(item <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>When</code>: item等待多久才能进入待处理状态</li>
<li><code>Forget</code>: （限流器中可能会记录item的尝试处理次数）从限流器中删除item</li>
<li><code>NumRequeues</code>‘: item重新入队的次数</li>
</ol>
<h4 id="BucketRateLimiter"><a href="#BucketRateLimiter" class="headerlink" title="BucketRateLimiter"></a>BucketRateLimiter</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BucketRateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	*rate.Limiter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该限流器使用令牌桶算法（设定令牌生成的速率和令牌桶容量）限制item加入的速率，其<code>NumRequeues</code>/<code>Forget</code>不做任何处理。</p>
<h4 id="ItemBucketRateLimiter"><a href="#ItemBucketRateLimiter" class="headerlink" title="ItemBucketRateLimiter"></a>ItemBucketRateLimiter</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ItemBucketRateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	r     rate.Limit</span><br><span class="line">	burst <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	limitersLock sync.Mutex</span><br><span class="line">	limiters     <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*rate.Limiter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>升级版的<code>BucketRateLimiter</code>，它对每一个item设置一个令牌桶限流，<code>NumRequeues</code>/<code>Forget</code>不做任何处理。</p>
<h4 id="ItemExponentialFailureRateLimiter"><a href="#ItemExponentialFailureRateLimiter" class="headerlink" title="ItemExponentialFailureRateLimiter"></a>ItemExponentialFailureRateLimiter</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ItemExponentialFailureRateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	failuresLock sync.Mutex</span><br><span class="line">	failures     <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	baseDelay time.Duration</span><br><span class="line">	maxDelay  time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ItemExponentialFailureRateLimiter</code>针对每个item记录失败次数和设置限流器，限流策略是：等待时间随失败次数（重入队次数）指数增长，直到抵达阈值。<code>NumRequeues</code>返回失败次数，<code>Forget</code>重置其失败次数。</p>
<h4 id="ItemFastSlowRateLimiter"><a href="#ItemFastSlowRateLimiter" class="headerlink" title="ItemFastSlowRateLimiter"></a>ItemFastSlowRateLimiter</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ItemFastSlowRateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	failuresLock sync.Mutex</span><br><span class="line">	failures     <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	maxFastAttempts <span class="keyword">int</span></span><br><span class="line">	fastDelay       time.Duration</span><br><span class="line">	slowDelay       time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ItemFastSlowRateLimiter</code>也是针对每个item记录失败次数和设置限流器，限流策略是：在一定失败次数内，等待时间是fastDelay，否则是slowDelay。<code>NumRequeues</code>返回失败（重入队）次数，<code>Forget</code>重置其失败次数。</p>
<h4 id="MaxOfRateLimiter"><a href="#MaxOfRateLimiter" class="headerlink" title="MaxOfRateLimiter"></a>MaxOfRateLimiter</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MaxOfRateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	limiters []RateLimiter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MaxOfRateLimiter</code>是一种特殊限流器，是其他限流器的组合（可放入任意限流器）。其等待时间和失败次数，取其成员中的最大等待时间和最大失败次数，<code>Forget</code>则重置所有成员限流器的失败次数。</p>
<p>Controller默认使用的就是这种组合限流器。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DefaultControllerRateLimiter</span><span class="params">()</span> <span class="title">RateLimiter</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewMaxOfRateLimiter(</span><br><span class="line">		NewItemExponentialFailureRateLimiter(<span class="number">5</span>*time.Millisecond, <span class="number">1000</span>*time.Second),</span><br><span class="line">		<span class="comment">// 10 qps, 100 bucket size.  This is only for retry speed and its only the overall factor (not per item)</span></span><br><span class="line">		&amp;BucketRateLimiter&#123;Limiter: rate.NewLimiter(rate.Limit(<span class="number">10</span>), <span class="number">100</span>)&#125;,</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="限流队列的一般用法"><a href="#限流队列的一般用法" class="headerlink" title="限流队列的一般用法"></a>限流队列的一般用法</h3><p>下面写一个简单例子，示意限流队列的用法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ct *controller)</span> <span class="title">processNextWorkItem</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    item, quit := ct.queue.Get() <span class="comment">// 尝试从队列中获取item</span></span><br><span class="line">    <span class="keyword">if</span> quit &#123;   <span class="comment">// 队列关闭则不再做任何处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    err := ct.syncHandler(item) <span class="comment">// 根据item进行调谐</span></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        ct.queue.Forget(item)    <span class="comment">// 处理完毕，则从限流器中删除该item</span></span><br><span class="line">    &#125;</span><br><span class="line">    ct.queue.AddRateLimited(item)   <span class="comment">// 将该item重新加入队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote><p>同步自 <a href="https://github.com/pangsq/read_code_of_k8s/blob/master/util/WorkQueue/WorkQueue.md" target="_blank" rel="noopener">https://github.com/pangsq/read_code_of_k8s/blob/master/util/WorkQueue/WorkQueue.md</a></p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/03/build-your-blog/">使用Hexo + Github Pages搭建个人博客</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E9%BC%93%E6%8D%A3%E7%82%B9%E5%84%BF%E4%BB%80%E4%B9%88/">鼓捣点儿什么</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Hexo/">Hexo</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Github-Pages/">Github Pages</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Travis-CI/">Travis CI</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/SEO/">SEO</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Realm/">Realm</a></span><div class="content"><p>本文记录利用 <code>Hexo + Github Pages + Travis CI + 域名</code> 搭建个人博客的过程。</p>
<h2 id="Hexo作为博客框架"><a href="#Hexo作为博客框架" class="headerlink" title="Hexo作为博客框架"></a>Hexo作为博客框架</h2><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>是一个广泛使用的博客框架，上手简单，页面简洁，非常适合用于发布个人的一些文章。</p>
<p>Hexo项目可以直接跑在服务器上，或者依托于Github Pages之类的平台进行托管。无论最终网站运行在哪，在搭建Hexo项目和创作文章过程中还是需要有一台电脑或服务器能够运行Hexo。建议用mac或linux，配环境省事点；直接用win或者WSL也可以。</p>
<p>因为这几天手头只有台win10的笔记本，所以我用的阿里云的一台ecs(centos 7.2)运行Hexo，用vscode remote初始化项目和进行修改。</p>
<ol>
<li>安装或更新nodejs。对于centos最简单的做法是 <code>sudo yum install -y nodejs</code>，但是由于yum源的nodejs版本比较老，所以直接到 <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a> 下载二进制包(v14.0.0)，解压后配置PATH。</li>
<li>安装hexo-cli <code>npm install hexo-cli -g</code></li>
<li>初始化hexo项目 <code>hexo init blog</code>。blog是项目的目录。刚初始化的项目中已存在一篇helloWorld文章。</li>
<li>创建新文章 <code>hexo new page &quot;&lt;page name&gt;&quot;</code>，文章格式是Markdown的<ol>
<li>注意<code>hexo new page</code>是以scaffolds/page.md为模板在source/_posts中创建相应Markdown文件，post/draft同理，所以可以根据自己需要事先修改这几个模板文件</li>
<li>在文章中插入图片需要注意，直接将图片放在与Markdown同级目录下，然后用相对地址，Hexo是渲染不出来的；需要在_config.yml中配置 <code>post_asset_folder: true</code>，那么<code>hexo new</code>创建文章时会一并创建一个同名的目录，将图片放置在该目录下，然后再用Markdown插入图片的方式就能生效了</li>
</ol>
</li>
<li>默认情况下hexo运行后，导航栏中会存在catagories和tags两个栏目，但点击跳转会显示404，需要事先进行简单配置<ol>
<li>用<code>hexo new page categories</code>和<code>hexo new page tags</code>创建categories和tags，然后修改它们的type以及layout，分别修改为categories和tags</li>
<li>在_config.yml中配置<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nav:</span> </span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags</span></span><br><span class="line">  <span class="attr">catagories:</span> <span class="string">/catagories</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>默认用的<code>landscape</code>主题，可以在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">themes</a>挑选主题，放到themes/目录下，并在_config.yml中配置theme启用</li>
<li>运行Hexo <code>hexo server</code>，监听4000端口，此时浏览器可以进行访问</li>
<li>Hexo使用上的更多内容见<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo文档</a></li>
</ol>
<h2 id="Github-Pages托管博客"><a href="#Github-Pages托管博客" class="headerlink" title="Github Pages托管博客"></a>Github Pages托管博客</h2><p><a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a>,可以对我们的博客进行托管，节省自己维护服务器的精力。</p>
<ol>
<li>在github上创建一个名为<code>&lt;username&gt;.github.io</code>的repo（用这个格式作为repo名字的原因是只有这个名字可以在启用Github Pages时直接拿来当url用，其他repo的url只能是<code>&lt;username&gt;.github.io/&lt;repo name&gt;</code></li>
<li>在repo的settings中开启Github Pages，默认情况（不花钱）下只能选择master作为发布分支（即想让Github Pages托管的网站文件都必须放在master分支，其他分支是无关的，想放什么都可以）</li>
<li>将之前hexo init所在目录git init，并关联刚创建的repo（下一小节再推送）</li>
</ol>
<h2 id="Travis-CI自动发布"><a href="#Travis-CI自动发布" class="headerlink" title="Travis CI自动发布"></a>Travis CI自动发布</h2><p>Travis CI我们一般用来做自动化集成，这里也可以用来做Hexo项目的自动化构建。</p>
<p>Hexo运行时真正起作用的是public/文件夹内的内容，在Hexo项目中使用<code>hexo generate</code>可生成public/，将其放到Github Pages关联的分支中，就能让Github Pages把博客网站跑起来了。</p>
<ol>
<li>参考<a href="https://hexo.io/zh-cn/docs/github-pages" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/github-pages</a> 配置travis-ci，将其与我们的github账号联动起来</li>
<li>修改.travis.yml中的master为source，并添加target_branch: master。这是由于我们只能选择master作为发布分支，所以以source分支维护我们的项目。<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10</span> <span class="comment"># use nodejs v10 LTS</span></span><br><span class="line"><span class="attr">cache:</span> <span class="string">npm</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source</span> <span class="comment"># build master branch only</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span> <span class="comment"># generate static files</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip-cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github-token:</span> <span class="string">$GH_TOKEN</span></span><br><span class="line">  <span class="attr">keep-history:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">source</span></span><br><span class="line">  <span class="attr">local-dir:</span> <span class="string">public</span></span><br><span class="line">  <span class="attr">target_branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li>
<li>将本地的分支推送到github中作为source分支。<code>git push origin master:source</code></li>
<li>关注travis-ci中的构建情况，如不出意外，几分钟后访问 <code>http://&lt;username&gt;.github.io</code> 就能看到博客效果了。</li>
</ol>
<p>至此，个人博客已经成型，以后修改文章、创建文章都在source分支中进行，travis-ci会自动帮我们进行构建。</p>
<h2 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h2><p>如果自己有域名的话，可以将自己的域名关联到个人博客上。</p>
<p>由于我之前有在阿里云上申请过域名，该域名直接关联ecs（为了平时敲敲ssh的时候不用背ip），所以打算用一个二级域名去关联博客。</p>
<ol>
<li>登录阿里云，添加一条DNS解析，给pangsq.cn域名（主机为blog）添加CNAME记录指向pangsq.github.io</li>
<li>source分支中，在source/目录下添加一个CNAME文件，内容为blog.pangsq.cn</li>
<li>推送source分支到远端；travis ci构建成功后，在master分支也能看到CNAME文件</li>
<li>访问<a href="http://blog.pangsq.cn">http://blog.pangsq.cn</a>或<a href="https://blog.pangsq.cn">https://blog.pangsq.cn</a>就能访问博客了</li>
</ol>
<h2 id="让搜索引擎对博客进行收录"><a href="#让搜索引擎对博客进行收录" class="headerlink" title="让搜索引擎对博客进行收录"></a>让搜索引擎对博客进行收录</h2><p>完成了上面的工作，博客就能通过个人域名访问到了，但目前还不会被搜索引擎收录。</p>
<p>这里提个醒，Github Pages禁止百度的爬虫访问，所以百度搜索不到博客是正常的。</p>
<p>这里只考虑Google，以后再处理Bing或其他搜索引擎。</p>
<ol>
<li>使用sitemap，我们可以直接向Google提交我们的网站。首先生成网站的sitemap<ol>
<li>在source分支的代码下，<code>npm install hexo-generator-sitemap --save</code></li>
<li>在_config.yml中配置<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br></pre></td></tr></table></figure></li>
<li>推送分支到远端，构建后master分支下会生成sitemap.xml</li>
</ol>
</li>
<li>登录Google的<a href="https://search.google.com/search-console" target="_blank" rel="noopener">Search Console</a></li>
<li>按照指示验证域名。在域名控制台里，添加一条txt记录。</li>
<li>在Search Console的<code>Index &gt; Sitemaps</code>栏目中提交sitemap.xml的url，例如 <code>https://blog.pangsq.cn/sitemap.xml</code></li>
<li>在<code>URL inspection</code>中输入博客地址，再点击”REQUEST INDEXING”，会将博客地址加入Google的相对高优先级的队列中供爬虫获取</li>
<li>等待几分钟后能在Google中就搜到博客了（可能是目前网页的权重还比较低，所以关键词是网站的url才容易搜得到；我直接搜博客名是显示在了第二页）</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/02/controllerManagerEntry/index/">Kubernetes Controller —— Controller Manager入口分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Kubernetes/">Kubernetes</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Kubernetes/Controller/">Controller</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Kubernetes/">Kubernetes</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Controller/">Controller</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Golang/">Golang</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Entry/">Entry</a></span><div class="content"><p>branch: release-v1.18</p>
<p>commit: ff809a5d953ba778270ce8790b21d394821e1e28</p>
<h2 id="cmd-kube-controller-manager-controller-manager-go"><a href="#cmd-kube-controller-manager-controller-manager-go" class="headerlink" title="cmd/kube-controller-manager/controller-manager.go"></a><code>cmd/kube-controller-manager/controller-manager.go</code></h2><p>一个非常简洁标准的命令模样的入口</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">	command := app.NewControllerManagerCommand()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> once we switch everything over to Cobra commands, we can go back to calling</span></span><br><span class="line">	<span class="comment">// utilflag.InitFlags() (by removing its pflag.Parse() call). For now, we have to set the</span></span><br><span class="line">	<span class="comment">// normalize func and add the go flag set by hand.</span></span><br><span class="line">	<span class="comment">// utilflag.InitFlags()</span></span><br><span class="line">	logs.InitLogs()</span><br><span class="line">	<span class="keyword">defer</span> logs.FlushLogs()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := command.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体实现逻辑明显在<code>NewControllerManagerCommand()</code>中</p>
<h2 id="cmd-kube-contoller-manager-app"><a href="#cmd-kube-contoller-manager-app" class="headerlink" title="cmd/kube-contoller-manager/app/"></a><code>cmd/kube-contoller-manager/app/</code></h2><h3 id="NewContollerManagerCommand-，在controllermanager-go中"><a href="#NewContollerManagerCommand-，在controllermanager-go中" class="headerlink" title="NewContollerManagerCommand()，在controllermanager.go中"></a>NewContollerManagerCommand()，在controllermanager.go中</h3><ol>
<li>构造ControllerManager命令；初始化配置</li>
<li>接下来运行 Run(c.Complete(), wait.NeverStop)  // 见 2.3</li>
</ol>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewControllerManagerCommand creates a *cobra.Command object with default parameters</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControllerManagerCommand</span><span class="params">()</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">	s, err := options.NewKubeControllerManagerOptions() <span class="comment">// 详情见2.2</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	cmd := &amp;cobra.Command&#123;</span><br><span class="line">		Use: <span class="string">"kube-controller-manager"</span>,</span><br><span class="line">		Long: ...</span><br><span class="line">		Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">			...</span><br><span class="line"></span><br><span class="line">			c, err := s.Config(KnownControllers(), <span class="comment">// 所有支持的controllers名：sets.StringKeySet(NewControllerInitializers(IncludeCloudLoops)) </span></span><br><span class="line">			  ControllersDisabledByDefault.List()) <span class="comment">// 缺省被关闭的控制器，现在有"bootstrapsigner", "tokencleaner"</span></span><br><span class="line">			  <span class="comment">// 此处方法内部只有一个Validate(allContollers, disabledByDefaultControllers)用到了这两入参</span></span><br><span class="line">			  <span class="comment">// 注意到Run作为一个函数还没有到调用的时刻，cmd带哪些flags还得依赖从 `fs := cmd.Flags`开始的代码</span></span><br><span class="line">			...</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err := Run(c.Complete(), wait.NeverStop); err != <span class="literal">nil</span> &#123; <span class="comment">// 核心入口</span></span><br><span class="line">				fmt.Fprintf(os.Stderr, <span class="string">"%v\n"</span>, err)</span><br><span class="line">				os.Exit(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fs := cmd.Flags()</span><br><span class="line">	namedFlagSets := s.Flags(KnownControllers(), ControllersDisabledByDefault.List()) </span><br><span class="line">	<span class="comment">// 给命令行组装flags，传入这俩参数是为了描述controllers这个配置项的时候提示总共有哪些controller以及哪些是默认禁用的</span></span><br><span class="line">	<span class="comment">// controllers默认是"*" 表示启用所有默认开启的controllers，如果配置"foo"表示开启foo，"-foo"表示关闭foo，以,分隔</span></span><br><span class="line">	... <span class="comment">// 其他一些初始化cmd</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NewKubeControllerManagerOptions-在options-options-go中"><a href="#NewKubeControllerManagerOptions-在options-options-go中" class="headerlink" title="NewKubeControllerManagerOptions(),在options/options.go中"></a>NewKubeControllerManagerOptions(),在options/options.go中</h3><ol>
<li>创建一份kubeControllerManager的默认配置；追溯其源头可以到<code>pkg/controller/apis/config/v1alpha1/defaults.go</code>中的SetDefaults_KubeControllerManagerConfiguration 查看各个缺省值</li>
<li>此处展开可以了解一些controllerManager中有哪些配置项以及其可能的默认配置</li>
</ol>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewKubeControllerManagerOptions creates a new KubeControllerManagerOptions with a default config.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewKubeControllerManagerOptions</span><span class="params">()</span> <span class="params">(*KubeControllerManagerOptions, error)</span></span> &#123;</span><br><span class="line">	componentConfig, err := NewDefaultComponentConfig(ports.InsecureKubeControllerManagerPort) <span class="comment">// 又套了一层方法去实现一些通用的默认配置的初始化</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s := KubeControllerManagerOptions&#123;</span><br><span class="line">		Generic:         cmoptions.NewGenericControllerManagerConfigurationOptions(&amp;componentConfig.Generic),</span><br><span class="line">		KubeCloudShared: cmoptions.NewKubeCloudSharedOptions(&amp;componentConfig.KubeCloudShared),</span><br><span class="line">		ServiceController: &amp;cmoptions.ServiceControllerOptions&#123;</span><br><span class="line">			ServiceControllerConfiguration: &amp;componentConfig.ServiceController,</span><br><span class="line">		&#125;,</span><br><span class="line">		... <span class="comment">// 一堆controller的key-value对</span></span><br><span class="line">		... <span class="comment">// 一些认证方面的配置</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	... <span class="comment">// authentication/authorization/secureServing等默认配置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// gc资源配置就在此处了，一般我们很少配置gc相关的配置，所以通过这里可以知道k8s中一般有哪些资源可能是需要gc的</span></span><br><span class="line">	gcIgnoredResources := <span class="built_in">make</span>([]garbagecollectorconfig.GroupResource, <span class="number">0</span>, <span class="built_in">len</span>(garbagecollector.DefaultIgnoredResources()))  <span class="comment">// 忽略gc的资源，缺省的只有一个events</span></span><br><span class="line">	<span class="keyword">for</span> r := <span class="keyword">range</span> garbagecollector.DefaultIgnoredResources() &#123;</span><br><span class="line">		gcIgnoredResources = <span class="built_in">append</span>(gcIgnoredResources, garbagecollectorconfig.GroupResource&#123;Group: r.Group, Resource: r.Resource&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.GarbageCollectorController.GCIgnoredResources = gcIgnoredResources</span><br><span class="line">	s.Generic.LeaderElection.ResourceName = <span class="string">"kube-controller-manager"</span></span><br><span class="line">	s.Generic.LeaderElection.ResourceNamespace = <span class="string">"kube-system"</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Run-c-config-CompletedConfig-stopCh-lt-chan-struct-回到controllermanager-go"><a href="#Run-c-config-CompletedConfig-stopCh-lt-chan-struct-回到controllermanager-go" class="headerlink" title="Run(c *config.CompletedConfig, stopCh &lt;-chan struct{}),回到controllermanager.go"></a>Run(c *config.CompletedConfig, stopCh &lt;-chan struct{}),回到controllermanager.go</h3><ol>
<li>源码总计有130+行，算是controllerManager业务逻辑的主干了</li>
<li>具体功能有：<ol>
<li>打印version</li>
<li>向/configz这个handler中放入controllerManager目前的配置内容</li>
<li>将选主(leaderelection)情况放到healthCheck中</li>
<li>创建mux，加入/healthz、/debug/pprof、/configz、/metrics等handler</li>
<li>根据配置使用安全或非安全的模式，如果是安全模式，有Authorization和Authentication，之后启动http server</li>
<li>定义run：初始化clientBuilder为了后续能获取controller的config和client；先初始化saController再初始化其他controller；启动相关的informer</li>
<li>如果不需要选主则直接执行run，否则选主成功才执行run</li>
</ol>
</li>
</ol>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run runs the KubeControllerManagerOptions.  This should never exit.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(c *config.CompletedConfig, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	... <span class="comment">// 打印Version</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cfgz, err := configz.New(ConfigzName); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		cfgz.Set(c.ComponentConfig) <span class="comment">// configz是一个map[string]*Config&#123;&#125;，把kubeController的配置项注册进去，key为kubecontrollermanager.config.k8s.io</span></span><br><span class="line">		<span class="comment">// controller server会持有一个路径为`/configz`的handler</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		klog.Errorf(<span class="string">"unable to register configz: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Setup any healthz checks we will want to use.</span></span><br><span class="line">	<span class="comment">// 为了HA 所以集群中可能有多个controllerManager，因此controllerManager通过apiserver/etcd选主；</span></span><br><span class="line">	<span class="comment">// 此处将选主情况做进healthCheck中</span></span><br><span class="line">	<span class="keyword">var</span> checks []healthz.HealthChecker</span><br><span class="line">	<span class="keyword">var</span> electionChecker *leaderelection.HealthzAdaptor</span><br><span class="line">	<span class="keyword">if</span> c.ComponentConfig.Generic.LeaderElection.LeaderElect &#123;</span><br><span class="line">		electionChecker = leaderelection.NewLeaderHealthzAdaptor(time.Second * <span class="number">20</span>)</span><br><span class="line">		checks = <span class="built_in">append</span>(checks, electionChecker)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start the controller manager HTTP server</span></span><br><span class="line">	<span class="comment">// unsecuredMux is the handler for these controller *after* authn/authz filters have been applied</span></span><br><span class="line">	<span class="keyword">var</span> unsecuredMux *mux.PathRecorderMux</span><br><span class="line">	<span class="keyword">if</span> c.SecureServing != <span class="literal">nil</span> &#123;</span><br><span class="line">	    <span class="comment">// 1. 创建mux，基础path设置成"controller-manager" 2. 给mux加入/healthz、/debug/pprof、/configz、/metrics等handler</span></span><br><span class="line">		unsecuredMux = genericcontrollermanager.NewBaseHandler(&amp;c.ComponentConfig.Generic.Debugging, checks...)</span><br><span class="line">		handler := genericcontrollermanager.BuildHandlerChain(unsecuredMux, &amp;c.Authorization, &amp;c.Authentication)</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> handle stoppedCh returned by c.SecureServing.Serve</span></span><br><span class="line">		<span class="comment">// 开启server</span></span><br><span class="line">		<span class="keyword">if</span> _, err := c.SecureServing.Serve(handler, <span class="number">0</span>, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c.InsecureServing != <span class="literal">nil</span> &#123;</span><br><span class="line">		unsecuredMux = genericcontrollermanager.NewBaseHandler(&amp;c.ComponentConfig.Generic.Debugging, checks...)</span><br><span class="line">		insecureSuperuserAuthn := server.AuthenticationInfo&#123;Authenticator: &amp;server.InsecureSuperuser&#123;&#125;&#125;</span><br><span class="line">		handler := genericcontrollermanager.BuildHandlerChain(unsecuredMux, <span class="literal">nil</span>, &amp;insecureSuperuserAuthn)</span><br><span class="line">		<span class="keyword">if</span> err := c.InsecureServing.Serve(handler, <span class="number">0</span>, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	run := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">		rootClientBuilder := controller.SimpleControllerClientBuilder&#123;</span><br><span class="line">			ClientConfig: c.Kubeconfig,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> clientBuilder controller.ControllerClientBuilder <span class="comment">// 通过clientBuilder可以通过name获取controller的config和client</span></span><br><span class="line">		<span class="keyword">if</span> c.ComponentConfig.KubeCloudShared.UseServiceAccountCredentials &#123;</span><br><span class="line">			... <span class="comment">// 在云环境中的clientBuilder</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			clientBuilder = rootClientBuilder</span><br><span class="line">		&#125;</span><br><span class="line">		controllerContext, err := CreateControllerContext(c, rootClientBuilder, clientBuilder, ctx.Done())</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.Fatalf(<span class="string">"error building controller context: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 由于serverAccountToken的特殊性，必须先于其他controller启动</span></span><br><span class="line">		saTokenControllerInitFunc := serviceAccountTokenControllerStarter&#123;rootClientBuilder: rootClientBuilder&#125;.startServiceAccountTokenController</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动所有controllers。StartControllers见 2.4，NewControllerInitializers 见2.5</span></span><br><span class="line">		<span class="keyword">if</span> err := StartControllers(controllerContext, saTokenControllerInitFunc, NewControllerInitializers(controllerContext.LoopMode), unsecuredMux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.Fatalf(<span class="string">"error starting controllers: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 用于controller的informers</span></span><br><span class="line">		controllerContext.InformerFactory.Start(controllerContext.Stop)</span><br><span class="line">		<span class="comment">// 用于typed资源本身或动态资源的metadata的informers；目前用到这个informerFactory的有ResourceQuota和GarbageCollector</span></span><br><span class="line">		controllerContext.ObjectOrMetadataInformerFactory.Start(controllerContext.Stop)</span><br><span class="line">		<span class="built_in">close</span>(controllerContext.InformersStarted)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;&#125; <span class="comment">// 阻塞当前线程</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有启用选主（集群中只有一个controllerManager的情况下），直接run</span></span><br><span class="line">	<span class="keyword">if</span> !c.ComponentConfig.Generic.LeaderElection.LeaderElect &#123;</span><br><span class="line">		run(context.TODO()) <span class="comment">// 这里定义了一个Done() 为 &lt;-chan struct&#123;&#125;，在select中作为一个永远不会触发的条件</span></span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"unreachable"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	id, err := os.Hostname()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// add a uniquifier so that two processes on the same host don't accidentally both become active</span></span><br><span class="line">	id = id + <span class="string">"_"</span> + <span class="keyword">string</span>(uuid.NewUUID())</span><br><span class="line"></span><br><span class="line">	rl, err := resourcelock.New(c.ComponentConfig.Generic.LeaderElection.ResourceLock,</span><br><span class="line">		c.ComponentConfig.Generic.LeaderElection.ResourceNamespace,</span><br><span class="line">		c.ComponentConfig.Generic.LeaderElection.ResourceName,</span><br><span class="line">		c.LeaderElectionClient.CoreV1(),</span><br><span class="line">		c.LeaderElectionClient.CoordinationV1(),</span><br><span class="line">		resourcelock.ResourceLockConfig&#123;</span><br><span class="line">			Identity:      id,</span><br><span class="line">			EventRecorder: c.EventRecorder,</span><br><span class="line">		&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Fatalf(<span class="string">"error creating lock: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 选主，成为主才执行run</span></span><br><span class="line">	leaderelection.RunOrDie(context.TODO(), leaderelection.LeaderElectionConfig&#123;</span><br><span class="line">		Lock:          rl,</span><br><span class="line">		LeaseDuration: c.ComponentConfig.Generic.LeaderElection.LeaseDuration.Duration,</span><br><span class="line">		RenewDeadline: c.ComponentConfig.Generic.LeaderElection.RenewDeadline.Duration,</span><br><span class="line">		RetryPeriod:   c.ComponentConfig.Generic.LeaderElection.RetryPeriod.Duration,</span><br><span class="line">		Callbacks: leaderelection.LeaderCallbacks&#123;</span><br><span class="line">			OnStartedLeading: run,</span><br><span class="line">			OnStoppedLeading: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				klog.Fatalf(<span class="string">"leaderelection lost"</span>)</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		WatchDog: electionChecker,</span><br><span class="line">		Name:     <span class="string">"kube-controller-manager"</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"unreachable"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="StartControllers-在controolermanager-go中"><a href="#StartControllers-在controolermanager-go中" class="headerlink" title="StartControllers,在controolermanager.go中"></a>StartControllers,在controolermanager.go中</h3><ol>
<li>通过传入的ctx和initFunc启动saTokenController</li>
<li>通过传入的ctx和controllers，调用每个controller的initFunc分别对其进行初始化</li>
<li>往mux中添加一些debug的handler</li>
</ol>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StartControllers starts a set of controllers with a specified ControllerContext</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartControllers</span><span class="params">(ctx ControllerContext, startSATokenController InitFunc, controllers <span class="keyword">map</span>[<span class="keyword">string</span>]InitFunc, unsecuredMux *mux.PathRecorderMux)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Always start the SA token controller first using a full-power client, since it needs to mint tokens for the rest</span></span><br><span class="line">	<span class="comment">// If this fails, just return here and fail since other controllers won't be able to get credentials.</span></span><br><span class="line">	<span class="keyword">if</span> _, _, err := startSATokenController(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the cloud provider with a reference to the clientBuilder only after token controller</span></span><br><span class="line">	<span class="comment">// has started in case the cloud provider uses the client builder.</span></span><br><span class="line">	<span class="keyword">if</span> ctx.Cloud != <span class="literal">nil</span> &#123;</span><br><span class="line">		ctx.Cloud.Initialize(ctx.ClientBuilder, ctx.Stop)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> controllerName, initFn := <span class="keyword">range</span> controllers &#123;</span><br><span class="line">		<span class="keyword">if</span> !ctx.IsControllerEnabled(controllerName) &#123;</span><br><span class="line">			klog.Warningf(<span class="string">"%q is disabled"</span>, controllerName)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		time.Sleep(wait.Jitter(ctx.ComponentConfig.Generic.ControllerStartInterval.Duration, ControllerStartJitter))</span><br><span class="line"></span><br><span class="line">		klog.V(<span class="number">1</span>).Infof(<span class="string">"Starting %q"</span>, controllerName)</span><br><span class="line">		debugHandler, started, err := initFn(ctx)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.Errorf(<span class="string">"Error starting %q"</span>, controllerName)</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !started &#123;</span><br><span class="line">			klog.Warningf(<span class="string">"Skipping %q"</span>, controllerName)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> debugHandler != <span class="literal">nil</span> &amp;&amp; unsecuredMux != <span class="literal">nil</span> &#123;</span><br><span class="line">			basePath := <span class="string">"/debug/controllers/"</span> + controllerName</span><br><span class="line">			unsecuredMux.UnlistedHandle(basePath, http.StripPrefix(basePath, debugHandler))</span><br><span class="line">			unsecuredMux.UnlistedHandlePrefix(basePath+<span class="string">"/"</span>, http.StripPrefix(basePath, debugHandler))</span><br><span class="line">		&#125;</span><br><span class="line">		klog.Infof(<span class="string">"Started %q"</span>, controllerName)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NewControllerInitializers-在controllermanager-go中"><a href="#NewControllerInitializers-在controllermanager-go中" class="headerlink" title="NewControllerInitializers,在controllermanager.go中"></a>NewControllerInitializers,在controllermanager.go中</h3><p>此处定义了每个controller的初始化方法，其内容大同小异，所以2.6选取比较简单的namespace进行分析</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewControllerInitializers is a public map of named controller groups (you can start more than one in an init func)</span></span><br><span class="line"><span class="comment">// paired to their InitFunc.  This allows for structured downstream composition and subdivision.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControllerInitializers</span><span class="params">(loopMode ControllerLoopMode)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">InitFunc</span></span> &#123;</span><br><span class="line">	controllers := <span class="keyword">map</span>[<span class="keyword">string</span>]InitFunc&#123;&#125;</span><br><span class="line">	controllers[<span class="string">"endpoint"</span>] = startEndpointController</span><br><span class="line">	controllers[<span class="string">"endpointslice"</span>] = startEndpointSliceController</span><br><span class="line">	controllers[<span class="string">"replicationcontroller"</span>] = startReplicationController</span><br><span class="line">	controllers[<span class="string">"podgc"</span>] = startPodGCController</span><br><span class="line">	controllers[<span class="string">"resourcequota"</span>] = startResourceQuotaController</span><br><span class="line">	controllers[<span class="string">"namespace"</span>] = startNamespaceController</span><br><span class="line">	controllers[<span class="string">"serviceaccount"</span>] = startServiceAccountController</span><br><span class="line">	controllers[<span class="string">"garbagecollector"</span>] = startGarbageCollectorController</span><br><span class="line">	controllers[<span class="string">"daemonset"</span>] = startDaemonSetController</span><br><span class="line">	controllers[<span class="string">"job"</span>] = startJobController</span><br><span class="line">	controllers[<span class="string">"deployment"</span>] = startDeploymentController</span><br><span class="line">	controllers[<span class="string">"replicaset"</span>] = startReplicaSetController</span><br><span class="line">	controllers[<span class="string">"horizontalpodautoscaling"</span>] = startHPAController</span><br><span class="line">	controllers[<span class="string">"disruption"</span>] = startDisruptionController</span><br><span class="line">	controllers[<span class="string">"statefulset"</span>] = startStatefulSetController</span><br><span class="line">	controllers[<span class="string">"cronjob"</span>] = startCronJobController</span><br><span class="line">	controllers[<span class="string">"csrsigning"</span>] = startCSRSigningController</span><br><span class="line">	controllers[<span class="string">"csrapproving"</span>] = startCSRApprovingController</span><br><span class="line">	controllers[<span class="string">"csrcleaner"</span>] = startCSRCleanerController</span><br><span class="line">	controllers[<span class="string">"ttl"</span>] = startTTLController</span><br><span class="line">	controllers[<span class="string">"bootstrapsigner"</span>] = startBootstrapSignerController</span><br><span class="line">	controllers[<span class="string">"tokencleaner"</span>] = startTokenCleanerController</span><br><span class="line">	controllers[<span class="string">"nodeipam"</span>] = startNodeIpamController</span><br><span class="line">	controllers[<span class="string">"nodelifecycle"</span>] = startNodeLifecycleController</span><br><span class="line">	<span class="keyword">if</span> loopMode == IncludeCloudLoops &#123;</span><br><span class="line">		controllers[<span class="string">"service"</span>] = startServiceController</span><br><span class="line">		controllers[<span class="string">"route"</span>] = startRouteController</span><br><span class="line">		controllers[<span class="string">"cloud-node-lifecycle"</span>] = startCloudNodeLifecycleController</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> volume controller into the IncludeCloudLoops only set.</span></span><br><span class="line">	&#125;</span><br><span class="line">	controllers[<span class="string">"persistentvolume-binder"</span>] = startPersistentVolumeBinderController</span><br><span class="line">	controllers[<span class="string">"attachdetach"</span>] = startAttachDetachController</span><br><span class="line">	controllers[<span class="string">"persistentvolume-expander"</span>] = startVolumeExpandController</span><br><span class="line">	controllers[<span class="string">"clusterrole-aggregation"</span>] = startClusterRoleAggregrationController</span><br><span class="line">	controllers[<span class="string">"pvc-protection"</span>] = startPVCProtectionController</span><br><span class="line">	controllers[<span class="string">"pv-protection"</span>] = startPVProtectionController</span><br><span class="line">	controllers[<span class="string">"ttl-after-finished"</span>] = startTTLAfterFinishedController</span><br><span class="line">	controllers[<span class="string">"root-ca-cert-publisher"</span>] = startRootCACertPublisher</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> controllers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="startNamespaceController-在core-go中"><a href="#startNamespaceController-在core-go中" class="headerlink" title="startNamespaceController,在core.go中"></a>startNamespaceController,在core.go中</h3><ol>
<li>startNamespaceController初始化了用于namespace-controller的client(就是一个访问apiserver的kube-client实例，设置了UserAgent)，然后调用startModifiedNamespaceController</li>
<li>startModifiedNamespaceController中初始化了真正的namespace控制器，然后起了一个goroutine去管理namespace</li>
<li>启用多个goroutine（缺省为10个），每个goroutine中一个worker处理具体逻辑</li>
<li>worker中最外围是一个loop，循环往复地执行处理逻辑<ol>
<li>尝试从队列中获取一个key</li>
<li>根据这个key尝试同步namespace信息:syncNamespaceFromKey；由于namespace的操作只有delete（在enqueueNamespace这个方法中删除了除delete namespace外的其他操作）了，所以此处的同步即从apiserver中删除key对应的namespace，具体代码在<code>func (d *namespacedResourcesDeleter) deleteAllContent(ns *v1.Namespace) (int64, error)</code></li>
<li>如果成功，从队列中删除这个key并返回</li>
<li>如果不成功，判断是什么类型的错误<ol>
<li>如果是deletion.ResourcesRemainingError（namespace下还有其他资源），则在一段时间后加入队列</li>
<li>如果不是，则直接将key重新加入队列</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startNamespaceController</span><span class="params">(ctx ControllerContext)</span> <span class="params">(http.Handler, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// the namespace cleanup controller is very chatty.  It makes lots of discovery calls and then it makes lots of delete calls</span></span><br><span class="line">	<span class="comment">// the ratelimiter negatively affects its speed.  Deleting 100 total items in a namespace (that's only a few of each resource</span></span><br><span class="line">	<span class="comment">// including events), takes ~10 seconds by default.</span></span><br><span class="line">	nsKubeconfig := ctx.ClientBuilder.ConfigOrDie(<span class="string">"namespace-controller"</span>)</span><br><span class="line">	nsKubeconfig.QPS *= <span class="number">20</span></span><br><span class="line">	nsKubeconfig.Burst *= <span class="number">100</span></span><br><span class="line">	namespaceKubeClient := clientset.NewForConfigOrDie(nsKubeconfig)</span><br><span class="line">	<span class="keyword">return</span> startModifiedNamespaceController(ctx, namespaceKubeClient, nsKubeconfig)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startModifiedNamespaceController</span><span class="params">(ctx ControllerContext, namespaceKubeClient clientset.Interface, nsKubeconfig *restclient.Config)</span> <span class="params">(http.Handler, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	metadataClient, err := metadata.NewForConfig(nsKubeconfig)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	discoverResourcesFn := namespaceKubeClient.Discovery().ServerPreferredNamespacedResources</span><br><span class="line"></span><br><span class="line">	namespaceController := namespacecontroller.NewNamespaceController(</span><br><span class="line">		namespaceKubeClient,</span><br><span class="line">		metadataClient,</span><br><span class="line">		discoverResourcesFn,</span><br><span class="line">		ctx.InformerFactory.Core().V1().Namespaces(),</span><br><span class="line">		ctx.ComponentConfig.NamespaceController.NamespaceSyncPeriod.Duration,</span><br><span class="line">		v1.FinalizerKubernetes,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">go</span> namespaceController.Run(<span class="keyword">int</span>(ctx.ComponentConfig.NamespaceController.ConcurrentNamespaceSyncs), ctx.Stop)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到<code>namespace_controller.go</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run starts observing the system with the specified number of workers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nm *NamespaceController)</span> <span class="title">Run</span><span class="params">(workers <span class="keyword">int</span>, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line">	<span class="keyword">defer</span> nm.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">	klog.Infof(<span class="string">"Starting namespace controller"</span>)</span><br><span class="line">	<span class="keyword">defer</span> klog.Infof(<span class="string">"Shutting down namespace controller"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !cache.WaitForNamedCacheSync(<span class="string">"namespace"</span>, stopCh, nm.listerSynced) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	klog.V(<span class="number">5</span>).Info(<span class="string">"Starting workers of namespace controller"</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> wait.Until(nm.worker, time.Second, stopCh)</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;-stopCh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker processes the queue of namespace objects.</span></span><br><span class="line"><span class="comment">// Each namespace can be in the queue at most once.</span></span><br><span class="line"><span class="comment">// The system ensures that no two workers can process</span></span><br><span class="line"><span class="comment">// the same namespace at the same time.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nm *NamespaceController)</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line">	workFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		key, quit := nm.queue.Get()</span><br><span class="line">		<span class="keyword">if</span> quit &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> nm.queue.Done(key)</span><br><span class="line"></span><br><span class="line">		err := nm.syncNamespaceFromKey(key.(<span class="keyword">string</span>))</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// no error, forget this entry and return</span></span><br><span class="line">			nm.queue.Forget(key)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> estimate, ok := err.(*deletion.ResourcesRemainingError); ok &#123;</span><br><span class="line">			t := estimate.Estimate/<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">			klog.V(<span class="number">4</span>).Infof(<span class="string">"Content remaining in namespace %s, waiting %d seconds"</span>, key, t)</span><br><span class="line">			nm.queue.AddAfter(key, time.Duration(t)*time.Second)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// rather than wait for a full resync, re-add the namespace to the queue to be processed</span></span><br><span class="line">			nm.queue.AddRateLimited(key)</span><br><span class="line">			utilruntime.HandleError(fmt.Errorf(<span class="string">"deletion of namespace %v failed: %v"</span>, key, err))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		quit := workFunc()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> quit &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参见client-go的例子"><a href="#参见client-go的例子" class="headerlink" title="参见client-go的例子"></a>参见client-go的例子</h3><p>官方提供的一个client使用workqueue的例子很好地描述了controller的大致实现，可以作为一个非常标准的模板用于参考。</p>
<p><code>https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go</code></p>
<blockquote><p>同步自 <a href="https://github.com/pangsq/read_code_of_k8s/blob/master/controller-manager-entry.md" target="_blank" rel="noopener">https://github.com/pangsq/read_code_of_k8s/blob/master/controller-manager-entry.md</a></p>
</blockquote></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/01/gin_router_2/index/">Gin路由分析（二）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Gin/">Gin</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Golang/">Golang</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Gin/">Gin</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Router/">Router</a></span><div class="content"><blockquote>
<p>The fastest full-featured web framework for Go.</p>
</blockquote>
<blockquote>
<p>Radix tree based routing, small memory foot print. No reflection. Predictable API performance.</p>
</blockquote>
<p>官方声称Gin是最快的功能完整的Go web框架，本文研究下其实现细节。</p>
<h2 id="路由的注册"><a href="#路由的注册" class="headerlink" title="路由的注册"></a>路由的注册</h2><p>前一篇文章分析中已知handler最终落到<code>group.engine.addRoute(httpMethod, absolutePath, handlers)</code>，所以本文从addRoute开始分析。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span> <span class="title">addRoute</span><span class="params">(method, path <span class="keyword">string</span>, handlers HandlersChain)</span></span> &#123;</span><br><span class="line">	... <span class="comment">// 1. 参数检查与打印一些调试信息</span></span><br><span class="line">	root := engine.trees.get(method)</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="comment">// 2. 惰性创建相关method的root node</span></span><br><span class="line">		root = <span class="built_in">new</span>(node)</span><br><span class="line">		root.fullPath = <span class="string">"/"</span></span><br><span class="line">		engine.trees = <span class="built_in">append</span>(engine.trees, methodTree&#123;method: method, root: root&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 3. 往root node中注册handlers</span></span><br><span class="line">	root.addRoute(path, handlers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这段代码中我们还知道这么几件事：</p>
<ol>
<li>path -&gt; handlers的映射关系维护在tree(node)中</li>
<li>每个method一个独立的tree</li>
<li>从命名上我们可以大致猜测出这就是个树形结构</li>
</ol>
<p>在更深入实现细节前，先回顾下<code>路由参数</code>的概念。</p>
<p>url路径中存在两种通配符。<code>:</code>可以匹配一段路径，<code>*</code>可以匹配0或n段路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.) path &#x3D; &#x2F;user&#x2F;:name  </span><br><span class="line"></span><br><span class="line">此handler会匹配 &#x2F;user&#x2F;john 但不会匹配 &#x2F;user&#x2F; 或者 &#x2F;user</span><br><span class="line"></span><br><span class="line">2.) path &#x3D; &#x2F;user&#x2F;:name&#x2F;*action</span><br><span class="line">此 handler 将匹配 &#x2F;user&#x2F;john&#x2F; 和 &#x2F;user&#x2F;john&#x2F;send</span><br><span class="line">如果没有其他路由匹配 &#x2F;user&#x2F;john，它将重定向到 &#x2F;user&#x2F;john&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><p>再来看看node的数据结构。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	path      <span class="keyword">string</span>	<span class="comment">// 当前节点path，一段或多段segment，例如 /a/b，/:param等等</span></span><br><span class="line">	indices   <span class="keyword">string</span>	<span class="comment">// 索引，存储子节点的首字符</span></span><br><span class="line">	children  []*node	<span class="comment">// 子节点</span></span><br><span class="line">	handlers  HandlersChain	<span class="comment">// handlers方法</span></span><br><span class="line">	priority  <span class="keyword">uint32</span>	<span class="comment">// 路径包含该节点的handler数量，即路由经由该节点的handler数</span></span><br><span class="line">	nType     nodeType	<span class="comment">// 节点类型</span></span><br><span class="line">	maxParams <span class="keyword">uint8</span>		<span class="comment">// 该节点之后的路径参数个数</span></span><br><span class="line">	wildChild <span class="keyword">bool</span>		<span class="comment">// child是否为通配符，若true，则其child的path就带:或*</span></span><br><span class="line">	fullPath  <span class="keyword">string</span>	<span class="comment">// 完整路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点类型</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	static nodeType = <span class="literal">iota</span> <span class="comment">// default // 普通节点，不含路径参数</span></span><br><span class="line">	root	<span class="comment">// 根节点</span></span><br><span class="line">	param	<span class="comment">// 路径参数节点，通配符:代表的节点</span></span><br><span class="line">	catchAll	<span class="comment">// 通配符*代表的节点</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>此外还有几个结构体要注意，先列出来：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Param <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key   <span class="keyword">string</span></span><br><span class="line">	Value <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Params []Param</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> methodTree <span class="keyword">struct</span> &#123;</span><br><span class="line">	method <span class="keyword">string</span></span><br><span class="line">	root   *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> methodTrees []methodTree</span><br></pre></td></tr></table></figure>

<h4 id="node-addRoute"><a href="#node-addRoute" class="headerlink" title="node.addRoute"></a>node.addRoute</h4><p>分析下engine.addRoute最终调用的node.addRoute方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">addRoute</span><span class="params">(path <span class="keyword">string</span>, handlers HandlersChain)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注意：随着代码的进行，n可能指向不同的对象，path也在不断地缩短，handlers保持不变</span></span><br><span class="line">	fullPath := path</span><br><span class="line">	n.priority++</span><br><span class="line">	numParams := countParams(path)	<span class="comment">// 计算路径参数个数，即path中:和*的个数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前节点没有设置path和children，则只可能是root节点，直接调用insertChild（见下一小节）</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(n.path) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(n.children) == <span class="number">0</span> &#123;</span><br><span class="line">		n.insertChild(numParams, path, fullPath, handlers)</span><br><span class="line">		n.nType = root</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	parentFullPathIndex := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">walk:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Update maxParams of the current node</span></span><br><span class="line">		<span class="keyword">if</span> numParams &gt; n.maxParams &#123;</span><br><span class="line">			n.maxParams = numParams</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 找到path和当前node.path的最长前缀；其中不可能包含:或*</span></span><br><span class="line">		i := longestCommonPrefix(path, n.path)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Split edge</span></span><br><span class="line">		<span class="comment">// node.path并不是path的前缀，h则进行对node的拆分</span></span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(n.path) &#123;</span><br><span class="line">			child := node&#123;	<span class="comment">// 新节点继承了原节点的一切</span></span><br><span class="line">				path:      n.path[i:],	<span class="comment">// 公共前缀之后的路径</span></span><br><span class="line">				wildChild: n.wildChild,</span><br><span class="line">				indices:   n.indices,</span><br><span class="line">				children:  n.children,</span><br><span class="line">				handlers:  n.handlers,</span><br><span class="line">				priority:  n.priority - <span class="number">1</span>,	<span class="comment">// 新节点权重减小</span></span><br><span class="line">				fullPath:  n.fullPath,</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Update maxParams (max of all children)</span></span><br><span class="line">			<span class="keyword">for</span> _, v := <span class="keyword">range</span> child.children &#123;</span><br><span class="line">				<span class="keyword">if</span> v.maxParams &gt; child.maxParams &#123;</span><br><span class="line">					child.maxParams = v.maxParams</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			n.children = []*node&#123;&amp;child&#125;	<span class="comment">// node的子节点只有刚创建的节点</span></span><br><span class="line">			<span class="comment">// []byte for proper unicode char conversion, see #65</span></span><br><span class="line">			n.indices = <span class="keyword">string</span>([]<span class="keyword">byte</span>&#123;n.path[i]&#125;)</span><br><span class="line">			n.path = path[:i] <span class="comment">// node的path被截断</span></span><br><span class="line">			n.handlers = <span class="literal">nil</span>	<span class="comment">// 注册的handlers被置为空</span></span><br><span class="line">			n.wildChild = <span class="literal">false</span></span><br><span class="line">			n.fullPath = fullPath[:parentFullPathIndex+i] <span class="comment">// fullPath被截断</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Make new node a child of this node</span></span><br><span class="line">		<span class="comment">// path并不是node.path的前缀，需要在当前node之后挂新的child</span></span><br><span class="line">		<span class="comment">// 由于此前已经截断过node.path，所以此处判断的前提是node.path必然已是path的前缀</span></span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(path) &#123;</span><br><span class="line">			path = path[i:]	<span class="comment">// 去除与node.path的公共前缀，剩下的path才是需要处理的</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> n.wildChild &#123;	<span class="comment">// 通过阅读node.insertChild，可知wildChild节点之后的节点必然是通配符节点</span></span><br><span class="line">				parentFullPathIndex += <span class="built_in">len</span>(n.path)</span><br><span class="line">				n = n.children[<span class="number">0</span>]	<span class="comment">// 通配符节点</span></span><br><span class="line">				n.priority++</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Update maxParams of the child node</span></span><br><span class="line">				<span class="keyword">if</span> numParams &gt; n.maxParams &#123;</span><br><span class="line">					n.maxParams = numParams</span><br><span class="line">				&#125;</span><br><span class="line">				numParams--	<span class="comment">// 由于当前节点为wildChild则表示下一个节点必然是通配符节点，numParams可先减1</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// Check if the wildcard matches</span></span><br><span class="line">				<span class="comment">// 判断n.path是当前path的前缀</span></span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(path) &gt;= <span class="built_in">len</span>(n.path) &amp;&amp; n.path == path[:<span class="built_in">len</span>(n.path)] &#123;</span><br><span class="line">					<span class="comment">// check for longer wildcard, e.g. :name and :names</span></span><br><span class="line">					<span class="comment">// len(n.path)&gt;=len(path)结合上一判断条件，代表n.path完全等于path</span></span><br><span class="line">					<span class="comment">// 或者path是n.path头部的一或n个segemt</span></span><br><span class="line">					<span class="keyword">if</span> <span class="built_in">len</span>(n.path) &gt;= <span class="built_in">len</span>(path) || path[<span class="built_in">len</span>(n.path)] == <span class="string">'/'</span> &#123;</span><br><span class="line">						<span class="comment">// 例如：</span></span><br><span class="line">						<span class="comment">// path=:a和n.path=:a能够match</span></span><br><span class="line">						<span class="comment">// path=:a/a和n.path=:a能够match</span></span><br><span class="line">						<span class="comment">// path=:aa和n.path=:a不能match</span></span><br><span class="line">						<span class="comment">// path=:a和n.path=:aa不能match</span></span><br><span class="line">						<span class="keyword">continue</span> walk</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 若不能匹配，将会panic</span></span><br><span class="line">			</span><br><span class="line">				...</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 经过之前的处理，目前的情况如下</span></span><br><span class="line">			<span class="comment">// 1. node.path与（此时的）path已无交集</span></span><br><span class="line">			<span class="comment">// 2. node非wildChild</span></span><br><span class="line">			<span class="comment">// 接下来要做的就是基于剩下的path构建新节点，注册为node的child</span></span><br><span class="line"></span><br><span class="line">			c := path[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">			<span class="comment">// slash after param</span></span><br><span class="line">			<span class="comment">// param节点之后还存在节点的情况下，此时c == '/'表示当前path并不以通配符起始，取子节点代替node，直接进入下一轮</span></span><br><span class="line">			<span class="keyword">if</span> n.nType == param &amp;&amp; c == <span class="string">'/'</span> &amp;&amp; <span class="built_in">len</span>(n.children) == <span class="number">1</span> &#123;</span><br><span class="line">				parentFullPathIndex += <span class="built_in">len</span>(n.path)</span><br><span class="line">				n = n.children[<span class="number">0</span>]</span><br><span class="line">				n.priority++</span><br><span class="line">				<span class="keyword">continue</span> walk</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check if a child with the next path byte exists</span></span><br><span class="line">			<span class="comment">// 遍历indices，找到与c匹配的child，修改所有child的权重</span></span><br><span class="line">			<span class="comment">// 将node置为匹配的child，进入下一轮</span></span><br><span class="line">			<span class="keyword">for</span> i, max := <span class="number">0</span>, <span class="built_in">len</span>(n.indices); i &lt; max; i++ &#123;</span><br><span class="line">				<span class="keyword">if</span> c == n.indices[i] &#123;</span><br><span class="line">					parentFullPathIndex += <span class="built_in">len</span>(n.path)</span><br><span class="line">					i = n.incrementChildPrio(i)</span><br><span class="line">					n = n.children[i]</span><br><span class="line">					<span class="keyword">continue</span> walk</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Otherwise insert it</span></span><br><span class="line">			<span class="comment">// 没有任何一个child的path和当前的path有公共前缀，且c非通配符的情况下</span></span><br><span class="line">			<span class="keyword">if</span> c != <span class="string">':'</span> &amp;&amp; c != <span class="string">'*'</span> &#123;</span><br><span class="line">				<span class="comment">// []byte for proper unicode char conversion, see #65</span></span><br><span class="line">				n.indices += <span class="keyword">string</span>([]<span class="keyword">byte</span>&#123;c&#125;)</span><br><span class="line">				<span class="comment">// 创建一个全新的节点，加入到node的children中，并调整所有之前已存在的child的权重</span></span><br><span class="line">				child := &amp;node&#123;</span><br><span class="line">					maxParams: numParams,</span><br><span class="line">					fullPath:  fullPath,</span><br><span class="line">				&#125;</span><br><span class="line">				n.children = <span class="built_in">append</span>(n.children, child)</span><br><span class="line">				n.incrementChildPrio(<span class="built_in">len</span>(n.indices) - <span class="number">1</span>)</span><br><span class="line">				n = child</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 调用insertChild完成节点的注册</span></span><br><span class="line">			n.insertChild(numParams, path, fullPath, handlers)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Otherwise and handle to current node</span></span><br><span class="line">		<span class="keyword">if</span> n.handlers != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"handlers are already registered for path '"</span> + fullPath + <span class="string">"'"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 此时node.path == path</span></span><br><span class="line">		n.handlers = handlers</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要流程：</p>
<ol>
<li>如果是root节点，直接调用insertChild</li>
<li>非root节点时，进入walk loop<ol>
<li>计算当前node.path和path的公共前缀</li>
<li>假设node.path并不是path的前缀<ol>
<li>新建一个节点，将原节点的一系列数据转移过去</li>
<li>原节点的path置为计算出的公共前缀，将其他信息重置</li>
<li>node指向新节点</li>
</ol>
</li>
<li>经过一番处理，此时的node.path必然已是path的前缀<ol>
<li>当node.path与path不相等时（node.path是path的前缀，但不是完整的path）<ol>
<li>path减去前缀node.path部分</li>
<li>如果当前node是wildChild<ol>
<li>node直接指向其child</li>
<li>确保当前path不会与node.path产生冲突</li>
<li>直接进入下一轮</li>
</ol>
</li>
<li>如果当前node为param节点，且存在child，而且path以/起始。以child替换node，进入下一轮</li>
<li>遍历indices，寻找与c匹配的indice。若找到则调整所有child的权重，并以匹配的child替换node，进入下一轮</li>
<li>如果当前node的所有child的path都和当前path无公共前缀，则往node的children中添加新节点，node指向新节点</li>
<li>调用insertChild</li>
</ol>
</li>
<li>当node.path与path完全相等时，直接往node上注册handlers</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="node-insertChild"><a href="#node-insertChild" class="headerlink" title="node.insertChild"></a>node.insertChild</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">insertChild</span><span class="params">(numParams <span class="keyword">uint8</span>, path <span class="keyword">string</span>, fullPath <span class="keyword">string</span>, handlers HandlersChain)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注意：n指向的对象在下面的代码中可能会不断变化，path会不断缩短，fullPath/handlers会保持不变</span></span><br><span class="line">	<span class="keyword">for</span> numParams &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Find prefix until first wildcard</span></span><br><span class="line">		wildcard, i, valid := findWildcard(path) <span class="comment">// 找到第一个通配符，返回该通配符的segment和其位置，并检验是否合法（通配符后接/或处于path末尾是合法的，即不存在两个连续的通配符）</span></span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="number">0</span> &#123; <span class="comment">// No wildcard found // 当前path中已不存在通配符的情况下跳出循环；在整个for循环中，path的长度会不断减少</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		... </span><br><span class="line">		<span class="comment">// 进行检查 确保满足：</span></span><br><span class="line">		<span class="comment">// 1. path中通配符合法，即一个segment只存在一个:或*</span></span><br><span class="line">		<span class="comment">// 2. 路径参数必须有一个名字，所以该segment长度必须大于1</span></span><br><span class="line">		<span class="comment">// 3. node不允许已存在child</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> wildcard[<span class="number">0</span>] == <span class="string">':'</span> &#123; <span class="comment">// param // 当前path的第一个segment是通配符:</span></span><br><span class="line">			<span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// 设置parent的path，这是一段不含任何通配符的path</span></span><br><span class="line">				n.path = path[:i]</span><br><span class="line">				<span class="comment">// 从通配符开始的剩余path</span></span><br><span class="line">				path = path[i:]</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			n.wildChild = <span class="literal">true</span> <span class="comment">// 指明是通配符节点</span></span><br><span class="line">			child := &amp;node&#123;		<span class="comment">// 创建新节点</span></span><br><span class="line">				nType:     param,     <span class="comment">// 节点类型</span></span><br><span class="line">				path:      wildcard,  <span class="comment">// 当前节点的path，由于是wildcard，实则就是一段segment</span></span><br><span class="line">				maxParams: numParams, <span class="comment">// 从当前节点往后（递归遍历其child）存在多少个param</span></span><br><span class="line">				fullPath:  fullPath, <span class="comment">// handler的完整路径，后续搜索时可以根据这个判断，node是否可对应handler</span></span><br><span class="line">			&#125;</span><br><span class="line">			n.children = []*node&#123;child&#125; <span class="comment">// 将创建的节点注册为父亲节点的child</span></span><br><span class="line">			n = child		<span class="comment">// 之后若继续处理，则以刚创建的child为父亲节点</span></span><br><span class="line">			n.priority++	<span class="comment">// 即将刚创建的child的priority设置为1</span></span><br><span class="line">			numParams--		<span class="comment">// 剩余路径参数减少</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果当前处理的segment不是最后一段，那么为剩余的path创建新的子节点，进入下一轮</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(wildcard) &lt; <span class="built_in">len</span>(path) &#123;</span><br><span class="line">				path = path[<span class="built_in">len</span>(wildcard):]</span><br><span class="line"></span><br><span class="line">				child := &amp;node&#123;</span><br><span class="line">					maxParams: numParams,</span><br><span class="line">					priority:  <span class="number">1</span>,</span><br><span class="line">					fullPath:  fullPath,</span><br><span class="line">				&#125;</span><br><span class="line">				n.children = []*node&#123;child&#125;</span><br><span class="line">				n = child</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 直到path不再有剩余，设置handlers并结束</span></span><br><span class="line">			n.handlers = handlers</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 排除当前第一个segment是通配符:的情况，剩下自然是处理*的情况，剩下自然是处理</span></span><br><span class="line">		<span class="comment">// 由于*可以匹配0或n个segment，所以最终只会往parent上注册一个child就可以，而不需要考虑child的child</span></span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 进行检查 确保满足</span></span><br><span class="line">		<span class="comment">// 1. 含*的segment之后没有其他segment；当前path中只存在一个通配符</span></span><br><span class="line">		<span class="comment">// 2. parent的path不以/结尾</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// currently fixed width 1 for '/'</span></span><br><span class="line">		i--</span><br><span class="line">		<span class="keyword">if</span> path[i] != <span class="string">'/'</span> &#123; <span class="comment">// 确保*前是/</span></span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"no / before catch-all in path '"</span> + fullPath + <span class="string">"'"</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		n.path = path[:i]</span><br><span class="line"></span><br><span class="line">		<span class="comment">// First node: catchAll node with empty path</span></span><br><span class="line">		child := &amp;node&#123;</span><br><span class="line">			wildChild: <span class="literal">true</span>,</span><br><span class="line">			nType:     catchAll,</span><br><span class="line">			maxParams: <span class="number">1</span>,</span><br><span class="line">			fullPath:  fullPath,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// update maxParams of the parent node</span></span><br><span class="line">		<span class="keyword">if</span> n.maxParams &lt; <span class="number">1</span> &#123;</span><br><span class="line">			n.maxParams = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		n.children = []*node&#123;child&#125;</span><br><span class="line">		n.indices = <span class="keyword">string</span>(<span class="string">'/'</span>)</span><br><span class="line">		n = child</span><br><span class="line">		n.priority++ <span class="comment">//priority设置为1</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// second node: node holding the variable</span></span><br><span class="line">		child = &amp;node&#123;</span><br><span class="line">			path:      path[i:],</span><br><span class="line">			nType:     catchAll,</span><br><span class="line">			maxParams: <span class="number">1</span>,</span><br><span class="line">			handlers:  handlers,</span><br><span class="line">			priority:  <span class="number">1</span>,</span><br><span class="line">			fullPath:  fullPath,</span><br><span class="line">		&#125;</span><br><span class="line">		n.children = []*node&#123;child&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If no wildcard was found, simply insert the path and handle</span></span><br><span class="line">	n.path = path</span><br><span class="line">	n.handlers = handlers</span><br><span class="line">	n.fullPath = fullPath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要流程：</p>
<ol>
<li>在numParams &gt; 0的情况下，循环处理path中剩余的含通配符的segment<ol>
<li>取出当前path中最前面的通配符segment</li>
<li>如果含通配符:<ol>
<li>如果该segment之前还有静态路径，将node的path设置为该segment之前的静态路径</li>
<li>创建一个param类型的node作为其child</li>
<li>如果该segment还没到path尾部，则再创建一个param类型的node作为child的child，之后处理的node转为这个最新的child</li>
<li>如果该segment已到path尾部，则注册handlers，并结束整个方法</li>
</ol>
</li>
<li>如果含通配符*<ol>
<li>将node的path设置为该segment之前的静态路径（不含/）</li>
<li>创建一个catchAll类型节点，作为node的child</li>
<li>再创建一个catchAll类型节点，作为前一个节点的child，其path为这段segment，handlers注册在这个节点上</li>
<li>结束整个方法</li>
</ol>
</li>
</ol>
</li>
<li>当numParams == 0，即不存在路由参数的情况下，直接设置n.path/handlers/fullPath</li>
</ol>
<h2 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h2><p>存入trees中的router和handlers在什么时候使用？</p>
<p>下方是相应的调用链，不细展开了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(address, engine) -&gt; engine.ServeHTTP(writer, req) -&gt; engine.handleHTTPRequest(c) -&gt; root.getValue(rPath, c.Params, unescape)</span><br></pre></td></tr></table></figure>

<h2 id="路由的检索"><a href="#路由的检索" class="headerlink" title="路由的检索"></a>路由的检索</h2><p>接下来从getValue出发，研究下Gin是怎么根据url定位到相应handlers的。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">getValue</span><span class="params">(path <span class="keyword">string</span>, po Params, unescape <span class="keyword">bool</span>)</span> <span class="params">(value nodeValue)</span></span> &#123;</span><br><span class="line">	value.params = po</span><br><span class="line">walk: <span class="comment">// Outer loop for walking the tree</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		prefix := n.path</span><br><span class="line">		<span class="comment">// path == n.path</span></span><br><span class="line">		<span class="keyword">if</span> path == prefix &#123;</span><br><span class="line">			<span class="comment">// 若node.handlers不为空，则返回注册的handlers</span></span><br><span class="line">			<span class="keyword">if</span> value.handlers = n.handlers; value.handlers != <span class="literal">nil</span> &#123;</span><br><span class="line">				value.fullPath = n.fullPath</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 当path为"/"且wildChild为true时，设置重定向</span></span><br><span class="line">			<span class="keyword">if</span> path == <span class="string">"/"</span> &amp;&amp; n.wildChild &amp;&amp; n.nType != root &#123;</span><br><span class="line">				value.tsr = <span class="literal">true</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果children中某个child的path以/开始，满足以下任一情况时，设置重定向</span></span><br><span class="line">			<span class="comment">// 1. 该child的path就是/，且handlers非nil</span></span><br><span class="line">			<span class="comment">// 2. 该child是catchAll类型，且子child的handlers非nil（这里的逻辑有点不能理解，按前面分析的insertChild方法，树上只有通配符*会产生连续的两个catchAll节点，而第一个catchAll节点的path是空的，不可能满足此处的条件</span></span><br><span class="line">			indices := n.indices</span><br><span class="line">			<span class="keyword">for</span> i, max := <span class="number">0</span>, <span class="built_in">len</span>(indices); i &lt; max; i++ &#123;</span><br><span class="line">				<span class="keyword">if</span> indices[i] == <span class="string">'/'</span> &#123;</span><br><span class="line">					n = n.children[i]</span><br><span class="line">					value.tsr = (<span class="built_in">len</span>(n.path) == <span class="number">1</span> &amp;&amp; n.handlers != <span class="literal">nil</span>) ||</span><br><span class="line">						(n.nType == catchAll &amp;&amp; n.children[<span class="number">0</span>].handlers != <span class="literal">nil</span>)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// node.path是path前缀的情况</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; <span class="built_in">len</span>(prefix) &amp;&amp; path[:<span class="built_in">len</span>(prefix)] == prefix &#123;</span><br><span class="line">			path = path[<span class="built_in">len</span>(prefix):]	<span class="comment">// 截断path</span></span><br><span class="line">			<span class="comment">// 非wildChild的情况，因为wildChild的话，直接处理child即可</span></span><br><span class="line">			<span class="keyword">if</span> !n.wildChild &#123;</span><br><span class="line">				c := path[<span class="number">0</span>]</span><br><span class="line">				indices := n.indices</span><br><span class="line">				<span class="comment">// 根据indices快速（？）寻找匹配的child，进入下一轮</span></span><br><span class="line">				<span class="keyword">for</span> i, max := <span class="number">0</span>, <span class="built_in">len</span>(indices); i &lt; max; i++ &#123;</span><br><span class="line">					<span class="keyword">if</span> c == indices[i] &#123;</span><br><span class="line">						n = n.children[i]</span><br><span class="line">						<span class="keyword">continue</span> walk</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 没有匹配的child的话，如果path为/且当前nodes含handlers，则设置重定向</span></span><br><span class="line">				<span class="comment">// 例如 当前url中是 /a/b/c/，而注册在案的路由只有 /a/b/c，那么就可以顺利地进行重定向</span></span><br><span class="line">				value.tsr = path == <span class="string">"/"</span> &amp;&amp; n.handlers != <span class="literal">nil</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 对于wildChild，直接处理其child</span></span><br><span class="line">			n = n.children[<span class="number">0</span>]</span><br><span class="line">			<span class="keyword">switch</span> n.nType &#123;</span><br><span class="line">			<span class="keyword">case</span> param:</span><br><span class="line">				<span class="comment">// 找到:能匹配到的一段segment</span></span><br><span class="line">				end := <span class="number">0</span></span><br><span class="line">				<span class="keyword">for</span> end &lt; <span class="built_in">len</span>(path) &amp;&amp; path[end] != <span class="string">'/'</span> &#123;</span><br><span class="line">					end++</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 扩容params，达到必然满足要求的最小容量</span></span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">cap</span>(value.params) &lt; <span class="keyword">int</span>(n.maxParams) &#123;</span><br><span class="line">					value.params = <span class="built_in">make</span>(Params, <span class="number">0</span>, n.maxParams)</span><br><span class="line">				&#125;</span><br><span class="line">				i := <span class="built_in">len</span>(value.params)</span><br><span class="line">				value.params = value.params[:i+<span class="number">1</span>] <span class="comment">// expand slice within preallocated capacity</span></span><br><span class="line">				<span class="comment">// param的键</span></span><br><span class="line">				value.params[i].Key = n.path[<span class="number">1</span>:]</span><br><span class="line">				<span class="comment">// 从path中获取param对应的值</span></span><br><span class="line">				val := path[:end]</span><br><span class="line">				<span class="comment">// 转义</span></span><br><span class="line">				<span class="keyword">if</span> unescape &#123;</span><br><span class="line">					<span class="keyword">var</span> err error</span><br><span class="line">					<span class="keyword">if</span> value.params[i].Value, err = url.QueryUnescape(val); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						value.params[i].Value = val <span class="comment">// fallback, in case of error</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					value.params[i].Value = val</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 由上面逻辑可知，params与path中实际的路由参数组是逆序的</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// 还未到path末尾的话，则截断path，node指向child，继续</span></span><br><span class="line">				<span class="keyword">if</span> end &lt; <span class="built_in">len</span>(path) &#123;</span><br><span class="line">					<span class="keyword">if</span> <span class="built_in">len</span>(n.children) &gt; <span class="number">0</span> &#123;</span><br><span class="line">						path = path[end:]</span><br><span class="line">						n = n.children[<span class="number">0</span>]</span><br><span class="line">						<span class="keyword">continue</span> walk</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 如果没有children可用了，则重定向</span></span><br><span class="line">					value.tsr = <span class="built_in">len</span>(path) == end+<span class="number">1</span></span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> value.handlers = n.handlers; value.handlers != <span class="literal">nil</span> &#123;</span><br><span class="line">					value.fullPath = n.fullPath</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(n.children) == <span class="number">1</span> &#123;</span><br><span class="line">					<span class="comment">// 重定向</span></span><br><span class="line">					n = n.children[<span class="number">0</span>]</span><br><span class="line">					value.tsr = n.path == <span class="string">"/"</span> &amp;&amp; n.handlers != <span class="literal">nil</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="comment">// 直接将路由参数匹配完剩下的path</span></span><br><span class="line">			<span class="keyword">case</span> catchAll:</span><br><span class="line">				<span class="comment">// save param value</span></span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">cap</span>(value.params) &lt; <span class="keyword">int</span>(n.maxParams) &#123;</span><br><span class="line">					value.params = <span class="built_in">make</span>(Params, <span class="number">0</span>, n.maxParams)</span><br><span class="line">				&#125;</span><br><span class="line">				i := <span class="built_in">len</span>(value.params)</span><br><span class="line">				value.params = value.params[:i+<span class="number">1</span>] <span class="comment">// expand slice within preallocated capacity</span></span><br><span class="line">				value.params[i].Key = n.path[<span class="number">2</span>:]</span><br><span class="line">				<span class="keyword">if</span> unescape &#123;</span><br><span class="line">					<span class="keyword">var</span> err error</span><br><span class="line">					<span class="keyword">if</span> value.params[i].Value, err = url.QueryUnescape(path); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						value.params[i].Value = path <span class="comment">// fallback, in case of error</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					value.params[i].Value = path</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				value.handlers = n.handlers</span><br><span class="line">				value.fullPath = n.fullPath</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">"invalid node type"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 重定向</span></span><br><span class="line">		value.tsr = (path == <span class="string">"/"</span>) ||</span><br><span class="line">			(<span class="built_in">len</span>(prefix) == <span class="built_in">len</span>(path)+<span class="number">1</span> &amp;&amp; prefix[<span class="built_in">len</span>(path)] == <span class="string">'/'</span> &amp;&amp;</span><br><span class="line">				path == prefix[:<span class="built_in">len</span>(prefix)<span class="number">-1</span>] &amp;&amp; n.handlers != <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本阅读完了Gin的router模块（<a href="https://github.com/julienschmidt/httprouter" target="_blank" rel="noopener">https://github.com/julienschmidt/httprouter</a> 也就是这个项目），其对于radix的处理逻辑有点复杂，但大致思想我们已可以感受到。</p>
<p>所以Gin为什么快，源于其Radix的实现，令具有公共前缀的路由尽可能地复用相同的节点，使得树的深度尽量浅，以获得高效的查询效率。</p>
<p>举个例子，需要组建如下所示的路由：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">"/ping"</span>, <span class="literal">nil</span>)</span><br><span class="line">r.GET(<span class="string">"/p/*segs"</span>, <span class="literal">nil</span>))</span><br><span class="line">r.GET(<span class="string">"/ping/:seg"</span>, <span class="literal">nil</span>)</span><br><span class="line">r.Group(<span class="string">"/v1"</span>).GET(<span class="string">"/get"</span>))</span><br></pre></td></tr></table></figure>

<p>最终内存中树结构看起来是这样的：</p>
<img src="/2020/05/01/gin_router_2/index/radix.png" width="1000" height="600" align="center">


<h2 id="Gin的不足"><a href="#Gin的不足" class="headerlink" title="Gin的不足"></a>Gin的不足</h2><p>Gin在使用路由参数时依旧存在一些bug，与依赖的httprouter项目一直没修复相关，所以目前还没看到有改进计划，见<a href="https://github.com/gin-gonic/gin/issues/2016" target="_blank" rel="noopener">https://github.com/gin-gonic/gin/issues/2016</a></p>
<p>bug例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1) 同一位值，参数和静态路径冲突</span><br><span class="line">r.GET(&quot;&#x2F;ping&#x2F;:seg&#x2F;1&quot;, nil)</span><br><span class="line">r.GET(&quot;&#x2F;ping&#x2F;seg&#x2F;1&quot;, nil)</span><br><span class="line"></span><br><span class="line">2）同一位置，不同名的参数冲突</span><br><span class="line">r.GET(&quot;&#x2F;ping&#x2F;:seg&#x2F;1&quot;, nil)</span><br><span class="line">r.GET(&quot;&#x2F;ping&#x2F;:se&quot;, nil)</span><br><span class="line">或者</span><br><span class="line">r.GET(&quot;&#x2F;ping&#x2F;:seg&#x2F;1&quot;, nil)</span><br><span class="line">r.GET(&quot;&#x2F;ping&#x2F;:se&#x2F;2&quot;, nil)</span><br></pre></td></tr></table></figure>

<p>这样的bug可以归纳为：路由参数是排他的，一个位置（前缀相同）上只要存在了路由参数，就不能再定义静态路径或其他名字参数了，因为httprouter中并没有给静态路径和路由参数定义优先级…</p>
<p>要避免这个问题，方法也简单，只要遵守两点：</p>
<ol>
<li>不要在同一位置放不同名称的参数</li>
<li>想要在同一位置放参数和静态路径，可以选择统一成路由参数，再通过handler进行分发，示例如下<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//r.GET("/ping/:seg/1", handler1)</span></span><br><span class="line"><span class="comment">//r.GET("/ping/seg/1", handler2)</span></span><br><span class="line">r.GET(<span class="string">"/ping/:seg/1"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	seg := c.Param(<span class="string">"seg"</span>)</span><br><span class="line">	<span class="keyword">if</span> seg == <span class="string">"seg"</span> &#123;</span><br><span class="line">		handler1(c)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		handler2(c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>另外有点不合理的是Gin并没有对HANDLE/GET/POST/Group/Use等方法做非nil的判断，导致只有在request进来的时候才会提示空指针问题。</p>
<blockquote><p>同步自 <a href="https://github.com/pangsq/useGin/blob/master/articles/router_analysis_2.md" target="_blank" rel="noopener">https://github.com/pangsq/useGin/blob/master/articles/router_analysis_2.md</a></p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/01/gin_router_1/index/">Gin路由分析（一）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Gin/">Gin</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Golang/">Golang</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Gin/">Gin</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Router/">Router</a></span><div class="content"><p>Gin是Golang开发的一个Web框架，特点是轻量、高效。</p>
<p>由于Golang本身net/http功能已经很强大且易用，一般小型Web项目用自带的库足矣。</p>
<p>Gin更多地是关注复杂的router逻辑和方便中间件的嵌入（如认证、日志等），以便于团队协作和代码的工程化管理。</p>
<p>本文来分析下Gin的router。</p>
<h2 id="从一个普普通通的Gin使用例子开始"><a href="#从一个普普通通的Gin使用例子开始" class="headerlink" title="从一个普普通通的Gin使用例子开始"></a>从一个普普通通的Gin使用例子开始</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; r :&#x3D; gin.New()</span><br><span class="line">r :&#x3D; gin.Default() &#x2F;&#x2F; Default()会在New的基础上，注入默认的Logger和Recovery两个handler</span><br><span class="line">rg :&#x3D; r.Group(&quot;&#x2F;v1&quot;, middleware1, middleware2) &#x2F;&#x2F; 创建一个RouterGroup，并注册两个middleware</span><br><span class="line">rg1 :&#x3D; rg.Use(middleware2)  &#x2F;&#x2F; 注册一个middlerware</span><br><span class="line">rg1.Handle(http.MethodGet, &quot;&#x2F;ping&quot;, handler1)  &#x2F;&#x2F; 注册一个request handler</span><br><span class="line">r.Run()</span><br></pre></td></tr></table></figure>

<p>先搞明白各种方法（除了Run）的返回类型。</p>
<ol>
<li>Default/New 返回的是 *Engine</li>
<li>Group 返回的是 *RouterGroup</li>
<li>Use 返回的是 IRoutes</li>
<li>Handler 返回的是 IRoutes</li>
</ol>
<h3 id="IRoutes"><a href="#IRoutes" class="headerlink" title="IRoutes"></a>IRoutes</h3><p>首先来看看出现的接口IRoutes，涵盖了各种http handler的注册。</p>
<p>Use用于中间件的注册，Handle是通用的handler注册接口（可以在入参中指定是httpMethod）,Any匹配任意httpMethod，从GET到HEAD是特定httpMethod的handler注册，而StaticFile/Static/StaticFS用于静态资源的注册。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IRoutes <span class="keyword">interface</span> &#123;</span><br><span class="line">	Use(...HandlerFunc) IRoutes</span><br><span class="line"></span><br><span class="line">	Handle(<span class="keyword">string</span>, <span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">	Any(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">	GET(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">	POST(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">	DELETE(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">	PATCH(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">	PUT(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">	OPTIONS(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">	HEAD(<span class="keyword">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line"></span><br><span class="line">	StaticFile(<span class="keyword">string</span>, <span class="keyword">string</span>) IRoutes</span><br><span class="line">	Static(<span class="keyword">string</span>, <span class="keyword">string</span>) IRoutes</span><br><span class="line">	StaticFS(<span class="keyword">string</span>, http.FileSystem) IRoutes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处先引出IRouter接口，下文即将用到。</p>
<p>IRouter比起IRoutes仅多另一个Group方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IRouter <span class="keyword">interface</span> &#123;</span><br><span class="line">	IRoutes</span><br><span class="line">	Group(<span class="keyword">string</span>, ...HandlerFunc) *RouterGroup</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">	RouterGroup</span><br><span class="line"></span><br><span class="line">	... <span class="comment">//其他暂不关心的成员</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> _ IRouter = &amp;Engine&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Engine中与路由相关的是一个RouterGroup。按Golang匿名成员的写法，Engine继承了RouterGroup的方法，我们可以将Engine看做是功能更加丰富的RouterGroup。</p>
<h3 id="RouterGroup"><a href="#RouterGroup" class="headerlink" title="RouterGroup"></a>RouterGroup</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RouterGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	Handlers HandlersChain</span><br><span class="line">	basePath <span class="keyword">string</span></span><br><span class="line">	engine   *Engine</span><br><span class="line">	root     <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ IRouter = &amp;RouterGroup&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>RouterGroup是Gin路由功能的核心组件，它实现了IRouter/IRoutes接口。</p>
<p>在例子中Use/Handler返回的实际也是它，但通过IRoutes接口限制，避免了对Use/Handler结果再调用Group。</p>
<p>RouterGroup的成员：</p>
<ol>
<li>Handlers HandlersChain  // 存放中间件方法的数组。由于中间件（如认证、日志等）本质也是和业务逻辑相同的HandlerFunc，所以最终会在调用业务逻辑的HandlerFunc前先调用这些HandlerFunc</li>
<li>basePath string         // 基础url路径</li>
<li>engine *Engine          // Engine是一个项目中唯一的，所有的RouterGroup都会指向同一个</li>
<li>root bool               // Engine本身也是个RouterGroup，它被认为是root</li>
</ol>
<h2 id="关于RouterGroup的一切"><a href="#关于RouterGroup的一切" class="headerlink" title="关于RouterGroup的一切"></a>关于RouterGroup的一切</h2><p>RouterGroup的设计并不复杂，在routergroup.go中完全实现。</p>
<h3 id="Use-——-中间件的添加"><a href="#Use-——-中间件的添加" class="headerlink" title="Use —— 中间件的添加"></a>Use —— 中间件的添加</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">Use</span><span class="params">(middleware ...HandlerFunc)</span> <span class="title">IRoutes</span></span> &#123;</span><br><span class="line">	group.Handlers = <span class="built_in">append</span>(group.Handlers, middleware...)</span><br><span class="line">	<span class="keyword">return</span> group.returnObj()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将middleware添加到group.Handlers，并返回本身（如果是root，则返回engine）</p>
<h3 id="Group-——-创建子RouterGroup"><a href="#Group-——-创建子RouterGroup" class="headerlink" title="Group —— 创建子RouterGroup"></a>Group —— 创建子RouterGroup</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">Group</span><span class="params">(relativePath <span class="keyword">string</span>, handlers ...HandlerFunc)</span> *<span class="title">RouterGroup</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;RouterGroup&#123;</span><br><span class="line">		Handlers: group.combineHandlers(handlers),</span><br><span class="line">		basePath: group.calculateAbsolutePath(relativePath),</span><br><span class="line">		engine:   group.engine,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>创建新的RouterGroup</li>
<li>新RouterGroup继承此时原RouterGroup的Handlers，并添加新的handlers。<ol>
<li>此后若原RouterGroup继续使用Use添加handler，新RouterGroup的handlers不随之改变</li>
<li>此处的handlers均是middlewares</li>
</ol>
</li>
<li>计算新RouterGroup的basePath</li>
<li>engine依旧指向同一个engine</li>
</ol>
<h3 id="handle-——-注册业务逻辑的handler"><a href="#handle-——-注册业务逻辑的handler" class="headerlink" title="handle —— 注册业务逻辑的handler"></a>handle —— 注册业务逻辑的handler</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">handle</span><span class="params">(httpMethod, relativePath <span class="keyword">string</span>, handlers HandlersChain)</span> <span class="title">IRoutes</span></span> &#123;</span><br><span class="line">	absolutePath := group.calculateAbsolutePath(relativePath)</span><br><span class="line">	handlers = group.combineHandlers(handlers)</span><br><span class="line">	group.engine.addRoute(httpMethod, absolutePath, handlers)</span><br><span class="line">	<span class="keyword">return</span> group.returnObj()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>计算url的绝对路径</li>
<li>计算包含一些列middlewares和最终handler的handlers</li>
<li>调用engine.addRoute将route注册<ol>
<li>此后若group的Handlers有变化，也不对已经注册的这条路由有任何影响</li>
</ol>
</li>
<li>返回group</li>
</ol>
<p>Handle/Any/Get/POST/DELETE/PATCH/PUT/OPTIONS/HEAD/StaticFile/Static/StaticFS的实现均基于handle。</p>
<p>挑一个比较特殊的Any看看</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span> <span class="title">Any</span><span class="params">(relativePath <span class="keyword">string</span>, handlers ...HandlerFunc)</span> <span class="title">IRoutes</span></span> &#123;</span><br><span class="line">	group.handle(http.MethodGet, relativePath, handlers)</span><br><span class="line">	group.handle(http.MethodPost, relativePath, handlers)</span><br><span class="line">	group.handle(http.MethodPut, relativePath, handlers)</span><br><span class="line">	group.handle(http.MethodPatch, relativePath, handlers)</span><br><span class="line">	group.handle(http.MethodHead, relativePath, handlers)</span><br><span class="line">	group.handle(http.MethodOptions, relativePath, handlers)</span><br><span class="line">	group.handle(http.MethodDelete, relativePath, handlers)</span><br><span class="line">	group.handle(http.MethodConnect, relativePath, handlers)</span><br><span class="line">	group.handle(http.MethodTrace, relativePath, handlers)</span><br><span class="line">	<span class="keyword">return</span> group.returnObj()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很直接，将所有的httpMethod都注册。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>通过New/Default创建Engine</li>
<li>Engine/RouterGroup存放basePath和handlers（用于中间件），使用Use可以往handlers中添加新的middleware</li>
<li>基于Engine或RouterGroup可以创建新的RouterGroup，新的RouterGroup继承创建时Engine或RouterGroup的handlers</li>
<li>使用Engine或RouterGroup的Handle/Any/Get/…等方法注册业务用handler，会使用其中包含的handlers（HandlersChain）和basePath</li>
</ol>
<blockquote><p>同步自 <a href="https://github.com/pangsq/useGin/blob/master/articles/router_analysis_1.md" target="_blank" rel="noopener">https://github.com/pangsq/useGin/blob/master/articles/router_analysis_1.md</a></p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/05/01/sharedIndexInformer/index/">Kubernetes运行机制 —— SharedIndexInformer</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Kubernetes/">Kubernetes</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Kubernetes/">Kubernetes</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Golang/">Golang</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Informer/">Informer</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Cache/">Cache</a></span><div class="content"><p>SharedIndexInformer是k8s的client-go中一个功能强大的工具，通过它可以在client端缓存apiserver中的资源实例状态，以提高对整集群管理、调谐的效率。</p>
<p>无论在controller-manager/scheduler等原生组件中还是用kubebuilder编写crd的controller中都会用到它，因此对它内部的实现进行了解是很有必要的。</p>
<p>SharedIndexInformer的运行大致可以表述成：</p>
<ol>
<li>利用ListWatch机制不断从apiserver处获取某一类型的资源实例，存入本地内存中的一个Indexer（带索引和其他丰富接口的缓存）。</li>
<li>并辅以一个Queue（按照先后顺序）对外进行通知（资源实例的变化——增删改 到来时触发用户事先自定义好的事件句柄）。</li>
<li>一般情况下，触发的事件句柄会把资源变化事件放入一个workQueue，另有线程（可以有多个并行）从中拾取事件进行处理（基于本类型或其他类型资源的Indexer作出正确的决策）。当然这是后话，本文暂不具体展开。</li>
</ol>
<p>下文以三个层次对SharedIndexInformer进行分析，分别是：</p>
<ol>
<li>静态：数据结构，出于利用索引提高读性能、顺序访问、线程安全、缓冲、阻塞等待等目的而实现，如Indexer、Queue、RingGrowing等</li>
<li>动态：运行机制，创建、初始化、运行、运行时的各种goroutine被带起的时机</li>
<li>动静结合：完整的数据处理流程，从访问apiserver获取资源到分发、处理、存储资源的整个流程</li>
</ol>
<p>：如下文出现代码均以release-1.18分支为例。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>SharedIndexInformer，在cache包中提供了对应的实现sharedIndexInformer，其依赖一些自定义的特殊结构，先讲讲它们。</p>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>Store，一个通用的对象存储和处理的接口，可以简单理解成：以一个map为核心（存取数据），并提供丰富的接口方法（Add/Update/Delete/List/ListKeys/Get/GetByKey/Replace/Resync）。</p>
<p>Store在client-go/tools/cache库中并没有直接的实现，而是延伸出了两种新接口：Indexer和Queue，分别作为带索引的Store和维护处理顺序的Store。在具体业务逻辑中，这两者往往结合使用。</p>
<p>Store/Indexer/Queue的继承关系与实现的结构体如下图所示：</p>
<p><img src="/2020/05/01/sharedIndexInformer/index/store.png" alt="store"></p>
<h4 id="Indexer"><a href="#Indexer" class="headerlink" title="Indexer"></a>Indexer</h4><p>实现Indexer的结构体是cache，而cache的核心在ThreadSafeStore（cache封装了ThreadSafeStore的相应方法，而Add/Update/Delete等方法实现上是先调用keyFunc获取对象的key再调用后者相应方法）。</p>
<p>keyFunc作用是计算某个对象的key，相同key的对象就可以确定是同一个对象实例的副本。由于底层数据存储的实现上是一个map，自然就可以用对象实例的新副本覆盖旧副本（或者如DeltaFIFO中那样保存不同版本）。</p>
<p>对于k8s的资源对象，普遍使用的keyFunc是MetaNamespaceKeyFunc，如对Pod就可以计算 <code>Pod的namespace/Pod的name</code> 作为key。</p>
<h5 id="threadSafeMap"><a href="#threadSafeMap" class="headerlink" title="threadSafeMap"></a>threadSafeMap</h5><p>threadSafeMap实现了ThreadSafeStore，具体是如何实现的，有必要贴下其结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type threadSafeMap struct &#123;</span><br><span class="line">	lock  sync.RWMutex</span><br><span class="line">	items map[string]interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">	indexers Indexers</span><br><span class="line">	indices Indices</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type IndexFunc func(obj interface&#123;&#125;) ([]string, error)</span><br><span class="line"></span><br><span class="line">type Index map[string]sets.String</span><br><span class="line"></span><br><span class="line">type Indexers map[string]IndexFunc</span><br><span class="line"></span><br><span class="line">type Indices map[string]Index</span><br></pre></td></tr></table></figure>

<p>简单说明：</p>
<ol>
<li>items作为存储对象key-value对的 核心结构</li>
<li>indexers存储一系列索引方法</li>
<li>indices存储通过将indexers中的索引方法作用在items上计算得出的索引key和索引values(此处有点绕，结合实例才方便理解)</li>
</ol>
<p>举个例子：(模仿<a href="https://github.com/kubernetes/kubernetes/blob/29e4e66b597e8fed0a41b77d99653941ae742103/pkg/controller/nodelifecycle/node_lifecycle_controller.go#L130:1" target="_blank" rel="noopener">nodeNameKeyIndex</a>以nodename为索引)</p>
<p>假设此时items中含我们预设的Pod（精简了结构的），其key-value对如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;default&#x2F;pod1&quot; -&gt; Pod&#123;</span><br><span class="line">    nodename: &quot;node1&quot;</span><br><span class="line">&#125;</span><br><span class="line">&quot;default&#x2F;pod2&quot; -&gt; Pod&#123;</span><br><span class="line">    nodename: &quot;node1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时该Indexer包含一个nodename索引，那么Indexers的key-value对如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;nodename&quot; -&gt;  nodeNameKeyIndex</span><br></pre></td></tr></table></figure>

<p>nodeNameKeyIndex代码逻辑为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func nodeNameKeyIndex(obj interface&#123;&#125;) ([]string, error) &#123;</span><br><span class="line">	pod, ok :&#x3D; obj.(*Pod)</span><br><span class="line">	if !ok &#123;</span><br><span class="line">		return []string&#123;&#125;, nil</span><br><span class="line">	&#125;</span><br><span class="line">	if pod.nodename &#x3D;&#x3D; &quot;&quot; &#123;</span><br><span class="line">		return []string&#123;&#125;, nil</span><br><span class="line">	&#125;</span><br><span class="line">	return []string&#123;pod.nodename&#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么最终indices的数据组织如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;nodename&quot; -&gt; &#123;</span><br><span class="line">    &quot;node1&quot; -&gt; &#123; &quot;default&#x2F;pod1&quot;, &quot;default&#x2F;pod2&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Indexer的使用例子"><a href="#Indexer的使用例子" class="headerlink" title="Indexer的使用例子"></a>Indexer的使用例子</h5><p>代码放在<a href="https://github.com/pangsq/read_code_of_k8s/blob/master/tools/cache/SharedIndexInformer/example/main.go" target="_blank" rel="noopener">SharedIndexInformer/example/main.go</a></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Resource <span class="keyword">struct</span> &#123;</span><br><span class="line">	Namespace <span class="keyword">string</span></span><br><span class="line">	Name      <span class="keyword">string</span></span><br><span class="line">	Nodename  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertEquals</span><span class="params">(obj, target <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> obj != target &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"%v is not equal to %v"</span>, obj, target))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cache.MetaNamespaceKeyFunc是client-go中常用的keyFunc(计算object的key)，将`namespace/name`作为对象的唯一键</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">metaNamespaceKeyFunc</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> res, ok := obj.(*Resource); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> res.Namespace + <span class="string">"/"</span> + res.Name, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"Wrong resource type"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">useIndexer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	metaNamespaceKeyFunc := <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> res, ok := obj.(*Resource); ok &#123;</span><br><span class="line">			<span class="keyword">return</span> res.Namespace + <span class="string">"/"</span> + res.Name, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"Wrong resource type"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 以nodename为键的索引</span></span><br><span class="line">	indexByNodename := <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">		res := obj.(*Resource)</span><br><span class="line">		nodename := res.Nodename</span><br><span class="line">		<span class="keyword">return</span> []<span class="keyword">string</span>&#123;nodename&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 索引可以在初始化Indexer的时候放入，也可以通过AddIndexers添加</span></span><br><span class="line">	resourceIndexer := cache.NewIndexer(cache.KeyFunc(metaNamespaceKeyFunc),</span><br><span class="line">		cache.Indexers&#123;<span class="string">"byNodename"</span>: indexByNodename&#125;)</span><br><span class="line">	defaultRes1 := &amp;Resource&#123;</span><br><span class="line">		Namespace: <span class="string">"default"</span>,</span><br><span class="line">		Name:      <span class="string">"res1"</span>,</span><br><span class="line">		Nodename:  <span class="string">"node1"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	extendRes1 := &amp;Resource&#123;</span><br><span class="line">		Namespace: <span class="string">"extend"</span>,</span><br><span class="line">		Name:      <span class="string">"res1"</span>,</span><br><span class="line">		Nodename:  <span class="string">"node1"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// listWatch的list会调用Replace将现存的事例批量导入到Indexer中</span></span><br><span class="line">	<span class="comment">// resourceVersion在目前client-go实现的几个Store中并没有实际使用到</span></span><br><span class="line">	resourceIndexer.Replace([]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		defaultRes1, extendRes1,</span><br><span class="line">	&#125;, <span class="string">"0"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据对象获取对象</span></span><br><span class="line">	res, _, _ := resourceIndexer.Get(defaultRes1)</span><br><span class="line">	assertEquals(res.(*Resource).Nodename, <span class="string">"node1"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过key获取对象</span></span><br><span class="line">	res, _, _ = resourceIndexer.GetByKey(<span class="string">"default/res1"</span>)</span><br><span class="line">	assertEquals(res.(*Resource).Nodename, <span class="string">"node1"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加对象，如果已存在则是修改已有对象，实际实现上与Update并无二致</span></span><br><span class="line">	newRes := &amp;Resource&#123; <span class="comment">// 构造与res1同一个对象（namespace和name一致即可判定为同一资源对象），仅修改nodename</span></span><br><span class="line">		Namespace: <span class="string">"default"</span>,</span><br><span class="line">		Name:      <span class="string">"res1"</span>,</span><br><span class="line">		Nodename:  <span class="string">"node2"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	resourceIndexer.Add(newRes)</span><br><span class="line">	<span class="comment">// 修改后，存在以node2为键的byNodename索引</span></span><br><span class="line">	reses, _ := resourceIndexer.ByIndex(<span class="string">"byNodename"</span>, <span class="string">"node2"</span>)</span><br><span class="line">	assertEquals(<span class="built_in">len</span>(reses), <span class="number">1</span>)</span><br><span class="line">	assertEquals(reses[<span class="number">0</span>].(*Resource).Name, <span class="string">"res1"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>实现Queue的结构体有FIFO和DeltaFIFO，两者差别在于前者存放对象的一个最新版本，而后者可以存放对象的多个历史版本。</p>
<p>Delta具体是何物，与对象本身有什么联系，通过阅读下面的代码很容易理解。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Deltas []Delta</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Delta <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type   DeltaType</span><br><span class="line">	Object <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Added   DeltaType = <span class="string">"Added"</span></span><br><span class="line">	Updated DeltaType = <span class="string">"Updated"</span></span><br><span class="line">	Deleted DeltaType = <span class="string">"Deleted"</span></span><br><span class="line">	Replaced DeltaType = <span class="string">"Replaced"</span></span><br><span class="line">	Sync DeltaType = <span class="string">"Sync"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>FIFO和DeltaFIFO使用<code>queue []string</code>数组来维护先后顺序，并用sync.Cond来实现Pop时的阻塞（相较于异步非阻塞，同步阻塞的方法对于使用者的心智负担无疑是更小的）</p>
<h5 id="Queue的使用例子"><a href="#Queue的使用例子" class="headerlink" title="Queue的使用例子"></a>Queue的使用例子</h5><p>代码放在<a href="https://github.com/pangsq/read_code_of_k8s/blob/master/tools/cache/SharedIndexInformer/example/main.go" target="_blank" rel="noopener">SharedIndexInformer/example/main.go</a></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">useQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">	queue := cache.NewDeltaFIFO(metaNamespaceKeyFunc, <span class="literal">nil</span>)</span><br><span class="line">	lock := sync.Mutex&#123;&#125;</span><br><span class="line">	cond := sync.NewCond(&amp;lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ch := make(chan struct&#123;&#125;)</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		defaultRes1 := &amp;Resource&#123;</span><br><span class="line">			Namespace: <span class="string">"default"</span>,</span><br><span class="line">			Name:      <span class="string">"res1"</span>,</span><br><span class="line">			Nodename:  <span class="string">"node1"</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		extendRes1 := &amp;Resource&#123;</span><br><span class="line">			Namespace: <span class="string">"extend"</span>,</span><br><span class="line">			Name:      <span class="string">"res1"</span>,</span><br><span class="line">			Nodename:  <span class="string">"node1"</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Replace一般用于初始化</span></span><br><span class="line">		queue.Replace([]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">			defaultRes1, extendRes1,</span><br><span class="line">		&#125;, <span class="string">"0"</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 等待初始化放入(Sync)的资源被消费完毕</span></span><br><span class="line">		lock.Lock()</span><br><span class="line">		<span class="keyword">for</span> !queue.HasSynced() &#123;</span><br><span class="line">			cond.Wait()</span><br><span class="line">		&#125;</span><br><span class="line">		lock.Unlock()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 修改资源</span></span><br><span class="line">		defaultRes2 := &amp;Resource&#123;</span><br><span class="line">			Namespace: <span class="string">"default"</span>,</span><br><span class="line">			Name:      <span class="string">"res2"</span>,</span><br><span class="line">			Nodename:  <span class="string">"node1"</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		newDefaultRes2 := &amp;Resource&#123;</span><br><span class="line">			Namespace: <span class="string">"default"</span>,</span><br><span class="line">			Name:      <span class="string">"res2"</span>,</span><br><span class="line">			Nodename:  <span class="string">"node2"</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		queue.Add(defaultRes2)</span><br><span class="line">		queue.Update(newDefaultRes2)</span><br><span class="line"></span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		queue.Close()</span><br><span class="line">		<span class="comment">// close()</span></span><br><span class="line">	&#125;()</span><br><span class="line">	records := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 设计一个简单的处理逻辑：仅仅负责将资源信息打印出来</span></span><br><span class="line">	<span class="comment">// 真正业务中常是将资源事例放入一个workqueue中</span></span><br><span class="line">	recordFunc := <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		deltas := obj.(cache.Deltas)</span><br><span class="line">		<span class="comment">// 取最新的状态</span></span><br><span class="line">		res := deltas.Newest().Object.(*Resource)</span><br><span class="line"></span><br><span class="line">		record := fmt.Sprintf(<span class="string">"%v/%v is on %s , last change is %v, oldest change is %v"</span>,</span><br><span class="line">			res.Namespace, res.Name, res.Nodename, deltas.Newest().Type, deltas.Oldest().Type)</span><br><span class="line">		records = <span class="built_in">append</span>(records, record)</span><br><span class="line">		<span class="comment">// fmt.Println(record)</span></span><br><span class="line">		cond.Signal()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		_, err := queue.Pop(cache.PopProcessFunc(recordFunc))</span><br><span class="line">		<span class="comment">// 一般处理器会限流</span></span><br><span class="line">		time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			assertEquals(err, cache.ErrFIFOClosed)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// for _, rec := range records &#123;</span></span><br><span class="line">	<span class="comment">// 	fmt.Println(rec)</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	assertEquals(records[<span class="number">0</span>], <span class="string">"default/res1 is on node1 , last change is Sync, oldest change is Sync"</span>)     <span class="comment">// 按照顺序，default/res1是最先被添加到Queue的</span></span><br><span class="line">	assertEquals(records[<span class="number">1</span>], <span class="string">"extend/res1 is on node1 , last change is Sync, oldest change is Sync"</span>)      <span class="comment">// 按照顺序，extend/res1是第二个被添加到Queue的</span></span><br><span class="line">	assertEquals(records[<span class="number">2</span>], <span class="string">"default/res2 is on node2 , last change is Updated, oldest change is Added"</span>) <span class="comment">// default/res2最后加入，Deltas中存在它的两个版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="RingGrowing"><a href="#RingGrowing" class="headerlink" title="RingGrowing"></a>RingGrowing</h4><p>一个可增长的环形buffer，作为读写速度不一致时的缓冲区。</p>
<h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>SharedIndexInformer的创建一般有两种：直接创建、借助工厂类。</p>
<h4 id="直接创建"><a href="#直接创建" class="headerlink" title="直接创建"></a>直接创建</h4><p>直接上<a href="https://github.com/pangsq/read_code_of_k8s/blob/master/tools/cache/SharedIndexInformer/example/main.go" target="_blank" rel="noopener">例子</a></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createSharedIndexInformer</span><span class="params">(c *kubernetes.Clientset)</span> <span class="title">cache</span>.<span class="title">SharedIndexInformer</span></span> &#123;</span><br><span class="line">	namespace := v1.NamespaceAll</span><br><span class="line">	podListWatcher := cache.NewListWatchFromClient(c.CoreV1().RESTClient(), <span class="string">"pods"</span>, namespace, fields.Everything())</span><br><span class="line">	<span class="comment">// 也可以选择下面这种写法</span></span><br><span class="line">	<span class="comment">// podListWatcher = &amp;cache.ListWatch&#123;</span></span><br><span class="line">	<span class="comment">// 	ListFunc: func(options metav1.ListOptions) (runtime.Object, error) &#123;</span></span><br><span class="line">	<span class="comment">// 		return c.CoreV1().Pods(namespace).List(context.TODO(), options)</span></span><br><span class="line">	<span class="comment">// 	&#125;,</span></span><br><span class="line">	<span class="comment">// 	WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) &#123;</span></span><br><span class="line">	<span class="comment">// 		return c.CoreV1().Pods(namespace).Watch(context.TODO(), options)</span></span><br><span class="line">	<span class="comment">// 	&#125;,</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	informer := cache.NewSharedIndexInformer(podListWatcher, &amp;v1.Pod&#123;&#125;, <span class="number">0</span>, cache.Indexers&#123;&#125;)</span><br><span class="line">	<span class="comment">// go informer.Run(make(chan struct&#123;&#125;)) // informer.Run本身是阻塞的，所以一般另起一个goroutine；暂时先不启动</span></span><br><span class="line">	<span class="keyword">return</span> informer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="借助工厂类"><a href="#借助工厂类" class="headerlink" title="借助工厂类"></a>借助工厂类</h4><p>这种方式更鼓励使用，client-go也为此针对每个资源写了相应的构造方法，见<a href="https://github.com/kubernetes/client-go/tree/release-1.18/informers" target="_blank" rel="noopener">informers</a></p>
<p><a href="https://github.com/pangsq/read_code_of_k8s/blob/master/tools/cache/SharedIndexInformer/example/main.go" target="_blank" rel="noopener">例子</a>如下</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createSharedIndexInformerByFactory</span><span class="params">(c *kubernetes.Clientset)</span> <span class="params">(cache.SharedIndexInformer, informers.SharedInformerFactory)</span></span> &#123;</span><br><span class="line">	factory := informers.NewSharedInformerFactoryWithOptions(c, <span class="number">0</span>, informers.WithNamespace(v1.NamespaceAll))</span><br><span class="line">	<span class="comment">// factory.Start(make(chan struct&#123;&#125;)) // factory.Start非阻塞；暂时先不启动</span></span><br><span class="line">	<span class="keyword">return</span> factory.Core().V1().Pods().Informer(), factory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EventHandler"><a href="#EventHandler" class="headerlink" title="EventHandler"></a>EventHandler</h3><p>在informer启动之前向informer注册事件句柄；启动过程中也可以添加，但一般不鼓励。</p>
<p>对于同一个SharedIndexerInformer，可以多次使用AddEventHandler，给其注册零或多组EventHandler。（猜测这就是Shared这个前缀的来历</p>
<p>假设想要打印每个pod的变化事件，代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">informer.AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">	AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		key, _ := cache.MetaNamespaceKeyFunc(obj)</span><br><span class="line">		fmt.Println(<span class="string">"add a pod "</span>, key)</span><br><span class="line">	&#125;,</span><br><span class="line">	UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old <span class="keyword">interface</span>&#123;&#125;, <span class="built_in">new</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		key, _ := cache.MetaNamespaceKeyFunc(<span class="built_in">new</span>)</span><br><span class="line">		fmt.Println(<span class="string">"update a pod "</span>, key)</span><br><span class="line">	&#125;,</span><br><span class="line">	DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		key, _ := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)</span><br><span class="line">		fmt.Println(<span class="string">"delete a pod "</span>, key)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h3><p>启动的例子代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runSharedIndexInformerByFactory</span><span class="params">(informer cache.SharedIndexInformer, factory informers.SharedInformerFactory)</span></span> &#123;</span><br><span class="line">	withEventHandler(informer)</span><br><span class="line">	ctx, _ := context.WithTimeout(context.Background(), time.Second*<span class="number">10</span>)</span><br><span class="line">	fmt.Println(<span class="string">"### Start Informer By Factory"</span>)</span><br><span class="line">	<span class="comment">// 一般情况下，例如常驻的controller-manager中的controller会传入一个永不close的channel</span></span><br><span class="line">	<span class="comment">// factory.Start会调用注册在factory中的所有informer的Run方法</span></span><br><span class="line">	factory.Start(ctx.Done())</span><br><span class="line">	<span class="comment">// 由于informer刚启动时会从apiserver拉取大量当前的资源实例状态，所以总是等待这些这些资源实例被处理完毕(EventHandler)之后，再进行具体的业务逻辑</span></span><br><span class="line">	<span class="keyword">if</span> !factory.WaitForCacheSync(ctx.Done())[reflect.TypeOf(&amp;v1.Pod&#123;&#125;)] &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"timed out waiting for caches to sync"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;-ctx.Done()</span><br><span class="line">	fmt.Println(<span class="string">"### End Informer"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再分析下SharedIndexInformer的<a href="https://sourcegraph.com/github.com/kubernetes/client-go@release-1.18/-/blob/tools/cache/shared_informer.go#L336:31&tab=def" target="_blank" rel="noopener">Run</a>方法。</p>
<p>它做了这么几件事：</p>
<ol>
<li>使用defer处理线程奔溃</li>
<li>创建一个deltaFIFO</li>
<li>通过New(c *Config)方法创建一个Controller</li>
<li>另起一个协程运行cacheMutationDetector.Run -&gt; 监控Store中对象不被修改</li>
<li>另起一个协程运行processor.run -&gt; 由资源实例的变化事件（从deltaFIFO读取）触发EventHandler，期间用到一个RingGrowing来进行缓冲</li>
<li>阻塞地运行controller.Run -&gt; 通过reflector的listerWatcher不断获取实例，放入Indexer和deltaFIFO中</li>
</ol>
<h3 id="Goroutine及函数调用链路"><a href="#Goroutine及函数调用链路" class="headerlink" title="Goroutine及函数调用链路"></a>Goroutine及函数调用链路</h3><ol>
<li>从sharedIndexInformer.Run出发，（不考虑cacheMutationDetector）有两条函数调用路径：1.负责数据的生产；2.负责数据的消费</li>
<li>函数前带go说明另起了协程（实际代码中不一定是直接使用的go关键字），带loop说明是一个循环操作，带multi说明是多次调用（例如对deltas/listeners的遍历）</li>
</ol>
<img src="/2020/05/01/sharedIndexInformer/index/trace.png" width="1000" hegiht="600" align="center">

<p>由上图可知，最终所有的资源实例对象存储在Indexer中，每次实例的变化通知到EventHandler。</p>
<h2 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h2><img src="/2020/05/01/sharedIndexInformer/index/flow.png" width="1000" hegiht="600" align="center">

<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><p>client-go还存在一个与SharedIndexInformer功能相似的组件——Controller，两者区别在于：</p>
<ol>
<li>创建Controller时调用NewIndexerInformer，产生两个返回值——Indexer和Controller，Indexer存储资源对象，Controller负责通过Reflector获取资源对象和产生通知；而SharedIndexInformer封装地更好。</li>
<li>Controller中的EventHandler有且只能有一个，在NewIndexerInformer创建Controller时就需要指定</li>
<li>SharedIndexInformer可以选择性开启MutationDetector（用于监控缓存的资源对象是否被修改。约定想要修改资源时，要先deep copy一份在新副本上修改）</li>
<li>SharedIndexInformer的实现sharedIndexInformer使用了一个Controller</li>
</ol>
<blockquote><p>同步自 <a href="https://github.com/pangsq/read_code_of_k8s/blob/master/tools/cache/SharedIndexInformer/SharedIndexInformer.md" target="_blank" rel="noopener">https://github.com/pangsq/read_code_of_k8s/blob/master/tools/cache/SharedIndexInformer/SharedIndexInformer.md</a></p>
</blockquote>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By 锋寒</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>